diff -Naur linux-3.19.old/include/sound/rt286.h linux-3.19/include/sound/rt286.h
--- linux-3.19.old/include/sound/rt286.h	2015-03-24 17:40:26.479837908 -0800
+++ linux-3.19/include/sound/rt286.h	2015-03-24 18:29:35.278015573 -0800
@@ -14,6 +14,7 @@
 struct rt286_platform_data {
 	bool cbj_en; /*combo jack enable*/
 	bool gpio2_en; /*GPIO2 enable*/
+	bool suspend_power_off; /* power is off during suspend */
 };
 
 #endif
diff -Naur linux-3.19.old/include/sound/rt5640.h linux-3.19/include/sound/rt5640.h
--- linux-3.19.old/include/sound/rt5640.h	2015-03-24 17:40:26.479837908 -0800
+++ linux-3.19/include/sound/rt5640.h	2015-03-24 18:29:35.278015573 -0800
@@ -16,10 +16,6 @@
 	bool in1_diff;
 	bool in2_diff;
 
-	bool dmic_en;
-	bool dmic1_data_pin; /* 0 = IN1P; 1 = GPIO3 */
-	bool dmic2_data_pin; /* 0 = IN1N; 1 = GPIO4 */
-
 	int ldo1_en; /* GPIO for LDO1_EN */
 };
 
diff -Naur linux-3.19.old/include/sound/rt5677.h linux-3.19/include/sound/rt5677.h
--- linux-3.19.old/include/sound/rt5677.h	2015-03-24 17:40:26.479837908 -0800
+++ linux-3.19/include/sound/rt5677.h	2015-03-24 18:29:35.278015573 -0800
@@ -12,13 +12,30 @@
 #ifndef __LINUX_SND_RT5677_H
 #define __LINUX_SND_RT5677_H
 
+enum rt5677_micbias {
+	RT5677_MICBIAS_1_476V = 0,
+	RT5677_MICBIAS_2_970V = 1,
+	RT5677_MICBIAS_1_242V = 2,
+	RT5677_MICBIAS_2_475V = 3,
+};
+
 enum rt5677_dmic2_clk {
 	RT5677_DMIC_CLK1 = 0,
 	RT5677_DMIC_CLK2 = 1,
 };
 
+enum rt5677_pdm_clk_div {
+	RT5677_PDM_CLK_DIV1 = 0,
+	RT5677_PDM_CLK_DIV2 = 1,
+	RT5677_PDM_CLK_DIV4 = 2,
+	RT5677_PDM_CLK_DIV3 = 3,
+};
 
 struct rt5677_platform_data {
+	/* MICBIAS output voltage control */
+	enum rt5677_micbias micbias1;
+	/* Select codec internal 1.8V as DACREF source optionally */
+	bool internal_dacref_en;
 	/* IN1/IN2/LOUT1/LOUT2/LOUT3 can optionally be differential */
 	bool in1_diff;
 	bool in2_diff;
@@ -27,9 +44,13 @@
 	bool lout3_diff;
 	/* DMIC2 clock source selection */
 	enum rt5677_dmic2_clk dmic2_clk_pin;
+	/* System clock to PDM filter divider */
+	enum rt5677_pdm_clk_div pdm_clk_div;
 
 	/* configures GPIO, 0 - floating, 1 - pulldown, 2 - pullup */
 	u8 gpio_config[6];
+	/* Asynchronous Sample Rate Converter can be optionally enabled */
+	bool asrc_en;
 
 	/* jd1 can select 0 ~ 3 as OFF, GPIO1, GPIO2 and GPIO3 respectively */
 	unsigned int jd1_gpio;
diff -Naur linux-3.19.old/include/sound/soc-dai.h linux-3.19/include/sound/soc-dai.h
--- linux-3.19.old/include/sound/soc-dai.h	2015-03-24 17:40:26.499837908 -0800
+++ linux-3.19/include/sound/soc-dai.h	2015-03-24 18:38:32.868031593 -0800
@@ -206,6 +206,7 @@
 	/* DAI description */
 	const char *name;
 	unsigned int id;
+	int ac97_control;
 	unsigned int base;
 
 	/* DAI driver callbacks */
@@ -215,8 +216,6 @@
 	int (*resume)(struct snd_soc_dai *dai);
 	/* compress dai */
 	bool compress_dai;
-	/* DAI is also used for the control bus */
-	bool bus_control;
 
 	/* ops */
 	const struct snd_soc_dai_ops *ops;
@@ -242,6 +241,7 @@
 	const char *name;
 	int id;
 	struct device *dev;
+	void *ac97_pdata;	/* platform_data for the ac97 codec */
 
 	/* driver ops */
 	struct snd_soc_dai_driver *driver;
@@ -268,6 +268,7 @@
 	unsigned int sample_bits;
 
 	/* parent platform/codec */
+	struct snd_soc_platform *platform;
 	struct snd_soc_codec *codec;
 	struct snd_soc_component *component;
 
@@ -275,6 +276,8 @@
 	unsigned int tx_mask;
 	unsigned int rx_mask;
 
+	struct snd_soc_card *card;
+
 	struct list_head list;
 };
 
diff -Naur linux-3.19.old/include/sound/soc-dapm.h linux-3.19/include/sound/soc-dapm.h
--- linux-3.19.old/include/sound/soc-dapm.h	2015-03-24 17:40:26.499837908 -0800
+++ linux-3.19/include/sound/soc-dapm.h	2015-03-24 18:38:32.868031593 -0800
@@ -107,6 +107,10 @@
 {	.id = snd_soc_dapm_mux, .name = wname, \
 	SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), \
 	.kcontrol_news = wcontrols, .num_kcontrols = 1}
+#define SND_SOC_DAPM_VIRT_MUX(wname, wreg, wshift, winvert, wcontrols) \
+	SND_SOC_DAPM_MUX(wname, wreg, wshift, winvert, wcontrols)
+#define SND_SOC_DAPM_VALUE_MUX(wname, wreg, wshift, winvert, wcontrols) \
+	SND_SOC_DAPM_MUX(wname, wreg, wshift, winvert, wcontrols)
 
 /* Simplified versions of above macros, assuming wncontrols = ARRAY_SIZE(wcontrols) */
 #define SOC_PGA_ARRAY(wname, wreg, wshift, winvert,\
@@ -162,6 +166,10 @@
 	SND_SOC_DAPM_INIT_REG_VAL(wreg, wshift, winvert), \
 	.kcontrol_news = wcontrols, .num_kcontrols = 1, \
 	.event = wevent, .event_flags = wflags}
+#define SND_SOC_DAPM_VIRT_MUX_E(wname, wreg, wshift, winvert, wcontrols, \
+	wevent, wflags) \
+	SND_SOC_DAPM_MUX_E(wname, wreg, wshift, winvert, wcontrols, wevent, \
+		wflags)
 
 /* additional sequencing control within an event type */
 #define SND_SOC_DAPM_PGA_S(wname, wsubseq, wreg, wshift, winvert, \
@@ -296,12 +304,16 @@
  	.get = snd_soc_dapm_get_enum_double, \
  	.put = snd_soc_dapm_put_enum_double, \
   	.private_value = (unsigned long)&xenum }
+#define SOC_DAPM_ENUM_VIRT(xname, xenum) \
+	SOC_DAPM_ENUM(xname, xenum)
 #define SOC_DAPM_ENUM_EXT(xname, xenum, xget, xput) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
 	.info = snd_soc_info_enum_double, \
 	.get = xget, \
 	.put = xput, \
 	.private_value = (unsigned long)&xenum }
+#define SOC_DAPM_VALUE_ENUM(xname, xenum) \
+	SOC_DAPM_ENUM(xname, xenum)
 #define SOC_DAPM_PIN_SWITCH(xname) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname " Switch", \
 	.info = snd_soc_dapm_info_pin_switch, \
@@ -432,10 +444,9 @@
 int snd_soc_dapm_ignore_suspend(struct snd_soc_dapm_context *dapm,
 				const char *pin);
 void snd_soc_dapm_auto_nc_pins(struct snd_soc_card *card);
-unsigned int dapm_kcontrol_get_value(const struct snd_kcontrol *kcontrol);
 
 /* Mostly internal - should not normally be used */
-void dapm_mark_endpoints_dirty(struct snd_soc_card *card);
+void dapm_mark_io_dirty(struct snd_soc_dapm_context *dapm);
 
 /* dapm path query */
 int snd_soc_dapm_dai_get_connected_widgets(struct snd_soc_dai *dai, int stream,
@@ -508,9 +519,9 @@
 
 	/* status */
 	u32 connect:1;	/* source and sink widgets are connected */
+	u32 walked:1;	/* path has been walked */
 	u32 walking:1;  /* path is in the process of being walked */
 	u32 weak:1;	/* path ignored for power management */
-	u32 is_supply:1;	/* At least one of the connected widgets is a supply */
 
 	int (*connected)(struct snd_soc_dapm_widget *source,
 			 struct snd_soc_dapm_widget *sink);
@@ -544,13 +555,11 @@
 	unsigned char active:1;			/* active stream on DAC, ADC's */
 	unsigned char connected:1;		/* connected codec pin */
 	unsigned char new:1;			/* cnew complete */
+	unsigned char ext:1;			/* has external widgets */
 	unsigned char force:1;			/* force state */
 	unsigned char ignore_suspend:1;         /* kept enabled over suspend */
 	unsigned char new_power:1;		/* power from this run */
 	unsigned char power_checked:1;		/* power checked this run */
-	unsigned char is_supply:1;		/* Widget is a supply type widget */
-	unsigned char is_sink:1;		/* Widget is a sink type widget */
-	unsigned char is_source:1;		/* Widget is a source type widget */
 	int subseq;				/* sort within widget type */
 
 	int (*power_check)(struct snd_soc_dapm_widget *w);
@@ -569,7 +578,6 @@
 	struct list_head sinks;
 
 	/* used during DAPM updates */
-	struct list_head work_list;
 	struct list_head power_list;
 	struct list_head dirty;
 	int inputs;
@@ -591,13 +599,13 @@
 	enum snd_soc_bias_level suspend_bias_level;
 	struct delayed_work delayed_work;
 	unsigned int idle_bias_off:1; /* Use BIAS_OFF instead of STANDBY */
-	/* Go to BIAS_OFF in suspend if the DAPM context is idle */
-	unsigned int suspend_bias_off:1;
+
 	void (*seq_notifier)(struct snd_soc_dapm_context *,
 			     enum snd_soc_dapm_type, int);
 
 	struct device *dev; /* from parent - for debug */
 	struct snd_soc_component *component; /* parent component */
+	struct snd_soc_codec *codec; /* parent codec */
 	struct snd_soc_card *card; /* parent card */
 
 	/* used during DAPM updates */
diff -Naur linux-3.19.old/include/sound/soc-dpcm.h linux-3.19/include/sound/soc-dpcm.h
--- linux-3.19.old/include/sound/soc-dpcm.h	2015-03-24 17:40:26.499837908 -0800
+++ linux-3.19/include/sound/soc-dpcm.h	2015-03-24 18:38:32.868031593 -0800
@@ -102,8 +102,6 @@
 	/* state and update */
 	enum snd_soc_dpcm_update runtime_update;
 	enum snd_soc_dpcm_state state;
-
-	int trigger_pending; /* trigger cmd + 1 if pending, 0 if not */
 };
 
 /* can this BE stop and free */
diff -Naur linux-3.19.old/include/sound/soc.h linux-3.19/include/sound/soc.h
--- linux-3.19.old/include/sound/soc.h	2015-03-24 17:40:26.506504574 -0800
+++ linux-3.19/include/sound/soc.h	2015-03-24 18:35:23.018025924 -0800
@@ -36,11 +36,6 @@
 	{.reg = xreg, .rreg = xreg, .shift = shift_left, \
 	.rshift = shift_right, .max = xmax, .platform_max = xmax, \
 	.invert = xinvert, .autodisable = xautodisable})
-#define SOC_DOUBLE_S_VALUE(xreg, shift_left, shift_right, xmin, xmax, xsign_bit, xinvert, xautodisable) \
-	((unsigned long)&(struct soc_mixer_control) \
-	{.reg = xreg, .rreg = xreg, .shift = shift_left, \
-	.rshift = shift_right, .min = xmin, .max = xmax, .platform_max = xmax, \
-	.sign_bit = xsign_bit, .invert = xinvert, .autodisable = xautodisable})
 #define SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, xautodisable) \
 	SOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert, xautodisable)
 #define SOC_SINGLE_VALUE_EXT(xreg, xmax, xinvert) \
@@ -176,9 +171,11 @@
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
 		  SNDRV_CTL_ELEM_ACCESS_READWRITE, \
 	.tlv.p  = (tlv_array), \
-	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\
-	.put = snd_soc_put_volsw, \
-	.private_value = SOC_DOUBLE_S_VALUE(xreg, 0, 8, xmin, xmax, 7, 0, 0) }
+	.info   = snd_soc_info_volsw_s8, .get = snd_soc_get_volsw_s8, \
+	.put    = snd_soc_put_volsw_s8, \
+	.private_value = (unsigned long)&(struct soc_mixer_control) \
+		{.reg = xreg, .min = xmin, .max = xmax, \
+		 .platform_max = xmax} }
 #define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xitems, xtexts) \
 {	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \
 	.items = xitems, .texts = xtexts, \
@@ -199,6 +196,8 @@
 	.info = snd_soc_info_enum_double, \
 	.get = snd_soc_get_enum_double, .put = snd_soc_put_enum_double, \
 	.private_value = (unsigned long)&xenum }
+#define SOC_VALUE_ENUM(xname, xenum) \
+	SOC_ENUM(xname, xenum)
 #define SOC_SINGLE_EXT(xname, xreg, xshift, xmax, xinvert,\
 	 xhandler_get, xhandler_put) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
@@ -280,7 +279,7 @@
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE | \
 		  SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK, \
 	.tlv.c = (snd_soc_bytes_tlv_callback), \
-	.info = snd_soc_bytes_info_ext, \
+	.info = snd_soc_info_bytes_ext, \
 	.private_value = (unsigned long)&(struct soc_bytes_ext) \
 		{.max = xcount, .get = xhandler_get, .put = xhandler_put, } }
 #define SOC_SINGLE_XR_SX(xname, xregbase, xregcount, xnbits, \
@@ -369,6 +368,8 @@
 
 typedef int (*hw_write_t)(void *,const char* ,int);
 
+extern struct snd_ac97_bus_ops *soc_ac97_ops;
+
 enum snd_soc_pcm_subclass {
 	SND_SOC_PCM_CLASS_PCM	= 0,
 	SND_SOC_PCM_CLASS_BE	= 1,
@@ -410,9 +411,13 @@
 			 const struct snd_soc_component_driver *cmpnt_drv,
 			 struct snd_soc_dai_driver *dai_drv, int num_dai);
 void snd_soc_unregister_component(struct device *dev);
+int snd_soc_cache_sync(struct snd_soc_codec *codec);
 int snd_soc_cache_init(struct snd_soc_codec *codec);
 int snd_soc_cache_exit(struct snd_soc_codec *codec);
-
+int snd_soc_cache_write(struct snd_soc_codec *codec,
+			unsigned int reg, unsigned int value);
+int snd_soc_cache_read(struct snd_soc_codec *codec,
+		       unsigned int reg, unsigned int *value);
 int snd_soc_platform_read(struct snd_soc_platform *platform,
 					unsigned int reg);
 int snd_soc_platform_write(struct snd_soc_platform *platform,
@@ -467,6 +472,7 @@
 			    int count, struct snd_soc_jack_gpio *gpios);
 void snd_soc_jack_free_gpios(struct snd_soc_jack *jack, int count,
 			struct snd_soc_jack_gpio *gpios);
+void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio);
 #else
 static inline int snd_soc_jack_add_gpios(struct snd_soc_jack *jack, int count,
 					 struct snd_soc_jack_gpio *gpios)
@@ -486,6 +492,10 @@
 					   struct snd_soc_jack_gpio *gpios)
 {
 }
+
+void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio)
+{
+}
 #endif
 
 /* codec register bit access */
@@ -497,29 +507,14 @@
 int snd_soc_test_bits(struct snd_soc_codec *codec, unsigned int reg,
 				unsigned int mask, unsigned int value);
 
-#ifdef CONFIG_SND_SOC_AC97_BUS
-struct snd_ac97 *snd_soc_alloc_ac97_codec(struct snd_soc_codec *codec);
-struct snd_ac97 *snd_soc_new_ac97_codec(struct snd_soc_codec *codec);
-void snd_soc_free_ac97_codec(struct snd_ac97 *ac97);
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num);
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec);
 
 int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops);
 int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
 		struct platform_device *pdev);
 
-extern struct snd_ac97_bus_ops *soc_ac97_ops;
-#else
-static inline int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
-	struct platform_device *pdev)
-{
-	return 0;
-}
-
-static inline int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
-{
-	return 0;
-}
-#endif
-
 /*
  *Controls
  */
@@ -557,6 +552,12 @@
 	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo);
 int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
@@ -696,17 +697,6 @@
 struct snd_soc_component_driver {
 	const char *name;
 
-	/* Default control and setup, added after probe() is run */
-	const struct snd_kcontrol_new *controls;
-	unsigned int num_controls;
-	const struct snd_soc_dapm_widget *dapm_widgets;
-	unsigned int num_dapm_widgets;
-	const struct snd_soc_dapm_route *dapm_routes;
-	unsigned int num_dapm_routes;
-
-	int (*probe)(struct snd_soc_component *);
-	void (*remove)(struct snd_soc_component *);
-
 	/* DT */
 	int (*of_xlate_dai_name)(struct snd_soc_component *component,
 				 struct of_phandle_args *args,
@@ -714,10 +704,6 @@
 	void (*seq_notifier)(struct snd_soc_component *, enum snd_soc_dapm_type,
 		int subseq);
 	int (*stream_event)(struct snd_soc_component *, int event);
-
-	/* probe ordering - for components with runtime dependencies */
-	int probe_order;
-	int remove_order;
 };
 
 struct snd_soc_component {
@@ -731,7 +717,6 @@
 
 	unsigned int ignore_pmdown_time:1; /* pmdown_time is ignored at stop */
 	unsigned int registered_as_component:1;
-	unsigned int probed:1;
 
 	struct list_head list;
 
@@ -750,35 +735,9 @@
 
 	struct mutex io_mutex;
 
-#ifdef CONFIG_DEBUG_FS
-	struct dentry *debugfs_root;
-#endif
-
-	/*
-	* DO NOT use any of the fields below in drivers, they are temporary and
-	* are going to be removed again soon. If you use them in driver code the
-	* driver will be marked as BROKEN when these fields are removed.
-	*/
-
 	/* Don't use these, use snd_soc_component_get_dapm() */
 	struct snd_soc_dapm_context dapm;
 	struct snd_soc_dapm_context *dapm_ptr;
-
-	const struct snd_kcontrol_new *controls;
-	unsigned int num_controls;
-	const struct snd_soc_dapm_widget *dapm_widgets;
-	unsigned int num_dapm_widgets;
-	const struct snd_soc_dapm_route *dapm_routes;
-	unsigned int num_dapm_routes;
-	struct snd_soc_codec *codec;
-
-	int (*probe)(struct snd_soc_component *);
-	void (*remove)(struct snd_soc_component *);
-
-#ifdef CONFIG_DEBUG_FS
-	void (*init_debugfs)(struct snd_soc_component *component);
-	const char *debugfs_prefix;
-#endif
 };
 
 /* SoC Audio Codec device */
@@ -786,18 +745,26 @@
 	struct device *dev;
 	const struct snd_soc_codec_driver *driver;
 
+	struct mutex mutex;
 	struct list_head list;
 	struct list_head card_list;
 
 	/* runtime */
+	struct snd_ac97 *ac97;  /* for ad-hoc ac97 devices */
 	unsigned int cache_bypass:1; /* Suppress access to the cache */
 	unsigned int suspended:1; /* Codec is in suspend PM state */
+	unsigned int probed:1; /* Codec has been probed */
+	unsigned int ac97_registered:1; /* Codec has been AC97 registered */
+	unsigned int ac97_created:1; /* Codec has been created by SoC */
 	unsigned int cache_init:1; /* codec cache has been initialized */
+	u32 cache_only;  /* Suppress writes to hardware */
+	u32 cache_sync; /* Cache needs to be synced to hardware */
 
 	/* codec IO */
 	void *control_data; /* codec control (i2c/3wire) data */
 	hw_write_t hw_write;
 	void *reg_cache;
+	struct mutex cache_rw_mutex;
 
 	/* component */
 	struct snd_soc_component component;
@@ -806,6 +773,7 @@
 	struct snd_soc_dapm_context dapm;
 
 #ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_codec_root;
 	struct dentry *debugfs_reg;
 #endif
 };
@@ -847,12 +815,15 @@
 	int (*set_bias_level)(struct snd_soc_codec *,
 			      enum snd_soc_bias_level level);
 	bool idle_bias_off;
-	bool suspend_bias_off;
 
 	void (*seq_notifier)(struct snd_soc_dapm_context *,
 			     enum snd_soc_dapm_type, int);
 
 	bool ignore_pmdown_time;  /* Doesn't benefit from pmdown delay */
+
+	/* probe ordering - for components with runtime dependencies */
+	int probe_order;
+	int remove_order;
 };
 
 /* SoC platform interface */
@@ -860,12 +831,22 @@
 
 	int (*probe)(struct snd_soc_platform *);
 	int (*remove)(struct snd_soc_platform *);
+	int (*suspend)(struct snd_soc_dai *dai);
+	int (*resume)(struct snd_soc_dai *dai);
 	struct snd_soc_component_driver component_driver;
 
 	/* pcm creation and destruction */
 	int (*pcm_new)(struct snd_soc_pcm_runtime *);
 	void (*pcm_free)(struct snd_pcm *);
 
+	/* Default control and setup, added after probe() is run */
+	const struct snd_kcontrol_new *controls;
+	int num_controls;
+	const struct snd_soc_dapm_widget *dapm_widgets;
+	int num_dapm_widgets;
+	const struct snd_soc_dapm_route *dapm_routes;
+	int num_dapm_routes;
+
 	/*
 	 * For platform caused delay reporting.
 	 * Optional.
@@ -879,12 +860,19 @@
 	/* platform stream compress ops */
 	const struct snd_compr_ops *compr_ops;
 
+	/* probe ordering - for components with runtime dependencies */
+	int probe_order;
+	int remove_order;
+
+	/* platform IO - used for platform DAPM */
+	unsigned int (*read)(struct snd_soc_platform *, unsigned int);
+	int (*write)(struct snd_soc_platform *, unsigned int, unsigned int);
 	int (*bespoke_trigger)(struct snd_pcm_substream *, int);
 };
 
 struct snd_soc_dai_link_component {
 	const char *name;
-	struct device_node *of_node;
+	const struct device_node *of_node;
 	const char *dai_name;
 };
 
@@ -892,9 +880,16 @@
 	struct device *dev;
 	const struct snd_soc_platform_driver *driver;
 
+	unsigned int suspended:1; /* platform is suspended */
+	unsigned int probed:1;
+
 	struct list_head list;
 
 	struct snd_soc_component component;
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_platform_root;
+#endif
 };
 
 struct snd_soc_dai_link {
@@ -909,7 +904,7 @@
 	 * only for codec to codec links, or systems using device tree.
 	 */
 	const char *cpu_name;
-	struct device_node *cpu_of_node;
+	const struct device_node *cpu_of_node;
 	/*
 	 * You MAY specify the DAI name of the CPU DAI. If this information is
 	 * omitted, the CPU-side DAI is matched using .cpu_name/.cpu_of_node
@@ -921,7 +916,7 @@
 	 * DT/OF node, but not both.
 	 */
 	const char *codec_name;
-	struct device_node *codec_of_node;
+	const struct device_node *codec_of_node;
 	/* You MUST specify the DAI name within the codec */
 	const char *codec_dai_name;
 
@@ -934,7 +929,7 @@
 	 * do not need a platform.
 	 */
 	const char *platform_name;
-	struct device_node *platform_of_node;
+	const struct device_node *platform_of_node;
 	int be_id;	/* optional ID for machine driver BE identification */
 
 	const struct snd_soc_pcm_stream *params;
@@ -986,7 +981,7 @@
 	 * DT/OF node, but not both.
 	 */
 	const char *dev_name;
-	struct device_node *of_node;
+	const struct device_node *of_node;
 
 	/*
 	 * optional map of kcontrol, widget and path name prefixes that are
@@ -1003,10 +998,10 @@
 	 * DT/OF node, but not both.
 	 */
 	const char *codec_name;
-	struct device_node *codec_of_node;
+	const struct device_node *codec_of_node;
 
 	/* codec/machine specific init - e.g. add machine controls */
-	int (*init)(struct snd_soc_component *component);
+	int (*init)(struct snd_soc_dapm_context *dapm);
 };
 
 /* SoC card */
@@ -1124,7 +1119,6 @@
 	struct snd_soc_platform *platform;
 	struct snd_soc_dai *codec_dai;
 	struct snd_soc_dai *cpu_dai;
-	struct snd_soc_component *component; /* Only valid for AUX dev rtds */
 
 	struct snd_soc_dai **codec_dais;
 	unsigned int num_codecs;
@@ -1260,17 +1254,6 @@
 int snd_soc_write(struct snd_soc_codec *codec, unsigned int reg,
 	unsigned int val);
 
-/**
- * snd_soc_cache_sync() - Sync the register cache with the hardware
- * @codec: CODEC to sync
- *
- * Note: This function will call regcache_sync()
- */
-static inline int snd_soc_cache_sync(struct snd_soc_codec *codec)
-{
-	return regcache_sync(codec->component.regmap);
-}
-
 /* component IO */
 int snd_soc_component_read(struct snd_soc_component *component,
 	unsigned int reg, unsigned int *val);
@@ -1284,44 +1267,8 @@
 int snd_soc_component_test_bits(struct snd_soc_component *component,
 	unsigned int reg, unsigned int mask, unsigned int value);
 
-#ifdef CONFIG_REGMAP
-
-void snd_soc_component_init_regmap(struct snd_soc_component *component,
+int snd_soc_component_init_io(struct snd_soc_component *component,
 	struct regmap *regmap);
-void snd_soc_component_exit_regmap(struct snd_soc_component *component);
-
-/**
- * snd_soc_codec_init_regmap() - Initialize regmap instance for the CODEC
- * @codec: The CODEC for which to initialize the regmap instance
- * @regmap: The regmap instance that should be used by the CODEC
- *
- * This function allows deferred assignment of the regmap instance that is
- * associated with the CODEC. Only use this if the regmap instance is not yet
- * ready when the CODEC is registered. The function must also be called before
- * the first IO attempt of the CODEC.
- */
-static inline void snd_soc_codec_init_regmap(struct snd_soc_codec *codec,
-	struct regmap *regmap)
-{
-	snd_soc_component_init_regmap(&codec->component, regmap);
-}
-
-/**
- * snd_soc_codec_exit_regmap() - De-initialize regmap instance for the CODEC
- * @codec: The CODEC for which to de-initialize the regmap instance
- *
- * Calls regmap_exit() on the regmap instance associated to the CODEC and
- * removes the regmap instance from the CODEC.
- *
- * This function should only be used if snd_soc_codec_init_regmap() was used to
- * initialize the regmap instance.
- */
-static inline void snd_soc_codec_exit_regmap(struct snd_soc_codec *codec)
-{
-	snd_soc_component_exit_regmap(&codec->component);
-}
-
-#endif
 
 /* device driver data */
 
@@ -1336,37 +1283,26 @@
 	return card->drvdata;
 }
 
-static inline void snd_soc_component_set_drvdata(struct snd_soc_component *c,
-		void *data)
-{
-	dev_set_drvdata(c->dev, data);
-}
-
-static inline void *snd_soc_component_get_drvdata(struct snd_soc_component *c)
-{
-	return dev_get_drvdata(c->dev);
-}
-
 static inline void snd_soc_codec_set_drvdata(struct snd_soc_codec *codec,
 		void *data)
 {
-	snd_soc_component_set_drvdata(&codec->component, data);
+	dev_set_drvdata(codec->dev, data);
 }
 
 static inline void *snd_soc_codec_get_drvdata(struct snd_soc_codec *codec)
 {
-	return snd_soc_component_get_drvdata(&codec->component);
+	return dev_get_drvdata(codec->dev);
 }
 
 static inline void snd_soc_platform_set_drvdata(struct snd_soc_platform *platform,
 		void *data)
 {
-	snd_soc_component_set_drvdata(&platform->component, data);
+	dev_set_drvdata(platform->dev, data);
 }
 
 static inline void *snd_soc_platform_get_drvdata(struct snd_soc_platform *platform)
 {
-	return snd_soc_component_get_drvdata(&platform->component);
+	return dev_get_drvdata(platform->dev);
 }
 
 static inline void snd_soc_pcm_set_drvdata(struct snd_soc_pcm_runtime *rtd,
@@ -1497,9 +1433,6 @@
 				     struct device_node **framemaster);
 int snd_soc_of_get_dai_name(struct device_node *of_node,
 			    const char **dai_name);
-int snd_soc_of_get_dai_link_codecs(struct device *dev,
-				   struct device_node *of_node,
-				   struct snd_soc_dai_link *dai_link);
 
 #include <sound/soc-dai.h>
 
diff -Naur linux-3.19.old/sound/soc/codecs/max98090.c linux-3.19/sound/soc/codecs/max98090.c
--- linux-3.19.old/sound/soc/codecs/max98090.c	2015-03-24 17:38:13.829843638 -0800
+++ linux-3.19/sound/soc/codecs/max98090.c	2015-03-24 18:28:21.328013360 -0800
@@ -11,13 +11,11 @@
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
-#include <linux/of.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
-#include <linux/clk.h>
 #include <sound/jack.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -26,6 +24,10 @@
 #include <sound/max98090.h>
 #include "max98090.h"
 
+#define DEBUG
+#define EXTMIC_METHOD
+#define EXTMIC_METHOD_TEST
+
 /* Allows for sparsely populated register maps */
 static struct reg_default max98090_reg[] = {
 	{ 0x00, 0x00 }, /* 00 Software Reset */
@@ -389,7 +391,6 @@
 static const DECLARE_TLV_DB_SCALE(max98090_alcmakeup_tlv, 0, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_alccomp_tlv, -3100, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_drcexp_tlv, -6600, 100, 0);
-static const DECLARE_TLV_DB_SCALE(max98090_sdg_tlv, 50, 200, 0);
 
 static const unsigned int max98090_mixout_tlv[] = {
 	TLV_DB_RANGE_HEAD(2),
@@ -666,7 +667,7 @@
 	SOC_SINGLE_EXT_TLV("Digital Sidetone Volume",
 		M98090_REG_ADC_SIDETONE, M98090_DVST_SHIFT,
 		M98090_DVST_NUM - 1, 1, max98090_get_enab_tlv,
-		max98090_put_enab_tlv, max98090_sdg_tlv),
+		max98090_put_enab_tlv, max98090_micboost_tlv),
 	SOC_SINGLE_TLV("Digital Coarse Volume", M98090_REG_DAI_PLAYBACK_LEVEL,
 		M98090_DVG_SHIFT, M98090_DVG_NUM - 1, 0,
 		max98090_dvg_tlv),
@@ -806,7 +807,7 @@
 static int max98090_micinput_event(struct snd_soc_dapm_widget *w,
 				 struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
+	struct snd_soc_codec *codec = w->codec;
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 
 	unsigned int val = snd_soc_read(codec, w->reg);
@@ -816,6 +817,7 @@
 	else
 		val = (val & M98090_MIC_PA2EN_MASK) >> M98090_MIC_PA2EN_SHIFT;
 
+
 	if (val >= 1) {
 		if (w->reg == M98090_REG_MIC1_INPUT_LEVEL) {
 			max98090->pa1en = val - 1; /* Update for volatile */
@@ -850,6 +852,102 @@
 	return 0;
 }
 
+/* Save state and shutdown codec. */
+static void max98090_shdn_save(struct snd_soc_codec *codec)
+{
+	unsigned int shutdown_reg;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	regmap_read(max98090->regmap, M98090_REG_DEVICE_SHUTDOWN,
+			&shutdown_reg);
+	/* Shutdown only if needed. */
+	if (shutdown_reg & M98090_SHDNN_MASK) {
+		/* Only save state if state is not saved before. */
+		if (!max98090->state.saved) {
+			regmap_read(max98090->regmap,
+				M98090_REG_LEVEL_CONTROL,
+				&max98090->state.old_level_control);
+			max98090->state.old_shdn = shutdown_reg;
+			max98090->state.saved = 1;
+		}
+
+		/* Enable volume smoothing, disable zero cross.  This will cause
+		 * a quick 40ms ramp to mute on shutdown.
+		 */
+		regmap_write(max98090->regmap,
+			M98090_REG_LEVEL_CONTROL, M98090_VSENN_MASK);
+		regmap_write(max98090->regmap,
+			M98090_REG_DEVICE_SHUTDOWN, 0x00);
+		regcache_mark_dirty(max98090->regmap);
+		msleep(40);
+	}
+}
+
+static void max98090_shdn_restore(struct snd_soc_codec *codec)
+{
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	if (!max98090->state.saved)
+		return;
+
+	/* Turn on codec and restore level control if it was on. */
+	if (max98090->state.old_shdn & M98090_SHDNN_MASK) {
+		regmap_write(max98090->regmap,
+			M98090_REG_LEVEL_CONTROL,
+			max98090->state.old_level_control);
+		mdelay(1); /* Let input path stablize before releasing shdn. */
+		regmap_write(max98090->regmap,
+			M98090_REG_DEVICE_SHUTDOWN, max98090->state.old_shdn);
+		regcache_sync(max98090->regmap);
+		/* Clear saved state. */
+		max98090->state.saved = 0;
+	}
+}
+
+/*
+ * On max98090, DMIC should be enabled when shutdown bit is 0.
+ * However, DAPM does not support customizing procedure to
+ * shutdown codec, update a register, and turn on codec.
+ * In PRE_PMU case, we shutdown codec. After that before POST_PMU,
+ * the shutdown register is not protected. In reality, an extra
+ * shutdown and restore after DMIC is enabled is good enough to make
+ * DMIC works properly even if codec was on when DMIC was turned on.
+ * Max98091 is not subjected to this issue.
+ */
+static int dmic_event(struct snd_soc_dapm_widget *w,
+			 struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+
+	if (max98090->devtype == MAX98091)
+		return 0;
+
+	switch (event) {
+	/* Shutdown codec */
+	case SND_SOC_DAPM_PRE_PMU:
+		mutex_lock(&max98090->mutex);
+		max98090_shdn_save(codec);
+		mutex_unlock(&max98090->mutex);
+		max98090->dmic_post_pmu_done = false;
+		break;
+	/* Shutdown and resotre codec. Use the flag dmic_post_pmu_done to
+	 * save one shutdown/restore cycle because DMICL_ENA and DMICR_ENA
+	 * shares this callback. */
+	case SND_SOC_DAPM_POST_PMU:
+		if (max98090->dmic_post_pmu_done)
+			return 0;
+		mutex_lock(&max98090->mutex);
+		max98090_shdn_save(codec);
+		max98090_shdn_restore(codec);
+		mutex_unlock(&max98090->mutex);
+		max98090->dmic_post_pmu_done = true;
+		break;
+	}
+
+	return 0;
+}
+
 static const char *mic1_mux_text[] = { "IN12", "IN56" };
 
 static SOC_ENUM_SINGLE_DECL(mic1_mux_enum,
@@ -1135,6 +1233,7 @@
 	SOC_DAPM_ENUM("MIXHPRSEL Mux", mixhprsel_mux_enum);
 
 static const struct snd_soc_dapm_widget max98090_dapm_widgets[] = {
+
 	SND_SOC_DAPM_INPUT("MIC1"),
 	SND_SOC_DAPM_INPUT("MIC2"),
 	SND_SOC_DAPM_INPUT("DMICL"),
@@ -1151,16 +1250,16 @@
 
 	SND_SOC_DAPM_SUPPLY("MICBIAS", M98090_REG_INPUT_ENABLE,
 		M98090_MBEN_SHIFT, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("SHDN", M98090_REG_DEVICE_SHUTDOWN,
-		M98090_SHDNN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SDIEN", M98090_REG_IO_CONFIGURATION,
 		M98090_SDIEN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SDOEN", M98090_REG_IO_CONFIGURATION,
 		M98090_SDOEN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("DMICL_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMICL_SHIFT, 0, NULL, 0),
+		 M98090_DIGMICL_SHIFT, 0, dmic_event,
+		 SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("DMICR_ENA", M98090_REG_DIGITAL_MIC_ENABLE,
-		 M98090_DIGMICR_SHIFT, 0, NULL, 0),
+		 M98090_DIGMICR_SHIFT, 0, dmic_event,
+		 SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("AHPF", M98090_REG_FILTER_CONFIG,
 		M98090_AHPF_SHIFT, 0, NULL, 0),
 
@@ -1298,6 +1397,7 @@
 };
 
 static const struct snd_soc_dapm_widget max98091_dapm_widgets[] = {
+
 	SND_SOC_DAPM_INPUT("DMIC3"),
 	SND_SOC_DAPM_INPUT("DMIC4"),
 
@@ -1308,12 +1408,11 @@
 };
 
 static const struct snd_soc_dapm_route max98090_dapm_routes[] = {
+
 	{"MIC1 Input", NULL, "MIC1"},
 	{"MIC2 Input", NULL, "MIC2"},
 
 	{"DMICL", NULL, "DMICL_ENA"},
-	{"DMICL", NULL, "DMICR_ENA"},
-	{"DMICR", NULL, "DMICL_ENA"},
 	{"DMICR", NULL, "DMICR_ENA"},
 	{"DMICL", NULL, "AHPF"},
 	{"DMICR", NULL, "AHPF"},
@@ -1365,8 +1464,6 @@
 	/* Inputs */
 	{"ADCL", NULL, "Left ADC Mixer"},
 	{"ADCR", NULL, "Right ADC Mixer"},
-	{"ADCL", NULL, "SHDN"},
-	{"ADCR", NULL, "SHDN"},
 
 	{"DMIC Mux", "ADC", "ADCL"},
 	{"DMIC Mux", "ADC", "ADCR"},
@@ -1380,8 +1477,6 @@
 
 	{"AIFOUTL", NULL, "LBENL Mux"},
 	{"AIFOUTR", NULL, "LBENR Mux"},
-	{"AIFOUTL", NULL, "SHDN"},
-	{"AIFOUTR", NULL, "SHDN"},
 	{"AIFOUTL", NULL, "SDOEN"},
 	{"AIFOUTR", NULL, "SDOEN"},
 
@@ -1397,15 +1492,11 @@
 	{"STENL Mux", "Sidetone Left", "DMICL"},
 	{"STENR Mux", "Sidetone Right", "ADCR"},
 	{"STENR Mux", "Sidetone Right", "DMICR"},
-	{"DACL", NULL, "STENL Mux"},
-	{"DACR", NULL, "STENR Mux"},
+	{"DACL", "NULL", "STENL Mux"},
+	{"DACR", "NULL", "STENL Mux"},
 
-	{"AIFINL", NULL, "SHDN"},
-	{"AIFINR", NULL, "SHDN"},
 	{"AIFINL", NULL, "SDIEN"},
 	{"AIFINR", NULL, "SDIEN"},
-	{"DACL", NULL, "SHDN"},
-	{"DACR", NULL, "SHDN"},
 
 	/* Left headphone output mixer */
 	{"Left Headphone Mixer", "Left DAC Switch", "DACL"},
@@ -1487,14 +1578,17 @@
 	{"SPKR", NULL, "SPK Right Out"},
 	{"RCVL", NULL, "RCV Left Out"},
 	{"RCVR", NULL, "RCV Right Out"},
+
 };
 
 static const struct snd_soc_dapm_route max98091_dapm_routes[] = {
+
 	/* DMIC inputs */
 	{"DMIC3", NULL, "DMIC3_ENA"},
 	{"DMIC4", NULL, "DMIC4_ENA"},
 	{"DMIC3", NULL, "AHPF"},
 	{"DMIC4", NULL, "AHPF"},
+
 };
 
 static int max98090_add_widgets(struct snd_soc_codec *codec)
@@ -1522,6 +1616,7 @@
 
 		snd_soc_dapm_add_routes(dapm, max98091_dapm_routes,
 			ARRAY_SIZE(max98091_dapm_routes));
+
 	}
 
 	return 0;
@@ -1538,19 +1633,19 @@
 };
 
 static const int user_pclk_rates[] = {
-	13000000, 13000000, 19200000, 19200000,
+	13000000, 13000000
 };
 
 static const int user_lrclk_rates[] = {
-	44100, 48000, 44100, 48000,
+	44100, 48000
 };
 
 static const unsigned long long ni_value[] = {
-	3528, 768, 441, 8
+	3528, 768
 };
 
 static const unsigned long long mi_value[] = {
-	8125, 1625, 1500, 25
+	8125, 1625
 };
 
 static void max98090_configure_bclk(struct snd_soc_codec *codec)
@@ -1650,11 +1745,15 @@
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	struct max98090_cdata *cdata;
 	u8 regval;
+	int ret = 0;
 
 	max98090->dai_fmt = fmt;
 	cdata = &max98090->dai[0];
 
 	if (fmt != cdata->fmt) {
+		mutex_lock(&max98090->mutex);
+		/* Shutdown to config clock mode. */
+		max98090_shdn_save(codec);
 		cdata->fmt = fmt;
 
 		regval = 0;
@@ -1690,7 +1789,8 @@
 		case SND_SOC_DAIFMT_CBM_CFS:
 		default:
 			dev_err(codec->dev, "DAI clock mode unsupported");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto exit_reset_shdn;
 		}
 		snd_soc_write(codec, M98090_REG_MASTER_MODE, regval);
 
@@ -1708,7 +1808,8 @@
 			/* Not supported mode */
 		default:
 			dev_err(codec->dev, "DAI format unsupported");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto exit_reset_shdn;
 		}
 
 		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
@@ -1725,7 +1826,8 @@
 			break;
 		default:
 			dev_err(codec->dev, "DAI invert mode unsupported");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto exit_reset_shdn;
 		}
 
 		/*
@@ -1741,7 +1843,10 @@
 			M98090_REG_INTERFACE_FORMAT, regval);
 	}
 
-	return 0;
+exit_reset_shdn:
+	max98090_shdn_restore(codec);
+	mutex_unlock(&max98090->mutex);
+	return ret;
 }
 
 static int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,
@@ -1791,23 +1896,14 @@
 		break;
 
 	case SND_SOC_BIAS_PREPARE:
-		/*
-		 * SND_SOC_BIAS_PREPARE is called while preparing for a
-		 * transition to ON or away from ON. If current bias_level
-		 * is SND_SOC_BIAS_ON, then it is preparing for a transition
-		 * away from ON. Disable the clock in that case, otherwise
-		 * enable it.
-		 */
-		if (!IS_ERR(max98090->mclk)) {
-			if (codec->dapm.bias_level == SND_SOC_BIAS_ON)
-				clk_disable_unprepare(max98090->mclk);
-			else
-				clk_prepare_enable(max98090->mclk);
-		}
 		break;
 
 	case SND_SOC_BIAS_STANDBY:
 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
+			mutex_lock(&max98090->mutex);
+			snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+			mutex_unlock(&max98090->mutex);
 			ret = regcache_sync(max98090->regmap);
 			if (ret != 0) {
 				dev_err(codec->dev,
@@ -1821,6 +1917,10 @@
 		/* Set internal pull-up to lowest power mode */
 		snd_soc_update_bits(codec, M98090_REG_JACK_DETECT,
 			M98090_JDWK_MASK, M98090_JDWK_MASK);
+		mutex_lock(&max98090->mutex);
+		snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, 0);
+		mutex_unlock(&max98090->mutex);
 		regcache_mark_dirty(max98090->regmap);
 		break;
 	}
@@ -1828,78 +1928,74 @@
 	return 0;
 }
 
-static const int dmic_divisors[] = { 2, 3, 4, 5, 6, 8 };
-
-static const int comp_lrclk_rates[] = {
-	8000, 16000, 32000, 44100, 48000, 96000
-};
-
-struct dmic_table {
+/*
+ * In the following table the first column in the settings arrays is the
+ * setting for the DMIC_FREQ field of register 0x14, the remaining columns
+ * are the settings for the DMIC_COMP field of register 0x14.
+ */
+struct {
 	int pclk;
-	struct {
-		int freq;
-		int comp[6]; /* One each for 8, 16, 32, 44.1, 48, and 96 kHz */
-	} settings[6]; /* One for each dmic divisor. */
-};
-
-static const struct dmic_table dmic_table[] = { /* One for each pclk freq. */
+	int settings[6][7];
+} static const dmic_table[] = {
 	{
-		.pclk = 11289600,
+		.pclk = 11289600,				// PCLK
 		.settings = {
-			{ .freq = 2, .comp = { 7, 8, 3, 3, 3, 3 } },
-			{ .freq = 1, .comp = { 7, 8, 2, 2, 2, 2 } },
-			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
-			{ .freq = 0, .comp = { 7, 8, 6, 6, 6, 6 } },
-			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
-			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
-		},
+			{ 2, 7, 8, 3, 3, 3, 3 },	// fPCLK / 2
+			{ 1, 7, 8, 2, 2, 2, 2 },	// fPCLK / 3
+			{ 0, 7, 8, 3, 3, 3, 3 },	// fPCLK / 4
+			{ 0, 7, 8, 6, 6, 6, 6 },	// fPCLK / 5
+			{ 0, 7, 8, 3, 3, 3, 3 },	// fPCLK / 6
+			{ 0, 7, 8, 3, 3, 3, 3 },	// fPCLK / 8
+		}
 	},
 	{
-		.pclk = 12000000,
+		.pclk = 12000000,				// PCLK
 		.settings = {
-			{ .freq = 2, .comp = { 7, 8, 3, 3, 3, 3 } },
-			{ .freq = 1, .comp = { 7, 8, 2, 2, 2, 2 } },
-			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
-			{ .freq = 0, .comp = { 7, 8, 5, 5, 6, 6 } },
-			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
-			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ 2, 7, 8, 3, 3, 3, 3 },	// fPCLK / 2
+			{ 1, 7, 8, 2, 2, 2, 2 },	// fPCLK / 3
+			{ 0, 7, 8, 3, 3, 3, 3 },	// fPCLK / 4
+			{ 0, 7, 8, 5, 5, 6, 6 },	// fPCLK / 5
+			{ 0, 7, 8, 3, 3, 3, 3 },	// fPCLK / 6
+			{ 0, 7, 8, 3, 3, 3, 3 },	// fPCLK / 8
 		}
 	},
 	{
-		.pclk = 12288000,
+		.pclk = 12288000,				// PCLK
 		.settings = {
-			{ .freq = 2, .comp = { 7, 8, 3, 3, 3, 3 } },
-			{ .freq = 1, .comp = { 7, 8, 2, 2, 2, 2 } },
-			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
-			{ .freq = 0, .comp = { 7, 8, 6, 6, 6, 6 } },
-			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
-			{ .freq = 0, .comp = { 7, 8, 3, 3, 3, 3 } },
+			{ 2, 7, 8, 3, 3, 3, 3 },	// fPCLK / 2
+			{ 1, 7, 8, 2, 2, 2, 2 },	// fPCLK / 3
+			{ 0, 7, 8, 3, 3, 3, 3 },	// fPCLK / 4
+			{ 0, 7, 8, 6, 6, 6, 6 },	// fPCLK / 5
+			{ 0, 7, 8, 3, 3, 3, 3 },	// fPCLK / 6
+			{ 0, 7, 8, 3, 3, 3, 3 },	// fPCLK / 8
 		}
 	},
 	{
-		.pclk = 13000000,
+		.pclk = 13000000,				// PCLK
 		.settings = {
-			{ .freq = 2, .comp = { 7, 8, 1, 1, 1, 1 } },
-			{ .freq = 1, .comp = { 7, 8, 0, 0, 0, 0 } },
-			{ .freq = 0, .comp = { 7, 8, 1, 1, 1, 1 } },
-			{ .freq = 0, .comp = { 7, 8, 4, 4, 5, 5 } },
-			{ .freq = 0, .comp = { 7, 8, 1, 1, 1, 1 } },
-			{ .freq = 0, .comp = { 7, 8, 1, 1, 1, 1 } },
+			{ 2, 7, 8, 1, 1, 1, 1 },	// fPCLK / 2
+			{ 1, 7, 8, 0, 0, 0, 0 },	// fPCLK / 3
+			{ 0, 7, 8, 1, 1, 1, 1 },	// fPCLK / 4
+			{ 0, 7, 8, 4, 4, 5, 5 },	// fPCLK / 5
+			{ 0, 7, 8, 1, 1, 1, 1 },	// fPCLK / 6
+			{ 0, 7, 8, 1, 1, 1, 1 },	// fPCLK / 8
 		}
 	},
 	{
-		.pclk = 19200000,
+		.pclk = 19200000,				// PCLK
 		.settings = {
-			{ .freq = 2, .comp = { 0, 0, 0, 0, 0, 0 } },
-			{ .freq = 1, .comp = { 7, 8, 1, 1, 1, 1 } },
-			{ .freq = 0, .comp = { 7, 8, 5, 5, 6, 6 } },
-			{ .freq = 0, .comp = { 7, 8, 2, 2, 3, 3 } },
-			{ .freq = 0, .comp = { 7, 8, 1, 1, 2, 2 } },
-			{ .freq = 0, .comp = { 7, 8, 5, 5, 6, 6 } },
+			{ 0, 0, 0, 0, 0, 0, 0 },	// fPCLK / 2
+			{ 2, 7, 8, 1, 1, 1, 1 },	// fPCLK / 3
+			{ 2, 7, 8, 5, 5, 6, 6 },	// fPCLK / 4
+			{ 1, 7, 8, 2, 2, 3, 3 },	// fPCLK / 5
+			{ 0, 7, 8, 1, 1, 2, 2 },	// fPCLK / 6
+			{ 0, 7, 8, 5, 5, 6, 6 },	// fPCLK / 8
 		}
 	},
 };
 
+static int dmic_divisors[] = { 2, 3, 4, 5, 6, 8 };
+
 static int max98090_find_divisor(int target_freq, int pclk)
 {
 	int current_diff = INT_MAX;
@@ -1908,8 +2004,8 @@
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(dmic_divisors); i++) {
-		test_diff = abs(target_freq - (pclk / dmic_divisors[i]));
-		if (test_diff < current_diff) {
+		test_diff = target_freq - (pclk / dmic_divisors[i]);
+		if (abs(test_diff) < abs(current_diff)) {
 			current_diff = test_diff;
 			divisor_index = i;
 		}
@@ -1942,8 +2038,12 @@
 	return -EINVAL;
 }
 
+static const int comp_lrclk_rates[] = {
+	8000, 16000, 32000, 44100, 48000, 96000
+};
+
 static int max98090_configure_dmic(struct max98090_priv *max98090,
-				   int target_dmic_clk, int pclk, int fs)
+		int target_dmic_clk, int pclk, int fs)
 {
 	int micclk_index;
 	int pclk_index;
@@ -1962,17 +2062,17 @@
 			break;
 	}
 
-	dmic_freq = dmic_table[pclk_index].settings[micclk_index].freq;
-	dmic_comp = dmic_table[pclk_index].settings[micclk_index].comp[i];
+	dmic_freq = dmic_table[pclk_index].settings[micclk_index][0];
+	dmic_comp = dmic_table[pclk_index].settings[micclk_index][i+1];
 
 	regmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_ENABLE,
-			   M98090_MICCLK_MASK,
-			   micclk_index << M98090_MICCLK_SHIFT);
+			M98090_MICCLK_MASK,
+			micclk_index << M98090_MICCLK_SHIFT);
 
 	regmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_CONFIG,
-			   M98090_DMIC_COMP_MASK | M98090_DMIC_FREQ_MASK,
-			   dmic_comp << M98090_DMIC_COMP_SHIFT |
-			   dmic_freq << M98090_DMIC_FREQ_SHIFT);
+			M98090_DMIC_COMP_MASK | M98090_DMIC_FREQ_MASK,
+			dmic_comp << M98090_DMIC_COMP_SHIFT |
+			dmic_freq << M98090_DMIC_FREQ_SHIFT);
 
 	return 0;
 }
@@ -1984,13 +2084,26 @@
 	struct snd_soc_codec *codec = dai->codec;
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	struct max98090_cdata *cdata;
+	unsigned int new_lrclk = params_rate(params);
+	snd_pcm_format_t new_pcm_format = params_format(params);
+	bool lrclk_changed = (new_lrclk != max98090->lrclk);
+	bool format_changed = (new_pcm_format != max98090->pcm_format);
+	int ret = 0;
+
+	max98090->lrclk = new_lrclk;
+	max98090->pcm_format = new_pcm_format;
 
 	cdata = &max98090->dai[0];
 	max98090->bclk = snd_soc_params_to_bclk(params);
 	if (params_channels(params) == 1)
 		max98090->bclk *= 2;
 
-	max98090->lrclk = params_rate(params);
+	/* Checks if we needs to shutdown and config format, clock or mode. */
+	if (!lrclk_changed && !format_changed && !max98090->sysclk_changed)
+		return 0;
+
+	mutex_lock(&max98090->mutex);
+	max98090_shdn_save(codec);
 
 	switch (params_width(params)) {
 	case 16:
@@ -1998,7 +2111,8 @@
 			M98090_WS_MASK, 0);
 		break;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
+		goto exit_reset_shdn;
 	}
 
 	if (max98090->master)
@@ -2022,10 +2136,18 @@
 		snd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,
 			M98090_DHF_MASK, M98090_DHF_MASK);
 
-	max98090_configure_dmic(max98090, max98090->dmic_freq, max98090->pclk,
-				max98090->lrclk);
+	max98090_configure_dmic(max98090, FS_DMIC_TARGET, max98090->pclk,
+		max98090->lrclk);
+	/* Mark that the sysclk change which results in pclk change, dmic
+	 * configuration change, and bclk configuration change (for master mode)
+	 * have been handled. */
+	max98090->sysclk_changed = false;
 
-	return 0;
+
+exit_reset_shdn:
+	max98090_shdn_restore(codec);
+	mutex_unlock(&max98090->mutex);
+	return ret;
 }
 
 /*
@@ -2036,15 +2158,18 @@
 {
 	struct snd_soc_codec *codec = dai->codec;
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
 
 	/* Requested clock frequency is already setup */
 	if (freq == max98090->sysclk)
 		return 0;
 
-	if (!IS_ERR(max98090->mclk)) {
-		freq = clk_round_rate(max98090->mclk, freq);
-		clk_set_rate(max98090->mclk, freq);
-	}
+	/*
+	 * sysclk is not set before. Shutdown codec and set system clock
+	 * registers.
+	 */
+	mutex_lock(&max98090->mutex);
+	max98090_shdn_save(codec);
 
 	/* Setup clocks for slave mode, and using the PLL
 	 * PSCLK = 0x01 (when master clk is 10MHz to 20MHz)
@@ -2065,12 +2190,20 @@
 		max98090->pclk = freq >> 2;
 	} else {
 		dev_err(codec->dev, "Invalid master clock frequency\n");
-		return -EINVAL;
+		ret = -EINVAL;
+		goto exit_reset_shdn;
 	}
 
 	max98090->sysclk = freq;
+	max98090->sysclk_changed = true;
 
-	return 0;
+	dev_info(codec->dev, "mclk %d, pclk %d\n", max98090->sysclk,
+			max98090->pclk);
+
+exit_reset_shdn:
+	max98090_shdn_restore(codec);
+	mutex_unlock(&max98090->mutex);
+	return ret;
 }
 
 static int max98090_dai_digital_mute(struct snd_soc_dai *codec_dai, int mute)
@@ -2085,102 +2218,6 @@
 	return 0;
 }
 
-static int max98090_dai_trigger(struct snd_pcm_substream *substream, int cmd,
-				struct snd_soc_dai *dai)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (!max98090->master && dai->active == 1)
-			queue_delayed_work(system_power_efficient_wq,
-					   &max98090->pll_det_enable_work,
-					   msecs_to_jiffies(10));
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (!max98090->master && dai->active == 1)
-			schedule_work(&max98090->pll_det_disable_work);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static void max98090_pll_det_enable_work(struct work_struct *work)
-{
-	struct max98090_priv *max98090 =
-		container_of(work, struct max98090_priv,
-			     pll_det_enable_work.work);
-	struct snd_soc_codec *codec = max98090->codec;
-	unsigned int status, mask;
-
-	/*
-	 * Clear status register in order to clear possibly already occurred
-	 * PLL unlock. If PLL hasn't still locked, the status will be set
-	 * again and PLL unlock interrupt will occur.
-	 * Note this will clear all status bits
-	 */
-	regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &status);
-
-	/*
-	 * Queue jack work in case jack state has just changed but handler
-	 * hasn't run yet
-	 */
-	regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);
-	status &= mask;
-	if (status & M98090_JDET_MASK)
-		queue_delayed_work(system_power_efficient_wq,
-				   &max98090->jack_work,
-				   msecs_to_jiffies(100));
-
-	/* Enable PLL unlock interrupt */
-	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
-			    M98090_IULK_MASK,
-			    1 << M98090_IULK_SHIFT);
-}
-
-static void max98090_pll_det_disable_work(struct work_struct *work)
-{
-	struct max98090_priv *max98090 =
-		container_of(work, struct max98090_priv, pll_det_disable_work);
-	struct snd_soc_codec *codec = max98090->codec;
-
-	cancel_delayed_work_sync(&max98090->pll_det_enable_work);
-
-	/* Disable PLL unlock interrupt */
-	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
-			    M98090_IULK_MASK, 0);
-}
-
-static void max98090_pll_work(struct work_struct *work)
-{
-	struct max98090_priv *max98090 =
-		container_of(work, struct max98090_priv, pll_work);
-	struct snd_soc_codec *codec = max98090->codec;
-
-	if (!snd_soc_codec_is_active(codec))
-		return;
-
-	dev_info(codec->dev, "PLL unlocked\n");
-
-	/* Toggle shutdown OFF then ON */
-	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
-			    M98090_SHDNN_MASK, 0);
-	msleep(10);
-	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
-			    M98090_SHDNN_MASK, M98090_SHDNN_MASK);
-
-	/* Give PLL time to lock */
-	msleep(10);
-}
-
 static void max98090_jack_work(struct work_struct *work)
 {
 	struct max98090_priv *max98090 = container_of(work,
@@ -2268,20 +2305,61 @@
 			    SND_JACK_HEADSET | SND_JACK_BTN_0);
 
 	snd_soc_dapm_sync(dapm);
+
+	/* unmask the IRQ */
+	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+		M98090_IJDET_MASK, 1 << M98090_IJDET_SHIFT);
 }
 
-static irqreturn_t max98090_interrupt(int irq, void *data)
+
+static void max98090_pll_work(struct work_struct *work)
 {
-	struct max98090_priv *max98090 = data;
+	struct max98090_priv *max98090 = container_of(work,
+		struct max98090_priv,
+		pll_work);
 	struct snd_soc_codec *codec = max98090->codec;
+	unsigned int pll;
+	int i;
+
+	if (!snd_soc_codec_is_active(codec))
+		return;
+
+	for (i = 0; i < 10; i++) {
+
+		/* toggle shutdown OFF then ON */
+		mutex_lock(&max98090->mutex);
+		snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+			M98090_SHDNN_MASK, 0);
+		snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+			M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+		mutex_unlock(&max98090->mutex);
+
+		/* give PLL time to lock */
+		msleep(1);
+
+		/* check that we have lock now */
+		regmap_read(max98090->regmap,
+			M98090_REG_DEVICE_STATUS, &pll);
+		if (!(pll & M98090_ULK_MASK))
+			goto unmask;
+	}
+	dev_err(codec->dev, "PLL lock failed 0x%x retrying\n", pll);
+
+unmask:
+	/* unmask the PLL interrupt */
+	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+		M98090_IULK_MASK, 1 << M98090_IULK_SHIFT);
+	dev_err(codec->dev, "PLL after IRQ active fix %d is  0x%x\n", i, pll);
+}
+
+static irqreturn_t max98090_interrupt(int irq, void *data)
+{
+	struct snd_soc_codec *codec = data;
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	int ret;
 	unsigned int mask;
 	unsigned int active;
 
-	/* Treat interrupt before codec is initialized as spurious */
-	if (codec == NULL)
-		return IRQ_NONE;
-
 	dev_dbg(codec->dev, "***** max98090_interrupt *****\n");
 
 	ret = regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);
@@ -2293,8 +2371,8 @@
 		return IRQ_NONE;
 	}
 
+	/* this clears the IRQ */
 	ret = regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &active);
-
 	if (ret != 0) {
 		dev_err(codec->dev,
 			"failed to read M98090_REG_DEVICE_STATUS: %d\n",
@@ -2310,6 +2388,10 @@
 	if (!active)
 		return IRQ_NONE;
 
+	/* mask the interrupts - unmask after handlers/work completed */
+	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+			active, active);
+
 	if (active & M98090_CLD_MASK)
 		dev_err(codec->dev, "M98090_CLD_MASK\n");
 
@@ -2392,7 +2474,6 @@
 	.set_tdm_slot = max98090_set_tdm_slot,
 	.hw_params = max98090_dai_hw_params,
 	.digital_mute = max98090_dai_digital_mute,
-	.trigger = max98090_dai_trigger,
 };
 
 static struct snd_soc_dai_driver max98090_dai[] = {
@@ -2416,19 +2497,26 @@
 }
 };
 
+static void max98090_handle_pdata(struct snd_soc_codec *codec)
+{
+	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
+	struct max98090_pdata *pdata = max98090->pdata;
+
+	if (!pdata) {
+		dev_err(codec->dev, "No platform data\n");
+		return;
+	}
+
+}
+
 static int max98090_probe(struct snd_soc_codec *codec)
 {
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 	struct max98090_cdata *cdata;
-	enum max98090_type devtype;
 	int ret = 0;
 
 	dev_dbg(codec->dev, "max98090_probe\n");
 
-	max98090->mclk = devm_clk_get(codec->dev, "mclk");
-	if (PTR_ERR(max98090->mclk) == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-
 	max98090->codec = codec;
 
 	/* Reset the codec, the DSP core, and disable all interrupts */
@@ -2439,6 +2527,11 @@
 	max98090->sysclk = (unsigned)-1;
 	max98090->pclk = (unsigned)-1;
 	max98090->master = false;
+	max98090->sysclk_changed = false;
+	max98090->pcm_format = (unsigned)-1;
+	max98090->dmic_post_pmu_done = false;
+	max98090->state.saved = 0;
+	mutex_init(&max98090->mutex);
 
 	cdata = &max98090->dai[0];
 	cdata->rate = (unsigned)-1;
@@ -2447,6 +2540,7 @@
 	max98090->lin_state = 0;
 	max98090->pa1en = 0;
 	max98090->pa2en = 0;
+	max98090->extmic_mux = 0;
 
 	ret = snd_soc_read(codec, M98090_REG_REVISION_ID);
 	if (ret < 0) {
@@ -2456,34 +2550,36 @@
 	}
 
 	if ((ret >= M98090_REVA) && (ret <= M98090_REVA + 0x0f)) {
-		devtype = MAX98090;
+		max98090->devtype = MAX98090;
 		dev_info(codec->dev, "MAX98090 REVID=0x%02x\n", ret);
 	} else if ((ret >= M98091_REVA) && (ret <= M98091_REVA + 0x0f)) {
-		devtype = MAX98091;
+		max98090->devtype = MAX98091;
 		dev_info(codec->dev, "MAX98091 REVID=0x%02x\n", ret);
 	} else {
-		devtype = MAX98090;
+		max98090->devtype = MAX98090;
 		dev_err(codec->dev, "Unrecognized revision 0x%02x\n", ret);
 	}
 
-	if (max98090->devtype != devtype) {
-		dev_warn(codec->dev, "Mismatch in DT specified CODEC type.\n");
-		max98090->devtype = devtype;
-	}
-
 	max98090->jack_state = M98090_JACK_STATE_NO_HEADSET;
 
 	INIT_DELAYED_WORK(&max98090->jack_work, max98090_jack_work);
-	INIT_DELAYED_WORK(&max98090->pll_det_enable_work,
-			  max98090_pll_det_enable_work);
-	INIT_WORK(&max98090->pll_det_disable_work,
-		  max98090_pll_det_disable_work);
 	INIT_WORK(&max98090->pll_work, max98090_pll_work);
 
 	/* Enable jack detection */
 	snd_soc_write(codec, M98090_REG_JACK_DETECT,
 		M98090_JDETEN_MASK | M98090_JDEB_25MS);
 
+	/* Register for interrupts */
+	dev_dbg(codec->dev, "irq = %d\n", max98090->irq);
+
+	ret = request_threaded_irq(max98090->irq, NULL,
+		max98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+		"max98090_interrupt", codec);
+	if (ret < 0) {
+		dev_err(codec->dev, "request_irq failed: %d\n",
+			ret);
+	}
+
 	/*
 	 * Clear any old interrupts.
 	 * An old interrupt ocurring prior to installing the ISR
@@ -2509,6 +2605,8 @@
 	snd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,
 		M98090_MBVSEL_MASK, M98090_MBVSEL_2V8);
 
+	max98090_handle_pdata(codec);
+
 	max98090_add_widgets(codec);
 
 err_access:
@@ -2520,10 +2618,6 @@
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
 
 	cancel_delayed_work_sync(&max98090->jack_work);
-	cancel_delayed_work_sync(&max98090->pll_det_enable_work);
-	cancel_work_sync(&max98090->pll_det_disable_work);
-	cancel_work_sync(&max98090->pll_work);
-	max98090->codec = NULL;
 
 	return 0;
 }
@@ -2575,12 +2669,9 @@
 
 	max98090->devtype = driver_data;
 	i2c_set_clientdata(i2c, max98090);
+	max98090->control_data = i2c;
 	max98090->pdata = i2c->dev.platform_data;
-
-	ret = of_property_read_u32(i2c->dev.of_node, "maxim,dmic-freq",
-				   &max98090->dmic_freq);
-	if (ret < 0)
-		max98090->dmic_freq = MAX98090_DEFAULT_DMIC_FREQ;
+	max98090->irq = i2c->irq;
 
 	max98090->regmap = devm_regmap_init_i2c(i2c, &max98090_regmap);
 	if (IS_ERR(max98090->regmap)) {
@@ -2589,15 +2680,6 @@
 		goto err_enable;
 	}
 
-	ret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,
-		max98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-		"max98090_interrupt", max98090);
-	if (ret < 0) {
-		dev_err(&i2c->dev, "request_irq failed: %d\n",
-			ret);
-		return ret;
-	}
-
 	ret = snd_soc_register_codec(&i2c->dev,
 			&soc_codec_dev_max98090, max98090_dai,
 			ARRAY_SIZE(max98090_dai));
@@ -2611,7 +2693,7 @@
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_RUNTIME
 static int max98090_runtime_resume(struct device *dev)
 {
 	struct max98090_priv *max98090 = dev_get_drvdata(dev);
@@ -2635,7 +2717,7 @@
 }
 #endif
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 static int max98090_resume(struct device *dev)
 {
 	struct max98090_priv *max98090 = dev_get_drvdata(dev);
@@ -2667,18 +2749,10 @@
 
 static const struct i2c_device_id max98090_i2c_id[] = {
 	{ "max98090", MAX98090 },
-	{ "max98091", MAX98091 },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, max98090_i2c_id);
 
-static const struct of_device_id max98090_of_match[] = {
-	{ .compatible = "maxim,max98090", },
-	{ .compatible = "maxim,max98091", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, max98090_of_match);
-
 #ifdef CONFIG_ACPI
 static struct acpi_device_id max98090_acpi_match[] = {
 	{ "193C9890", MAX98090 },
@@ -2692,7 +2766,6 @@
 		.name = "max98090",
 		.owner = THIS_MODULE,
 		.pm = &max98090_pm,
-		.of_match_table = of_match_ptr(max98090_of_match),
 		.acpi_match_table = ACPI_PTR(max98090_acpi_match),
 	},
 	.probe  = max98090_i2c_probe,
diff -Naur linux-3.19.old/sound/soc/codecs/max98090.h linux-3.19/sound/soc/codecs/max98090.h
--- linux-3.19.old/sound/soc/codecs/max98090.h	2015-03-24 17:38:13.829843638 -0800
+++ linux-3.19/sound/soc/codecs/max98090.h	2015-03-24 18:28:21.328013360 -0800
@@ -11,11 +11,15 @@
 #ifndef _MAX98090_H
 #define _MAX98090_H
 
-/*
- * The default operating frequency for a DMIC attached to the codec.
- * This can be overridden by a device tree property.
+#include <linux/version.h>
+
+/* One can override the Linux version here with an explicit version number */
+#define M98090_LINUX_VERSION LINUX_VERSION_CODE
+
+/* If using a digital microphone then set FS_DMIC_TARGET to the desired
+ * operating frequency in Hertz
  */
-#define MAX98090_DEFAULT_DMIC_FREQ		2500000
+#define FS_DMIC_TARGET	2500000
 
 /*
  * MAX98090 Register Definitions
@@ -1503,6 +1507,9 @@
 #define M98090_REVID_WIDTH		8
 #define M98090_REVID_NUM		(1<<M98090_REVID_WIDTH)
 
+#define M98090_BYTE1(w) ((w >> 8) & 0xff)
+#define M98090_BYTE0(w) (w & 0xff)
+
 /* Silicon revision number */
 #define M98090_REVA			0x40
 #define M98091_REVA			0x50
@@ -1517,22 +1524,29 @@
 	unsigned int fmt;
 };
 
+/* Save state when temporarily shutting down the codec to change registers that
+ * must only be changes while in software shutdown.
+ */
+struct max98090_shdn_state {
+	int old_shdn;
+	int old_level_control;
+	bool saved;
+};
+
 struct max98090_priv {
 	struct regmap *regmap;
 	struct snd_soc_codec *codec;
 	enum max98090_type devtype;
+	void *control_data;
 	struct max98090_pdata *pdata;
-	struct clk *mclk;
 	unsigned int sysclk;
 	unsigned int pclk;
 	unsigned int bclk;
 	unsigned int lrclk;
-	u32 dmic_freq;
 	struct max98090_cdata dai[1];
+	int irq;
 	int jack_state;
 	struct delayed_work jack_work;
-	struct delayed_work pll_det_enable_work;
-	struct work_struct pll_det_disable_work;
 	struct work_struct pll_work;
 	struct snd_soc_jack *jack;
 	unsigned int dai_fmt;
@@ -1541,8 +1555,14 @@
 	u8 lin_state;
 	unsigned int pa1en;
 	unsigned int pa2en;
+	unsigned int extmic_mux;
 	unsigned int sidetone;
 	bool master;
+	bool sysclk_changed;
+	snd_pcm_format_t pcm_format;
+	struct mutex mutex;
+	struct max98090_shdn_state state;
+	bool dmic_post_pmu_done;
 };
 
 int max98090_mic_detect(struct snd_soc_codec *codec,
diff -Naur linux-3.19.old/sound/soc/codecs/rt286.c linux-3.19/sound/soc/codecs/rt286.c
--- linux-3.19.old/sound/soc/codecs/rt286.c	2015-03-24 17:38:13.859843637 -0800
+++ linux-3.19/sound/soc/codecs/rt286.c	2015-03-24 18:28:21.328013360 -0800
@@ -17,7 +17,6 @@
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
-#include <linux/dmi.h>
 #include <linux/acpi.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -40,7 +39,8 @@
 	struct snd_soc_codec *codec;
 	struct rt286_platform_data pdata;
 	struct i2c_client *i2c;
-	struct snd_soc_jack *jack;
+	struct snd_soc_jack *hp_jack;
+	struct snd_soc_jack *mic_jack;
 	struct delayed_work jack_detect_work;
 	int sys_clk;
 	int clk_id;
@@ -191,7 +191,7 @@
 	u8 data[4];
 	int ret, i;
 
-	/* handle index registers */
+	/*handle index registers*/
 	if (reg <= 0xff) {
 		rt286_hw_write(client, RT286_COEF_INDEX, reg);
 		for (i = 0; i < INDEX_CACHE_SIZE; i++) {
@@ -234,7 +234,7 @@
 	__be32 be_reg;
 	unsigned int index, vid, buf = 0x0;
 
-	/* handle index registers */
+	/*handle index registers*/
 	if (reg <= 0xff) {
 		rt286_hw_write(client, RT286_COEF_INDEX, reg);
 		reg = RT286_PROC_COEF;
@@ -272,7 +272,6 @@
 	return 0;
 }
 
-#ifdef CONFIG_PM
 static void rt286_index_sync(struct snd_soc_codec *codec)
 {
 	struct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);
@@ -283,7 +282,6 @@
 				  rt286->index_cache[i].def);
 	}
 }
-#endif
 
 static int rt286_support_power_controls[] = {
 	RT286_DAC_OUT1,
@@ -300,67 +298,99 @@
 
 static int rt286_jack_detect(struct rt286_priv *rt286, bool *hp, bool *mic)
 {
-	unsigned int val, buf;
+	unsigned int val, buf, vm = 0;
+	int i;
 
 	*hp = false;
 	*mic = false;
 
+	if (!rt286->codec)
+		return 0;
+
+	/* power on HV,VERF */
+	snd_soc_dapm_force_enable_pin(&rt286->codec->dapm, "VREF");
+	snd_soc_dapm_force_enable_pin(&rt286->codec->dapm, "LDO1");
+	snd_soc_dapm_sync(&rt286->codec->dapm);
 	if (rt286->pdata.cbj_en) {
 		regmap_read(rt286->regmap, RT286_GET_HP_SENSE, &buf);
 		*hp = buf & 0x80000000;
 		if (*hp) {
-			/* power on HV,VERF */
-			regmap_update_bits(rt286->regmap,
-				RT286_DC_GAIN, 0x200, 0x200);
-
-			snd_soc_dapm_force_enable_pin(&rt286->codec->dapm,
-							"HV");
-			snd_soc_dapm_force_enable_pin(&rt286->codec->dapm,
-							"VREF");
 			/* power LDO1 */
-			snd_soc_dapm_force_enable_pin(&rt286->codec->dapm,
-							"LDO1");
-			snd_soc_dapm_sync(&rt286->codec->dapm);
-
-			regmap_write(rt286->regmap, RT286_SET_MIC1, 0x24);
-			msleep(50);
-
 			regmap_update_bits(rt286->regmap,
-				RT286_CBJ_CTRL1, 0xfcc0, 0xd400);
-			msleep(300);
+				RT286_POWER_CTRL2, 0x4, 0x4);
+			regmap_write(rt286->regmap, RT286_SET_MIC1, 0x24);
 			regmap_read(rt286->regmap, RT286_CBJ_CTRL2, &val);
 
-			if (0x0070 == (val & 0x0070)) {
-				*mic = true;
-			} else {
-				regmap_update_bits(rt286->regmap,
-					RT286_CBJ_CTRL1, 0xfcc0, 0xe400);
-				msleep(300);
+			msleep(200);
+			i = 40;
+			while (((val & 0x0800) == 0) && (i > 0)) {
 				regmap_read(rt286->regmap,
 					RT286_CBJ_CTRL2, &val);
-				if (0x0070 == (val & 0x0070))
-					*mic = true;
-				else
-					*mic = false;
+				i--;
+				msleep(20);
+			}
+
+			if (0x0400 == (val & 0x0700)) {
+				*mic = false;
+
+				regmap_write(rt286->regmap,
+					RT286_SET_MIC1, 0x20);
+				regmap_update_bits(rt286->regmap,
+					RT286_A_BIAS_CTRL3, 0xc000, 0x0000);
+				regmap_update_bits(rt286->regmap,
+					RT286_CBJ_CTRL1, 0x0030, 0x0000);
+				regmap_update_bits(rt286->regmap,
+					RT286_A_BIAS_CTRL2, 0xc000, 0x0000);
+			} else if ((0x0200 == (val & 0x0700)) ||
+				(0x0100 == (val & 0x0700))) {
+				*mic = true;
+				regmap_update_bits(rt286->regmap,
+					RT286_A_BIAS_CTRL3, 0xc000, 0x8000);
+				regmap_update_bits(rt286->regmap,
+					RT286_CBJ_CTRL1, 0x0030, 0x0020);
+				regmap_update_bits(rt286->regmap,
+					RT286_A_BIAS_CTRL2, 0xc000, 0x8000);
+			} else {
+				*mic = false;
 			}
-			regmap_update_bits(rt286->regmap,
-				RT286_DC_GAIN, 0x200, 0x0);
 
+			regmap_update_bits(rt286->regmap,
+						RT286_MISC_CTRL1,
+						0x0060, 0x0000);
 		} else {
+			regmap_update_bits(rt286->regmap,
+						RT286_MISC_CTRL1,
+						0x0060, 0x0020);
+			regmap_update_bits(rt286->regmap,
+						RT286_A_BIAS_CTRL3,
+						0xc000, 0x8000);
+			regmap_update_bits(rt286->regmap,
+						RT286_CBJ_CTRL1,
+						0x0030, 0x0020);
+			regmap_update_bits(rt286->regmap,
+						RT286_A_BIAS_CTRL2,
+						0xc000, 0x8000);
+			regmap_write(rt286->regmap,
+					RT286_SET_MIC1, 0x0);
 			*mic = false;
-			regmap_write(rt286->regmap, RT286_SET_MIC1, 0x20);
 		}
 	} else {
 		regmap_read(rt286->regmap, RT286_GET_HP_SENSE, &buf);
 		*hp = buf & 0x80000000;
 		regmap_read(rt286->regmap, RT286_GET_MIC1_SENSE, &buf);
 		*mic = buf & 0x80000000;
+		if (*mic)
+			vm |= 0x4;
+		if (*hp)
+			vm |= 0x20;
+
+		regmap_write(rt286->regmap, RT286_SET_MIC1, vm);
 	}
 
-	snd_soc_dapm_disable_pin(&rt286->codec->dapm, "HV");
-	snd_soc_dapm_disable_pin(&rt286->codec->dapm, "VREF");
 	if (!*hp)
 		snd_soc_dapm_disable_pin(&rt286->codec->dapm, "LDO1");
+
+	snd_soc_dapm_disable_pin(&rt286->codec->dapm, "VREF");
 	snd_soc_dapm_sync(&rt286->codec->dapm);
 
 	return 0;
@@ -382,24 +412,59 @@
 	if (mic == true)
 		status |= SND_JACK_MICROPHONE;
 
-	snd_soc_jack_report(rt286->jack, status,
-		SND_JACK_MICROPHONE | SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->hp_jack, status, SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->mic_jack, status, SND_JACK_MICROPHONE);
 }
 
-int rt286_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack)
+int rt286_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *hp_jack,
+			struct snd_soc_jack *mic_jack)
 {
 	struct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);
 
-	rt286->jack = jack;
+	rt286->hp_jack = hp_jack;
+	rt286->mic_jack = mic_jack;
 
 	/* Send an initial empty report */
-	snd_soc_jack_report(rt286->jack, 0,
-		SND_JACK_MICROPHONE | SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->hp_jack, 0, SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->mic_jack, 0, SND_JACK_MICROPHONE);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(rt286_mic_detect);
 
+/**
+ * rt286_set_jack_type - Configure the HW supported jack type
+ *
+ * @codec:   RT286 codec
+ * @type:    supported jack type
+ *
+ * RT286 need to configure the jack type (combo or non-combo) according to the
+ * HW design. This function is given a easy way to set the correct jacy type
+ * for those without platform data supported.
+ */
+void rt286_set_jack_type(struct snd_soc_codec *codec,
+				enum rt286_jack_type type)
+{
+	struct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);
+
+	if (RT286_TYPE_COMBO == type)
+		rt286->pdata.cbj_en = true;
+	else
+		rt286->pdata.cbj_en = false;
+
+	if (!rt286->pdata.cbj_en) {
+		regmap_write(rt286->regmap, RT286_CBJ_CTRL2, 0x0000);
+		regmap_write(rt286->regmap, RT286_MIC1_DET_CTRL, 0x0816);
+		regmap_write(rt286->regmap, RT286_MISC_CTRL1, 0x0000);
+		regmap_update_bits(rt286->regmap,
+					RT286_CBJ_CTRL1, 0xf000, 0xb000);
+	} else {
+		regmap_update_bits(rt286->regmap,
+					RT286_CBJ_CTRL1, 0xf000, 0x5000);
+	}
+}
+EXPORT_SYMBOL_GPL(rt286_set_jack_type);
+
 static int is_mclk_mode(struct snd_soc_dapm_widget *source,
 			 struct snd_soc_dapm_widget *sink)
 {
@@ -572,9 +637,17 @@
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 		snd_soc_update_bits(codec,
-			RT286_CBJ_CTRL1, 0x0400, 0x0000);
+			RT286_CBJ_CTRL1, 0x8400, 0x8000);
 		mdelay(50);
 		break;
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec,
+			RT286_POWER_CTRL1, 0x1, 0x0);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec,
+			RT286_POWER_CTRL1, 0x1, 0x1);
+		break;
 	default:
 		return 0;
 	}
@@ -601,46 +674,17 @@
 	return 0;
 }
 
-static int rt286_mic1_event(struct snd_soc_dapm_widget *w,
-			     struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		snd_soc_update_bits(codec,
-			RT286_A_BIAS_CTRL3, 0xc000, 0x8000);
-		snd_soc_update_bits(codec,
-			RT286_A_BIAS_CTRL2, 0xc000, 0x8000);
-		break;
-	case SND_SOC_DAPM_POST_PMD:
-		snd_soc_update_bits(codec,
-			RT286_A_BIAS_CTRL3, 0xc000, 0x0000);
-		snd_soc_update_bits(codec,
-			RT286_A_BIAS_CTRL2, 0xc000, 0x0000);
-		break;
-	default:
-		return 0;
-	}
-
-	return 0;
-}
-
 static const struct snd_soc_dapm_widget rt286_dapm_widgets[] = {
-	SND_SOC_DAPM_SUPPLY_S("HV", 1, RT286_POWER_CTRL1,
-		12, 1, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("VREF", RT286_POWER_CTRL1,
-		0, 1, rt286_vref_event, SND_SOC_DAPM_PRE_PMU),
+		12, 1, rt286_vref_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMU),
 	SND_SOC_DAPM_SUPPLY_S("LDO1", 1, RT286_POWER_CTRL2,
 		2, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY_S("LDO2", 2, RT286_POWER_CTRL1,
+	SND_SOC_DAPM_SUPPLY_S("LDO2", 1, RT286_POWER_CTRL1,
 		13, 1, rt286_ldo2_event, SND_SOC_DAPM_PRE_PMD |
 		SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("MCLK MODE", RT286_PLL_CTRL1,
 		5, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("MIC1 Input Buffer", SND_SOC_NOPM,
-		0, 0, rt286_mic1_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMD),
 
 	/* Input Lines */
 	SND_SOC_DAPM_INPUT("DMIC1 Pin"),
@@ -720,18 +764,15 @@
 	{"Front", NULL, "MCLK MODE", is_mclk_mode},
 	{"Surround", NULL, "MCLK MODE", is_mclk_mode},
 
+	{"MIC1", NULL, "LDO1"},
+	{"SPO", NULL, "LDO1"},
 	{"HP Power", NULL, "LDO1"},
-	{"HP Power", NULL, "LDO2"},
 
-	{"MIC1", NULL, "LDO1"},
 	{"MIC1", NULL, "LDO2"},
-	{"MIC1", NULL, "HV"},
-	{"MIC1", NULL, "VREF"},
-	{"MIC1", NULL, "MIC1 Input Buffer"},
-
-	{"SPO", NULL, "LDO1"},
 	{"SPO", NULL, "LDO2"},
-	{"SPO", NULL, "HV"},
+	{"HP Power", NULL, "LDO2"},
+
+	{"MIC1", NULL, "VREF"},
 	{"SPO", NULL, "VREF"},
 
 	{"DMIC1", NULL, "DMIC1 Pin"},
@@ -861,8 +902,10 @@
 		RT286_I2S_CTRL1, 0x0018, d_len_code << 3);
 	dev_dbg(codec->dev, "format val = 0x%x\n", val);
 
-	snd_soc_update_bits(codec, RT286_DAC_FORMAT, 0x407f, val);
-	snd_soc_update_bits(codec, RT286_ADC_FORMAT, 0x407f, val);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_update_bits(codec, RT286_DAC_FORMAT, 0x407f, val);
+	else
+		snd_soc_update_bits(codec, RT286_ADC_FORMAT, 0x407f, val);
 
 	return 0;
 }
@@ -922,15 +965,11 @@
 	if (RT286_SCLK_S_MCLK == clk_id) {
 		snd_soc_update_bits(codec,
 			RT286_I2S_CTRL2, 0x0100, 0x0);
-		snd_soc_update_bits(codec,
-			RT286_PLL_CTRL1, 0x20, 0x20);
 	} else {
 		snd_soc_update_bits(codec,
 			RT286_I2S_CTRL2, 0x0100, 0x0100);
 		snd_soc_update_bits(codec,
 			RT286_PLL_CTRL, 0x4, 0x4);
-		snd_soc_update_bits(codec,
-			RT286_PLL_CTRL1, 0x20, 0x0);
 	}
 
 	switch (freq) {
@@ -1007,7 +1046,7 @@
 	case SND_SOC_BIAS_ON:
 		mdelay(10);
 		snd_soc_update_bits(codec,
-			RT286_CBJ_CTRL1, 0x0400, 0x0400);
+			RT286_CBJ_CTRL1, 0x8400, 0x0400);
 		snd_soc_update_bits(codec,
 			RT286_DC_GAIN, 0x200, 0x0);
 
@@ -1016,8 +1055,6 @@
 	case SND_SOC_BIAS_STANDBY:
 		snd_soc_write(codec,
 			RT286_SET_AUDIO_POWER, AC_PWRST_D3);
-		snd_soc_update_bits(codec,
-			RT286_CBJ_CTRL1, 0x0400, 0x0000);
 		break;
 
 	default:
@@ -1046,8 +1083,8 @@
 	if (mic == true)
 		status |= SND_JACK_MICROPHONE;
 
-	snd_soc_jack_report(rt286->jack, status,
-		SND_JACK_MICROPHONE | SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->hp_jack, status, SND_JACK_HEADPHONE);
+	snd_soc_jack_report(rt286->mic_jack, status, SND_JACK_MICROPHONE);
 
 	pm_wakeup_event(&rt286->i2c->dev, 300);
 
@@ -1061,6 +1098,9 @@
 	rt286->codec = codec;
 	codec->dapm.bias_level = SND_SOC_BIAS_OFF;
 
+	if (rt286->pdata.suspend_power_off)
+		codec->dapm.idle_bias_off = false;
+
 	if (rt286->i2c->irq) {
 		regmap_update_bits(rt286->regmap,
 					RT286_IRQ_CTRL, 0x2, 0x2);
@@ -1198,27 +1238,26 @@
 };
 MODULE_DEVICE_TABLE(i2c, rt286_i2c_id);
 
+/* the default platform data for acpi devices */
+static struct rt286_platform_data rt286_acpi_data = {
+	.cbj_en = true,
+	.gpio2_en = false,
+	.suspend_power_off = true,
+};
+
 static const struct acpi_device_id rt286_acpi_match[] = {
-	{ "INT343A", 0 },
+	{ "INT343A", (unsigned long)&rt286_acpi_data },
 	{},
 };
 MODULE_DEVICE_TABLE(acpi, rt286_acpi_match);
 
-static struct dmi_system_id force_combo_jack_table[] = {
-	{
-		.ident = "Intel Wilson Beach",
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "Wilson Beach SDS")
-		}
-	},
-	{ }
-};
-
 static int rt286_i2c_probe(struct i2c_client *i2c,
 			   const struct i2c_device_id *id)
 {
 	struct rt286_platform_data *pdata = dev_get_platdata(&i2c->dev);
 	struct rt286_priv *rt286;
+	struct device *dev = &i2c->dev;
+	const struct acpi_device_id *acpiid;
 	int i, ret;
 
 	rt286 = devm_kzalloc(&i2c->dev,	sizeof(*rt286),
@@ -1249,8 +1288,12 @@
 	if (pdata)
 		rt286->pdata = *pdata;
 
-	if (dmi_check_system(force_combo_jack_table))
-		rt286->pdata.cbj_en = true;
+	/* enable jack combo mode on supported devices */
+	acpiid = acpi_match_device(dev->driver->acpi_match_table, dev);
+	if (acpiid) {
+		rt286->pdata = *(struct rt286_platform_data *)
+				acpiid->driver_data;
+	}
 
 	regmap_write(rt286->regmap, RT286_SET_AUDIO_POWER, AC_PWRST_D3);
 
@@ -1262,6 +1305,7 @@
 	if (!rt286->pdata.cbj_en) {
 		regmap_write(rt286->regmap, RT286_CBJ_CTRL2, 0x0000);
 		regmap_write(rt286->regmap, RT286_MIC1_DET_CTRL, 0x0816);
+		regmap_write(rt286->regmap, RT286_MISC_CTRL1, 0x0000);
 		regmap_update_bits(rt286->regmap,
 					RT286_CBJ_CTRL1, 0xf000, 0xb000);
 	} else {
@@ -1278,12 +1322,10 @@
 
 	mdelay(10);
 
-	regmap_write(rt286->regmap, RT286_MISC_CTRL1, 0x0000);
-	/* Power down LDO, VREF */
-	regmap_update_bits(rt286->regmap, RT286_POWER_CTRL2, 0xc, 0x0);
-	regmap_update_bits(rt286->regmap, RT286_POWER_CTRL1, 0x1001, 0x1001);
+	/*Power down LDO2*/
+	regmap_update_bits(rt286->regmap, RT286_POWER_CTRL2, 0x8, 0x0);
 
-	/* Set depop parameter */
+	/*Set depop parameter*/
 	regmap_update_bits(rt286->regmap, RT286_DEPOP_CTRL2, 0x403a, 0x401a);
 	regmap_update_bits(rt286->regmap, RT286_DEPOP_CTRL3, 0xf777, 0x4737);
 	regmap_update_bits(rt286->regmap, RT286_DEPOP_CTRL4, 0x00ff, 0x003f);
diff -Naur linux-3.19.old/sound/soc/codecs/rt286.h linux-3.19/sound/soc/codecs/rt286.h
--- linux-3.19.old/sound/soc/codecs/rt286.h	2015-03-24 17:38:13.863176971 -0800
+++ linux-3.19/sound/soc/codecs/rt286.h	2015-03-24 18:28:21.328013360 -0800
@@ -192,7 +192,15 @@
 	RT286_AIFS,
 };
 
-int rt286_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack);
+enum rt286_jack_type {
+	RT286_TYPE_COMBO,
+	RT286_TYPE_NONCOMBO,
+};
+
+int rt286_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *hp_jack,
+			struct snd_soc_jack *mic_jack);
+void rt286_set_jack_type(struct snd_soc_codec *codec,
+				enum rt286_jack_type type);
 
 #endif /* __RT286_H__ */
 
diff -Naur linux-3.19.old/sound/soc/codecs/rt5640.c linux-3.19/sound/soc/codecs/rt5640.c
--- linux-3.19.old/sound/soc/codecs/rt5640.c	2015-03-24 17:38:13.873176970 -0800
+++ linux-3.19/sound/soc/codecs/rt5640.c	2015-03-24 18:28:21.328013360 -0800
@@ -1,5 +1,5 @@
 /*
- * rt5640.c  --  RT5640/RT5639 ALSA SoC audio codec driver
+ * rt5640.c  --  RT5640 ALSA SoC audio codec driver
  *
  * Copyright 2011 Realtek Semiconductor Corp.
  * Author: Johnny Hsu <johnnyhsu@realtek.com>
@@ -18,7 +18,6 @@
 #include <linux/gpio.h>
 #include <linux/i2c.h>
 #include <linux/regmap.h>
-#include <linux/of.h>
 #include <linux/of_gpio.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
@@ -61,7 +60,7 @@
 };
 #define RT5640_INIT_REG_LEN ARRAY_SIZE(init_list)
 
-static const struct reg_default rt5640_reg[] = {
+static const struct reg_default rt5640_reg[RT5640_VENDOR_ID2 + 1] = {
 	{ 0x00, 0x000e },
 	{ 0x01, 0xc8c8 },
 	{ 0x02, 0xc8c8 },
@@ -363,24 +362,25 @@
 static const char * const rt5640_data_select[] = {
 	"Normal", "left copy to right", "right copy to left", "Swap"};
 
-static SOC_ENUM_SINGLE_DECL(rt5640_if1_dac_enum, RT5640_DIG_INF_DATA,
-			    RT5640_IF1_DAC_SEL_SFT, rt5640_data_select);
+static const SOC_ENUM_SINGLE_DECL(rt5640_if1_dac_enum, RT5640_DIG_INF_DATA,
+				RT5640_IF1_DAC_SEL_SFT, rt5640_data_select);
 
-static SOC_ENUM_SINGLE_DECL(rt5640_if1_adc_enum, RT5640_DIG_INF_DATA,
-			    RT5640_IF1_ADC_SEL_SFT, rt5640_data_select);
+static const SOC_ENUM_SINGLE_DECL(rt5640_if1_adc_enum, RT5640_DIG_INF_DATA,
+				RT5640_IF1_ADC_SEL_SFT, rt5640_data_select);
 
-static SOC_ENUM_SINGLE_DECL(rt5640_if2_dac_enum, RT5640_DIG_INF_DATA,
-			    RT5640_IF2_DAC_SEL_SFT, rt5640_data_select);
+static const SOC_ENUM_SINGLE_DECL(rt5640_if2_dac_enum, RT5640_DIG_INF_DATA,
+				RT5640_IF2_DAC_SEL_SFT, rt5640_data_select);
 
-static SOC_ENUM_SINGLE_DECL(rt5640_if2_adc_enum, RT5640_DIG_INF_DATA,
-			    RT5640_IF2_ADC_SEL_SFT, rt5640_data_select);
+static const SOC_ENUM_SINGLE_DECL(rt5640_if2_adc_enum, RT5640_DIG_INF_DATA,
+				RT5640_IF2_ADC_SEL_SFT, rt5640_data_select);
 
 /* Class D speaker gain ratio */
 static const char * const rt5640_clsd_spk_ratio[] = {"1.66x", "1.83x", "1.94x",
 	"2x", "2.11x", "2.22x", "2.33x", "2.44x", "2.55x", "2.66x", "2.77x"};
 
-static SOC_ENUM_SINGLE_DECL(rt5640_clsd_spk_ratio_enum, RT5640_CLS_D_OUT,
-			    RT5640_CLSD_RATIO_SFT, rt5640_clsd_spk_ratio);
+static const SOC_ENUM_SINGLE_DECL(
+	rt5640_clsd_spk_ratio_enum, RT5640_CLS_D_OUT,
+	RT5640_CLSD_RATIO_SFT, rt5640_clsd_spk_ratio);
 
 static const struct snd_kcontrol_new rt5640_snd_controls[] = {
 	/* Speaker Output Volume */
@@ -400,13 +400,18 @@
 		RT5640_VOL_L_SFT, RT5640_VOL_R_SFT, 1, 1),
 	SOC_DOUBLE_TLV("OUT Playback Volume", RT5640_OUTPUT,
 		RT5640_L_VOL_SFT, RT5640_R_VOL_SFT, 39, 1, out_vol_tlv),
-
+	/* MONO Output Control */
+	SOC_SINGLE("Mono Playback Switch", RT5640_MONO_OUT,
+				RT5640_L_MUTE_SFT, 1, 1),
 	/* DAC Digital Volume */
 	SOC_DOUBLE("DAC2 Playback Switch", RT5640_DAC2_CTRL,
 		RT5640_M_DAC_L2_VOL_SFT, RT5640_M_DAC_R2_VOL_SFT, 1, 1),
 	SOC_DOUBLE_TLV("DAC1 Playback Volume", RT5640_DAC1_DIG_VOL,
 			RT5640_L_VOL_SFT, RT5640_R_VOL_SFT,
 			175, 0, dac_vol_tlv),
+	SOC_DOUBLE_TLV("Mono DAC Playback Volume", RT5640_DAC2_DIG_VOL,
+			RT5640_L_VOL_SFT, RT5640_R_VOL_SFT,
+			175, 0, dac_vol_tlv),
 	/* IN1/IN2 Control */
 	SOC_SINGLE_TLV("IN1 Boost", RT5640_IN1_IN2,
 		RT5640_BST_SFT1, 8, 0, bst_tlv),
@@ -438,15 +443,6 @@
 	SOC_ENUM("DAC IF2 Data Switch", rt5640_if2_dac_enum),
 };
 
-static const struct snd_kcontrol_new rt5640_specific_snd_controls[] = {
-	/* MONO Output Control */
-	SOC_SINGLE("Mono Playback Switch", RT5640_MONO_OUT, RT5640_L_MUTE_SFT,
-		1, 1),
-
-	SOC_DOUBLE_TLV("Mono DAC Playback Volume", RT5640_DAC2_DIG_VOL,
-		RT5640_L_VOL_SFT, RT5640_R_VOL_SFT, 175, 0, dac_vol_tlv),
-};
-
 /**
  * set_dmic_clk - Set parameter of dmic.
  *
@@ -472,14 +468,14 @@
 	return idx;
 }
 
-static int is_sys_clk_from_pll(struct snd_soc_dapm_widget *source,
+static int check_sysclk1_source(struct snd_soc_dapm_widget *source,
 			 struct snd_soc_dapm_widget *sink)
 {
 	unsigned int val;
 
 	val = snd_soc_read(source->codec, RT5640_GLB_CLK);
 	val &= RT5640_SCLK_SRC_MASK;
-	if (val == RT5640_SCLK_SRC_PLL1)
+	if (val == RT5640_SCLK_SRC_PLL1 || val == RT5640_SCLK_SRC_PLL1T)
 		return 1;
 	else
 		return 0;
@@ -546,20 +542,6 @@
 			RT5640_M_ANC_DAC_R_SFT, 1, 1),
 };
 
-static const struct snd_kcontrol_new rt5639_sto_dac_l_mix[] = {
-	SOC_DAPM_SINGLE("DAC L1 Switch", RT5640_STO_DAC_MIXER,
-			RT5640_M_DAC_L1_SFT, 1, 1),
-	SOC_DAPM_SINGLE("DAC L2 Switch", RT5640_STO_DAC_MIXER,
-			RT5640_M_DAC_L2_SFT, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5639_sto_dac_r_mix[] = {
-	SOC_DAPM_SINGLE("DAC R1 Switch", RT5640_STO_DAC_MIXER,
-			RT5640_M_DAC_R1_SFT, 1, 1),
-	SOC_DAPM_SINGLE("DAC R2 Switch", RT5640_STO_DAC_MIXER,
-			RT5640_M_DAC_R2_SFT, 1, 1),
-};
-
 static const struct snd_kcontrol_new rt5640_mono_dac_l_mix[] = {
 	SOC_DAPM_SINGLE("DAC L1 Switch", RT5640_MONO_DAC_MIXER,
 			RT5640_M_DAC_L1_MONO_L_SFT, 1, 1),
@@ -682,30 +664,6 @@
 			RT5640_M_DAC_R1_OM_R_SFT, 1, 1),
 };
 
-static const struct snd_kcontrol_new rt5639_out_l_mix[] = {
-	SOC_DAPM_SINGLE("BST1 Switch", RT5640_OUT_L3_MIXER,
-			RT5640_M_BST1_OM_L_SFT, 1, 1),
-	SOC_DAPM_SINGLE("INL Switch", RT5640_OUT_L3_MIXER,
-			RT5640_M_IN_L_OM_L_SFT, 1, 1),
-	SOC_DAPM_SINGLE("REC MIXL Switch", RT5640_OUT_L3_MIXER,
-			RT5640_M_RM_L_OM_L_SFT, 1, 1),
-	SOC_DAPM_SINGLE("DAC L1 Switch", RT5640_OUT_L3_MIXER,
-			RT5640_M_DAC_L1_OM_L_SFT, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5639_out_r_mix[] = {
-	SOC_DAPM_SINGLE("BST2 Switch", RT5640_OUT_R3_MIXER,
-			RT5640_M_BST4_OM_R_SFT, 1, 1),
-	SOC_DAPM_SINGLE("BST1 Switch", RT5640_OUT_R3_MIXER,
-			RT5640_M_BST1_OM_R_SFT, 1, 1),
-	SOC_DAPM_SINGLE("INR Switch", RT5640_OUT_R3_MIXER,
-			RT5640_M_IN_R_OM_R_SFT, 1, 1),
-	SOC_DAPM_SINGLE("REC MIXR Switch", RT5640_OUT_R3_MIXER,
-			RT5640_M_RM_R_OM_R_SFT, 1, 1),
-	SOC_DAPM_SINGLE("DAC R1 Switch", RT5640_OUT_R3_MIXER,
-			RT5640_M_DAC_R1_OM_R_SFT, 1, 1),
-};
-
 static const struct snd_kcontrol_new rt5640_spo_l_mix[] = {
 	SOC_DAPM_SINGLE("DAC R1 Switch", RT5640_SPO_L_MIXER,
 			RT5640_M_DAC_R1_SPM_L_SFT, 1, 1),
@@ -737,13 +695,6 @@
 			RT5640_M_HPVOL_HM_SFT, 1, 1),
 };
 
-static const struct snd_kcontrol_new rt5639_hpo_mix[] = {
-	SOC_DAPM_SINGLE("HPO MIX DAC1 Switch", RT5640_HPO_MIXER,
-			RT5640_M_DAC1_HM_SFT, 1, 1),
-	SOC_DAPM_SINGLE("HPO MIX HPVOL Switch", RT5640_HPO_MIXER,
-			RT5640_M_HPVOL_HM_SFT, 1, 1),
-};
-
 static const struct snd_kcontrol_new rt5640_lout_mix[] = {
 	SOC_DAPM_SINGLE("DAC L1 Switch", RT5640_LOUT_MIXER,
 			RT5640_M_DAC_L1_LM_SFT, 1, 1),
@@ -789,8 +740,9 @@
 	"DIG MIX", "ADC"
 };
 
-static SOC_ENUM_SINGLE_DECL(rt5640_stereo_adc1_enum, RT5640_STO_ADC_MIXER,
-			    RT5640_ADC_1_SRC_SFT, rt5640_stereo_adc1_src);
+static const SOC_ENUM_SINGLE_DECL(
+	rt5640_stereo_adc1_enum, RT5640_STO_ADC_MIXER,
+	RT5640_ADC_1_SRC_SFT, rt5640_stereo_adc1_src);
 
 static const struct snd_kcontrol_new rt5640_sto_adc_1_mux =
 	SOC_DAPM_ENUM("Stereo ADC1 Mux", rt5640_stereo_adc1_enum);
@@ -799,8 +751,9 @@
 	"DMIC1", "DMIC2", "DIG MIX"
 };
 
-static SOC_ENUM_SINGLE_DECL(rt5640_stereo_adc2_enum, RT5640_STO_ADC_MIXER,
-			    RT5640_ADC_2_SRC_SFT, rt5640_stereo_adc2_src);
+static const SOC_ENUM_SINGLE_DECL(
+	rt5640_stereo_adc2_enum, RT5640_STO_ADC_MIXER,
+	RT5640_ADC_2_SRC_SFT, rt5640_stereo_adc2_src);
 
 static const struct snd_kcontrol_new rt5640_sto_adc_2_mux =
 	SOC_DAPM_ENUM("Stereo ADC2 Mux", rt5640_stereo_adc2_enum);
@@ -810,8 +763,9 @@
 	"Mono DAC MIXL", "ADCL"
 };
 
-static SOC_ENUM_SINGLE_DECL(rt5640_mono_adc_l1_enum, RT5640_MONO_ADC_MIXER,
-			    RT5640_MONO_ADC_L1_SRC_SFT, rt5640_mono_adc_l1_src);
+static const SOC_ENUM_SINGLE_DECL(
+	rt5640_mono_adc_l1_enum, RT5640_MONO_ADC_MIXER,
+	RT5640_MONO_ADC_L1_SRC_SFT, rt5640_mono_adc_l1_src);
 
 static const struct snd_kcontrol_new rt5640_mono_adc_l1_mux =
 	SOC_DAPM_ENUM("Mono ADC1 left source", rt5640_mono_adc_l1_enum);
@@ -820,8 +774,9 @@
 	"DMIC L1", "DMIC L2", "Mono DAC MIXL"
 };
 
-static SOC_ENUM_SINGLE_DECL(rt5640_mono_adc_l2_enum, RT5640_MONO_ADC_MIXER,
-			    RT5640_MONO_ADC_L2_SRC_SFT, rt5640_mono_adc_l2_src);
+static const SOC_ENUM_SINGLE_DECL(
+	rt5640_mono_adc_l2_enum, RT5640_MONO_ADC_MIXER,
+	RT5640_MONO_ADC_L2_SRC_SFT, rt5640_mono_adc_l2_src);
 
 static const struct snd_kcontrol_new rt5640_mono_adc_l2_mux =
 	SOC_DAPM_ENUM("Mono ADC2 left source", rt5640_mono_adc_l2_enum);
@@ -830,8 +785,9 @@
 	"Mono DAC MIXR", "ADCR"
 };
 
-static SOC_ENUM_SINGLE_DECL(rt5640_mono_adc_r1_enum, RT5640_MONO_ADC_MIXER,
-			    RT5640_MONO_ADC_R1_SRC_SFT, rt5640_mono_adc_r1_src);
+static const SOC_ENUM_SINGLE_DECL(
+	rt5640_mono_adc_r1_enum, RT5640_MONO_ADC_MIXER,
+	RT5640_MONO_ADC_R1_SRC_SFT, rt5640_mono_adc_r1_src);
 
 static const struct snd_kcontrol_new rt5640_mono_adc_r1_mux =
 	SOC_DAPM_ENUM("Mono ADC1 right source", rt5640_mono_adc_r1_enum);
@@ -840,8 +796,9 @@
 	"DMIC R1", "DMIC R2", "Mono DAC MIXR"
 };
 
-static SOC_ENUM_SINGLE_DECL(rt5640_mono_adc_r2_enum, RT5640_MONO_ADC_MIXER,
-			    RT5640_MONO_ADC_R2_SRC_SFT, rt5640_mono_adc_r2_src);
+static const SOC_ENUM_SINGLE_DECL(
+	rt5640_mono_adc_r2_enum, RT5640_MONO_ADC_MIXER,
+	RT5640_MONO_ADC_R2_SRC_SFT, rt5640_mono_adc_r2_src);
 
 static const struct snd_kcontrol_new rt5640_mono_adc_r2_mux =
 	SOC_DAPM_ENUM("Mono ADC2 right source", rt5640_mono_adc_r2_enum);
@@ -856,12 +813,12 @@
 	3,
 };
 
-static SOC_VALUE_ENUM_SINGLE_DECL(rt5640_dac_l2_enum,
-				  RT5640_DSP_PATH2, RT5640_DAC_L2_SEL_SFT,
-				  0x3, rt5640_dac_l2_src, rt5640_dac_l2_values);
+static const SOC_VALUE_ENUM_SINGLE_DECL(
+	rt5640_dac_l2_enum, RT5640_DSP_PATH2, RT5640_DAC_L2_SEL_SFT,
+	0x3, rt5640_dac_l2_src, rt5640_dac_l2_values);
 
 static const struct snd_kcontrol_new rt5640_dac_l2_mux =
-	SOC_DAPM_ENUM("DAC2 left channel source", rt5640_dac_l2_enum);
+	SOC_DAPM_VALUE_ENUM("DAC2 left channel source", rt5640_dac_l2_enum);
 
 static const char * const rt5640_dac_r2_src[] = {
 	"IF2",
@@ -871,9 +828,9 @@
 	0,
 };
 
-static SOC_VALUE_ENUM_SINGLE_DECL(rt5640_dac_r2_enum,
-				  RT5640_DSP_PATH2, RT5640_DAC_R2_SEL_SFT,
-				  0x3, rt5640_dac_r2_src, rt5640_dac_r2_values);
+static const SOC_VALUE_ENUM_SINGLE_DECL(
+	rt5640_dac_r2_enum, RT5640_DSP_PATH2, RT5640_DAC_R2_SEL_SFT,
+	0x3, rt5640_dac_r2_src, rt5640_dac_r2_values);
 
 static const struct snd_kcontrol_new rt5640_dac_r2_mux =
 	SOC_DAPM_ENUM("DAC2 right channel source", rt5640_dac_r2_enum);
@@ -890,25 +847,73 @@
 	7,
 };
 
-static SOC_VALUE_ENUM_SINGLE_DECL(rt5640_dai_iis_map_enum,
-				  RT5640_I2S1_SDP, RT5640_I2S_IF_SFT,
-				  0x7, rt5640_dai_iis_map,
-				  rt5640_dai_iis_map_values);
+static const SOC_VALUE_ENUM_SINGLE_DECL(
+	rt5640_dai_iis_map_enum, RT5640_I2S1_SDP, RT5640_I2S_IF_SFT,
+	0x7, rt5640_dai_iis_map, rt5640_dai_iis_map_values);
 
 static const struct snd_kcontrol_new rt5640_dai_mux =
-	SOC_DAPM_ENUM("DAI select", rt5640_dai_iis_map_enum);
+	SOC_DAPM_VALUE_ENUM("DAI select", rt5640_dai_iis_map_enum);
 
 /* SDI select */
 static const char * const rt5640_sdi_sel[] = {
 	"IF1", "IF2"
 };
 
-static SOC_ENUM_SINGLE_DECL(rt5640_sdi_sel_enum, RT5640_I2S2_SDP,
-			    RT5640_I2S2_SDI_SFT, rt5640_sdi_sel);
+static const SOC_ENUM_SINGLE_DECL(
+	rt5640_sdi_sel_enum, RT5640_I2S2_SDP,
+	RT5640_I2S2_SDI_SFT, rt5640_sdi_sel);
 
 static const struct snd_kcontrol_new rt5640_sdi_mux =
 	SOC_DAPM_ENUM("SDI select", rt5640_sdi_sel_enum);
 
+static int rt5640_set_dmic1_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		snd_soc_update_bits(codec, RT5640_GPIO_CTRL1,
+			RT5640_GP2_PIN_MASK | RT5640_GP3_PIN_MASK,
+			RT5640_GP2_PIN_DMIC1_SCL | RT5640_GP3_PIN_DMIC1_SDA);
+		snd_soc_update_bits(codec, RT5640_DMIC,
+			RT5640_DMIC_1L_LH_MASK | RT5640_DMIC_1R_LH_MASK |
+			RT5640_DMIC_1_DP_MASK,
+			RT5640_DMIC_1L_LH_FALLING | RT5640_DMIC_1R_LH_RISING |
+			RT5640_DMIC_1_DP_IN1P);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5640_set_dmic2_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		snd_soc_update_bits(codec, RT5640_GPIO_CTRL1,
+			RT5640_GP2_PIN_MASK | RT5640_GP4_PIN_MASK,
+			RT5640_GP2_PIN_DMIC1_SCL | RT5640_GP4_PIN_DMIC2_SDA);
+		snd_soc_update_bits(codec, RT5640_DMIC,
+			RT5640_DMIC_2L_LH_MASK | RT5640_DMIC_2R_LH_MASK |
+			RT5640_DMIC_2_DP_MASK,
+			RT5640_DMIC_2L_LH_FALLING | RT5640_DMIC_2R_LH_RISING |
+			RT5640_DMIC_2_DP_IN1N);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
 static void hp_amp_power_on(struct snd_soc_codec *codec)
 {
 	struct rt5640_priv *rt5640 = snd_soc_codec_get_drvdata(codec);
@@ -1043,10 +1048,12 @@
 
 	SND_SOC_DAPM_SUPPLY("DMIC CLK", SND_SOC_NOPM, 0, 0,
 		set_dmic_clk, SND_SOC_DAPM_PRE_PMU),
-	SND_SOC_DAPM_SUPPLY("DMIC1 Power", RT5640_DMIC, RT5640_DMIC_1_EN_SFT, 0,
-		NULL, 0),
-	SND_SOC_DAPM_SUPPLY("DMIC2 Power", RT5640_DMIC, RT5640_DMIC_2_EN_SFT, 0,
-		NULL, 0),
+	SND_SOC_DAPM_SUPPLY("DMIC1 Power", RT5640_DMIC,
+		RT5640_DMIC_1_EN_SFT, 0, rt5640_set_dmic1_event,
+		SND_SOC_DAPM_PRE_PMU),
+	SND_SOC_DAPM_SUPPLY("DMIC2 Power", RT5640_DMIC,
+		RT5640_DMIC_2_EN_SFT, 0, rt5640_set_dmic2_event,
+		SND_SOC_DAPM_PRE_PMU),
 	/* Boost */
 	SND_SOC_DAPM_PGA("BST1", RT5640_PWR_ANLG2,
 		RT5640_PWR_BST1_BIT, 0, NULL, 0),
@@ -1133,15 +1140,26 @@
 	SND_SOC_DAPM_AIF_OUT("AIF1TX", "AIF1 Capture", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_IN("AIF2RX", "AIF2 Playback", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_OUT("AIF2TX", "AIF2 Capture", 0, SND_SOC_NOPM, 0, 0),
-
+	/* Audio DSP */
+	SND_SOC_DAPM_PGA("Audio DSP", SND_SOC_NOPM, 0, 0, NULL, 0),
+	/* ANC */
+	SND_SOC_DAPM_PGA("ANC", SND_SOC_NOPM, 0, 0, NULL, 0),
 	/* Output Side */
 	/* DAC mixer before sound effect  */
 	SND_SOC_DAPM_MIXER("DAC MIXL", SND_SOC_NOPM, 0, 0,
 		rt5640_dac_l_mix, ARRAY_SIZE(rt5640_dac_l_mix)),
 	SND_SOC_DAPM_MIXER("DAC MIXR", SND_SOC_NOPM, 0, 0,
 		rt5640_dac_r_mix, ARRAY_SIZE(rt5640_dac_r_mix)),
-
+	/* DAC2 channel Mux */
+	SND_SOC_DAPM_MUX("DAC L2 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5640_dac_l2_mux),
+	SND_SOC_DAPM_MUX("DAC R2 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5640_dac_r2_mux),
 	/* DAC Mixer */
+	SND_SOC_DAPM_MIXER("Stereo DAC MIXL", SND_SOC_NOPM, 0, 0,
+		rt5640_sto_dac_l_mix, ARRAY_SIZE(rt5640_sto_dac_l_mix)),
+	SND_SOC_DAPM_MIXER("Stereo DAC MIXR", SND_SOC_NOPM, 0, 0,
+		rt5640_sto_dac_r_mix, ARRAY_SIZE(rt5640_sto_dac_r_mix)),
 	SND_SOC_DAPM_MIXER("Mono DAC MIXL", SND_SOC_NOPM, 0, 0,
 		rt5640_mono_dac_l_mix, ARRAY_SIZE(rt5640_mono_dac_l_mix)),
 	SND_SOC_DAPM_MIXER("Mono DAC MIXR", SND_SOC_NOPM, 0, 0,
@@ -1153,14 +1171,21 @@
 	/* DACs */
 	SND_SOC_DAPM_DAC("DAC L1", NULL, RT5640_PWR_DIG1,
 			RT5640_PWR_DAC_L1_BIT, 0),
+	SND_SOC_DAPM_DAC("DAC L2", NULL, RT5640_PWR_DIG1,
+			RT5640_PWR_DAC_L2_BIT, 0),
 	SND_SOC_DAPM_DAC("DAC R1", NULL, RT5640_PWR_DIG1,
 			RT5640_PWR_DAC_R1_BIT, 0),
-
+	SND_SOC_DAPM_DAC("DAC R2", NULL, RT5640_PWR_DIG1,
+			RT5640_PWR_DAC_R2_BIT, 0),
 	/* SPK/OUT Mixer */
 	SND_SOC_DAPM_MIXER("SPK MIXL", RT5640_PWR_MIXER, RT5640_PWR_SM_L_BIT,
 		0, rt5640_spk_l_mix, ARRAY_SIZE(rt5640_spk_l_mix)),
 	SND_SOC_DAPM_MIXER("SPK MIXR", RT5640_PWR_MIXER, RT5640_PWR_SM_R_BIT,
 		0, rt5640_spk_r_mix, ARRAY_SIZE(rt5640_spk_r_mix)),
+	SND_SOC_DAPM_MIXER("OUT MIXL", RT5640_PWR_MIXER, RT5640_PWR_OM_L_BIT,
+		0, rt5640_out_l_mix, ARRAY_SIZE(rt5640_out_l_mix)),
+	SND_SOC_DAPM_MIXER("OUT MIXR", RT5640_PWR_MIXER, RT5640_PWR_OM_R_BIT,
+		0, rt5640_out_r_mix, ARRAY_SIZE(rt5640_out_r_mix)),
 	/* Ouput Volume */
 	SND_SOC_DAPM_PGA("SPKVOL L", RT5640_PWR_VOL,
 		RT5640_PWR_SV_L_BIT, 0, NULL, 0),
@@ -1179,8 +1204,16 @@
 		0, rt5640_spo_l_mix, ARRAY_SIZE(rt5640_spo_l_mix)),
 	SND_SOC_DAPM_MIXER("SPOR MIX", SND_SOC_NOPM, 0,
 		0, rt5640_spo_r_mix, ARRAY_SIZE(rt5640_spo_r_mix)),
+	SND_SOC_DAPM_MIXER("HPO MIX L", SND_SOC_NOPM, 0, 0,
+		rt5640_hpo_mix, ARRAY_SIZE(rt5640_hpo_mix)),
+	SND_SOC_DAPM_MIXER("HPO MIX R", SND_SOC_NOPM, 0, 0,
+		rt5640_hpo_mix, ARRAY_SIZE(rt5640_hpo_mix)),
 	SND_SOC_DAPM_MIXER("LOUT MIX", RT5640_PWR_ANLG1, RT5640_PWR_LM_BIT, 0,
 		rt5640_lout_mix, ARRAY_SIZE(rt5640_lout_mix)),
+	SND_SOC_DAPM_MIXER("Mono MIX", RT5640_PWR_ANLG1, RT5640_PWR_MM_BIT, 0,
+		rt5640_mono_mix, ARRAY_SIZE(rt5640_mono_mix)),
+	SND_SOC_DAPM_SUPPLY("Improve MONO Amp Drv", RT5640_PWR_ANLG1,
+		RT5640_PWR_MA_BIT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY_S("Improve HP Amp Drv", 1, SND_SOC_NOPM,
 		0, 0, rt5640_hp_power_event, SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_PGA_S("HP Amp", 1, SND_SOC_NOPM, 0, 0,
@@ -1212,69 +1245,10 @@
 	SND_SOC_DAPM_OUTPUT("HPOR"),
 	SND_SOC_DAPM_OUTPUT("LOUTL"),
 	SND_SOC_DAPM_OUTPUT("LOUTR"),
-};
-
-static const struct snd_soc_dapm_widget rt5640_specific_dapm_widgets[] = {
-	/* Audio DSP */
-	SND_SOC_DAPM_PGA("Audio DSP", SND_SOC_NOPM, 0, 0, NULL, 0),
-	/* ANC */
-	SND_SOC_DAPM_PGA("ANC", SND_SOC_NOPM, 0, 0, NULL, 0),
-
-	/* DAC2 channel Mux */
-	SND_SOC_DAPM_MUX("DAC L2 Mux", SND_SOC_NOPM, 0, 0, &rt5640_dac_l2_mux),
-	SND_SOC_DAPM_MUX("DAC R2 Mux", SND_SOC_NOPM, 0, 0, &rt5640_dac_r2_mux),
-
-	SND_SOC_DAPM_MIXER("Stereo DAC MIXL", SND_SOC_NOPM, 0, 0,
-		rt5640_sto_dac_l_mix, ARRAY_SIZE(rt5640_sto_dac_l_mix)),
-	SND_SOC_DAPM_MIXER("Stereo DAC MIXR", SND_SOC_NOPM, 0, 0,
-		rt5640_sto_dac_r_mix, ARRAY_SIZE(rt5640_sto_dac_r_mix)),
-
-	SND_SOC_DAPM_DAC("DAC R2", NULL, RT5640_PWR_DIG1, RT5640_PWR_DAC_R2_BIT,
-		0),
-	SND_SOC_DAPM_DAC("DAC L2", NULL, RT5640_PWR_DIG1, RT5640_PWR_DAC_L2_BIT,
-		0),
-
-	SND_SOC_DAPM_MIXER("OUT MIXL", RT5640_PWR_MIXER, RT5640_PWR_OM_L_BIT,
-		0, rt5640_out_l_mix, ARRAY_SIZE(rt5640_out_l_mix)),
-	SND_SOC_DAPM_MIXER("OUT MIXR", RT5640_PWR_MIXER, RT5640_PWR_OM_R_BIT,
-		0, rt5640_out_r_mix, ARRAY_SIZE(rt5640_out_r_mix)),
-
-	SND_SOC_DAPM_MIXER("HPO MIX L", SND_SOC_NOPM, 0, 0,
-		rt5640_hpo_mix, ARRAY_SIZE(rt5640_hpo_mix)),
-	SND_SOC_DAPM_MIXER("HPO MIX R", SND_SOC_NOPM, 0, 0,
-		rt5640_hpo_mix, ARRAY_SIZE(rt5640_hpo_mix)),
-
-	SND_SOC_DAPM_MIXER("Mono MIX", RT5640_PWR_ANLG1, RT5640_PWR_MM_BIT, 0,
-		rt5640_mono_mix, ARRAY_SIZE(rt5640_mono_mix)),
-	SND_SOC_DAPM_SUPPLY("Improve MONO Amp Drv", RT5640_PWR_ANLG1,
-		RT5640_PWR_MA_BIT, 0, NULL, 0),
-
 	SND_SOC_DAPM_OUTPUT("MONOP"),
 	SND_SOC_DAPM_OUTPUT("MONON"),
 };
 
-static const struct snd_soc_dapm_widget rt5639_specific_dapm_widgets[] = {
-	SND_SOC_DAPM_MIXER("Stereo DAC MIXL", SND_SOC_NOPM, 0, 0,
-		rt5639_sto_dac_l_mix, ARRAY_SIZE(rt5639_sto_dac_l_mix)),
-	SND_SOC_DAPM_MIXER("Stereo DAC MIXR", SND_SOC_NOPM, 0, 0,
-		rt5639_sto_dac_r_mix, ARRAY_SIZE(rt5639_sto_dac_r_mix)),
-
-	SND_SOC_DAPM_SUPPLY("DAC L2 Filter", RT5640_PWR_DIG1,
-		RT5640_PWR_DAC_L2_BIT, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("DAC R2 Filter", RT5640_PWR_DIG1,
-		RT5640_PWR_DAC_R2_BIT, 0, NULL, 0),
-
-	SND_SOC_DAPM_MIXER("OUT MIXL", RT5640_PWR_MIXER, RT5640_PWR_OM_L_BIT,
-		0, rt5639_out_l_mix, ARRAY_SIZE(rt5639_out_l_mix)),
-	SND_SOC_DAPM_MIXER("OUT MIXR", RT5640_PWR_MIXER, RT5640_PWR_OM_R_BIT,
-		0, rt5639_out_r_mix, ARRAY_SIZE(rt5639_out_r_mix)),
-
-	SND_SOC_DAPM_MIXER("HPO MIX L", SND_SOC_NOPM, 0, 0,
-		rt5639_hpo_mix, ARRAY_SIZE(rt5639_hpo_mix)),
-	SND_SOC_DAPM_MIXER("HPO MIX R", SND_SOC_NOPM, 0, 0,
-		rt5639_hpo_mix, ARRAY_SIZE(rt5639_hpo_mix)),
-};
-
 static const struct snd_soc_dapm_route rt5640_dapm_routes[] = {
 	{"IN1P", NULL, "LDO2"},
 	{"IN2P", NULL, "LDO2"},
@@ -1343,22 +1317,22 @@
 	{"Stereo ADC MIXL", "ADC1 Switch", "Stereo ADC L1 Mux"},
 	{"Stereo ADC MIXL", "ADC2 Switch", "Stereo ADC L2 Mux"},
 	{"Stereo ADC MIXL", NULL, "Stereo Filter"},
-	{"Stereo Filter", NULL, "PLL1", is_sys_clk_from_pll},
+	{"Stereo Filter", NULL, "PLL1", check_sysclk1_source},
 
 	{"Stereo ADC MIXR", "ADC1 Switch", "Stereo ADC R1 Mux"},
 	{"Stereo ADC MIXR", "ADC2 Switch", "Stereo ADC R2 Mux"},
 	{"Stereo ADC MIXR", NULL, "Stereo Filter"},
-	{"Stereo Filter", NULL, "PLL1", is_sys_clk_from_pll},
+	{"Stereo Filter", NULL, "PLL1", check_sysclk1_source},
 
 	{"Mono ADC MIXL", "ADC1 Switch", "Mono ADC L1 Mux"},
 	{"Mono ADC MIXL", "ADC2 Switch", "Mono ADC L2 Mux"},
 	{"Mono ADC MIXL", NULL, "Mono Left Filter"},
-	{"Mono Left Filter", NULL, "PLL1", is_sys_clk_from_pll},
+	{"Mono Left Filter", NULL, "PLL1", check_sysclk1_source},
 
 	{"Mono ADC MIXR", "ADC1 Switch", "Mono ADC R1 Mux"},
 	{"Mono ADC MIXR", "ADC2 Switch", "Mono ADC R2 Mux"},
 	{"Mono ADC MIXR", NULL, "Mono Right Filter"},
-	{"Mono Right Filter", NULL, "PLL1", is_sys_clk_from_pll},
+	{"Mono Right Filter", NULL, "PLL1", check_sysclk1_source},
 
 	{"IF2 ADC L", NULL, "Mono ADC MIXL"},
 	{"IF2 ADC R", NULL, "Mono ADC MIXR"},
@@ -1416,38 +1390,71 @@
 	{"DAC MIXR", "Stereo ADC Switch", "Stereo ADC MIXR"},
 	{"DAC MIXR", "INF1 Switch", "IF1 DAC R"},
 
+	{"ANC", NULL, "Stereo ADC MIXL"},
+	{"ANC", NULL, "Stereo ADC MIXR"},
+
+	{"Audio DSP", NULL, "DAC MIXL"},
+	{"Audio DSP", NULL, "DAC MIXR"},
+
+	{"DAC L2 Mux", "IF2", "IF2 DAC L"},
+	{"DAC L2 Mux", "Base L/R", "Audio DSP"},
+
+	{"DAC R2 Mux", "IF2", "IF2 DAC R"},
+
 	{"Stereo DAC MIXL", "DAC L1 Switch", "DAC MIXL"},
+	{"Stereo DAC MIXL", "DAC L2 Switch", "DAC L2 Mux"},
+	{"Stereo DAC MIXL", "ANC Switch", "ANC"},
 	{"Stereo DAC MIXR", "DAC R1 Switch", "DAC MIXR"},
+	{"Stereo DAC MIXR", "DAC R2 Switch", "DAC R2 Mux"},
+	{"Stereo DAC MIXR", "ANC Switch", "ANC"},
 
 	{"Mono DAC MIXL", "DAC L1 Switch", "DAC MIXL"},
+	{"Mono DAC MIXL", "DAC L2 Switch", "DAC L2 Mux"},
+	{"Mono DAC MIXL", "DAC R2 Switch", "DAC R2 Mux"},
 	{"Mono DAC MIXR", "DAC R1 Switch", "DAC MIXR"},
+	{"Mono DAC MIXR", "DAC R2 Switch", "DAC R2 Mux"},
+	{"Mono DAC MIXR", "DAC L2 Switch", "DAC L2 Mux"},
 
 	{"DIG MIXL", "DAC L1 Switch", "DAC MIXL"},
+	{"DIG MIXL", "DAC L2 Switch", "DAC L2 Mux"},
 	{"DIG MIXR", "DAC R1 Switch", "DAC MIXR"},
+	{"DIG MIXR", "DAC R2 Switch", "DAC R2 Mux"},
 
 	{"DAC L1", NULL, "Stereo DAC MIXL"},
-	{"DAC L1", NULL, "PLL1", is_sys_clk_from_pll},
+	{"DAC L1", NULL, "PLL1", check_sysclk1_source},
 	{"DAC R1", NULL, "Stereo DAC MIXR"},
-	{"DAC R1", NULL, "PLL1", is_sys_clk_from_pll},
+	{"DAC R1", NULL, "PLL1", check_sysclk1_source},
+	{"DAC L2", NULL, "Mono DAC MIXL"},
+	{"DAC L2", NULL, "PLL1", check_sysclk1_source},
+	{"DAC R2", NULL, "Mono DAC MIXR"},
+	{"DAC R2", NULL, "PLL1", check_sysclk1_source},
 
 	{"SPK MIXL", "REC MIXL Switch", "RECMIXL"},
 	{"SPK MIXL", "INL Switch", "INL VOL"},
 	{"SPK MIXL", "DAC L1 Switch", "DAC L1"},
+	{"SPK MIXL", "DAC L2 Switch", "DAC L2"},
 	{"SPK MIXL", "OUT MIXL Switch", "OUT MIXL"},
 	{"SPK MIXR", "REC MIXR Switch", "RECMIXR"},
 	{"SPK MIXR", "INR Switch", "INR VOL"},
 	{"SPK MIXR", "DAC R1 Switch", "DAC R1"},
+	{"SPK MIXR", "DAC R2 Switch", "DAC R2"},
 	{"SPK MIXR", "OUT MIXR Switch", "OUT MIXR"},
 
+	{"OUT MIXL", "SPK MIXL Switch", "SPK MIXL"},
 	{"OUT MIXL", "BST1 Switch", "BST1"},
 	{"OUT MIXL", "INL Switch", "INL VOL"},
 	{"OUT MIXL", "REC MIXL Switch", "RECMIXL"},
+	{"OUT MIXL", "DAC R2 Switch", "DAC R2"},
+	{"OUT MIXL", "DAC L2 Switch", "DAC L2"},
 	{"OUT MIXL", "DAC L1 Switch", "DAC L1"},
 
+	{"OUT MIXR", "SPK MIXR Switch", "SPK MIXR"},
 	{"OUT MIXR", "BST2 Switch", "BST2"},
 	{"OUT MIXR", "BST1 Switch", "BST1"},
 	{"OUT MIXR", "INR Switch", "INR VOL"},
 	{"OUT MIXR", "REC MIXR Switch", "RECMIXR"},
+	{"OUT MIXR", "DAC L2 Switch", "DAC L2"},
+	{"OUT MIXR", "DAC R2 Switch", "DAC R2"},
 	{"OUT MIXR", "DAC R1 Switch", "DAC R1"},
 
 	{"SPKVOL L", NULL, "SPK MIXL"},
@@ -1466,9 +1473,11 @@
 	{"SPOR MIX", "SPKVOL R Switch", "SPKVOL R"},
 	{"SPOR MIX", "BST1 Switch", "BST1"},
 
+	{"HPO MIX L", "HPO MIX DAC2 Switch", "DAC L2"},
 	{"HPO MIX L", "HPO MIX DAC1 Switch", "DAC L1"},
 	{"HPO MIX L", "HPO MIX HPVOL Switch", "HPOVOL L"},
 	{"HPO MIX L", NULL, "HP L Amp"},
+	{"HPO MIX R", "HPO MIX DAC2 Switch", "DAC R2"},
 	{"HPO MIX R", "HPO MIX DAC1 Switch", "DAC R1"},
 	{"HPO MIX R", "HPO MIX HPVOL Switch", "HPOVOL R"},
 	{"HPO MIX R", NULL, "HP R Amp"},
@@ -1478,6 +1487,12 @@
 	{"LOUT MIX", "OUTVOL L Switch", "OUTVOL L"},
 	{"LOUT MIX", "OUTVOL R Switch", "OUTVOL R"},
 
+	{"Mono MIX", "DAC R2 Switch", "DAC R2"},
+	{"Mono MIX", "DAC L2 Switch", "DAC L2"},
+	{"Mono MIX", "OUTVOL R Switch", "OUTVOL R"},
+	{"Mono MIX", "OUTVOL L Switch", "OUTVOL L"},
+	{"Mono MIX", "BST1 Switch", "BST1"},
+
 	{"HP Amp", NULL, "HPO MIX L"},
 	{"HP Amp", NULL, "HPO MIX R"},
 
@@ -1502,82 +1517,11 @@
 	{"HPOR", NULL, "HP R Playback"},
 	{"LOUTL", NULL, "LOUT MIX"},
 	{"LOUTR", NULL, "LOUT MIX"},
-};
-
-static const struct snd_soc_dapm_route rt5640_specific_dapm_routes[] = {
-	{"ANC", NULL, "Stereo ADC MIXL"},
-	{"ANC", NULL, "Stereo ADC MIXR"},
-
-	{"Audio DSP", NULL, "DAC MIXL"},
-	{"Audio DSP", NULL, "DAC MIXR"},
-
-	{"DAC L2 Mux", "IF2", "IF2 DAC L"},
-	{"DAC L2 Mux", "Base L/R", "Audio DSP"},
-
-	{"DAC R2 Mux", "IF2", "IF2 DAC R"},
-
-	{"Stereo DAC MIXL", "DAC L2 Switch", "DAC L2 Mux"},
-	{"Stereo DAC MIXL", "ANC Switch", "ANC"},
-	{"Stereo DAC MIXR", "DAC R2 Switch", "DAC R2 Mux"},
-	{"Stereo DAC MIXR", "ANC Switch", "ANC"},
-
-	{"Mono DAC MIXL", "DAC L2 Switch", "DAC L2 Mux"},
-	{"Mono DAC MIXL", "DAC R2 Switch", "DAC R2 Mux"},
-
-	{"Mono DAC MIXR", "DAC R2 Switch", "DAC R2 Mux"},
-	{"Mono DAC MIXR", "DAC L2 Switch", "DAC L2 Mux"},
-
-	{"DIG MIXR", "DAC R2 Switch", "DAC R2 Mux"},
-	{"DIG MIXL", "DAC L2 Switch", "DAC L2 Mux"},
-
-	{"DAC L2", NULL, "Mono DAC MIXL"},
-	{"DAC L2", NULL, "PLL1", is_sys_clk_from_pll},
-	{"DAC R2", NULL, "Mono DAC MIXR"},
-	{"DAC R2", NULL, "PLL1", is_sys_clk_from_pll},
-
-	{"SPK MIXL", "DAC L2 Switch", "DAC L2"},
-	{"SPK MIXR", "DAC R2 Switch", "DAC R2"},
-
-	{"OUT MIXL", "SPK MIXL Switch", "SPK MIXL"},
-	{"OUT MIXR", "SPK MIXR Switch", "SPK MIXR"},
-
-	{"OUT MIXL", "DAC R2 Switch", "DAC R2"},
-	{"OUT MIXL", "DAC L2 Switch", "DAC L2"},
-
-	{"OUT MIXR", "DAC L2 Switch", "DAC L2"},
-	{"OUT MIXR", "DAC R2 Switch", "DAC R2"},
-
-	{"HPO MIX L", "HPO MIX DAC2 Switch", "DAC L2"},
-	{"HPO MIX R", "HPO MIX DAC2 Switch", "DAC R2"},
-
-	{"Mono MIX", "DAC R2 Switch", "DAC R2"},
-	{"Mono MIX", "DAC L2 Switch", "DAC L2"},
-	{"Mono MIX", "OUTVOL R Switch", "OUTVOL R"},
-	{"Mono MIX", "OUTVOL L Switch", "OUTVOL L"},
-	{"Mono MIX", "BST1 Switch", "BST1"},
-
 	{"MONOP", NULL, "Mono MIX"},
 	{"MONON", NULL, "Mono MIX"},
 	{"MONOP", NULL, "Improve MONO Amp Drv"},
 };
 
-static const struct snd_soc_dapm_route rt5639_specific_dapm_routes[] = {
-	{"Stereo DAC MIXL", "DAC L2 Switch", "IF2 DAC L"},
-	{"Stereo DAC MIXR", "DAC R2 Switch", "IF2 DAC R"},
-
-	{"Mono DAC MIXL", "DAC L2 Switch", "IF2 DAC L"},
-	{"Mono DAC MIXL", "DAC R2 Switch", "IF2 DAC R"},
-
-	{"Mono DAC MIXR", "DAC R2 Switch", "IF2 DAC R"},
-	{"Mono DAC MIXR", "DAC L2 Switch", "IF2 DAC L"},
-
-	{"DIG MIXL", "DAC L2 Switch", "IF2 DAC L"},
-	{"DIG MIXR", "DAC R2 Switch", "IF2 DAC R"},
-
-	{"IF2 DAC L", NULL, "DAC L2 Filter"},
-	{"IF2 DAC R", NULL, "DAC R2 Filter"},
-};
-
 static int get_sdp_info(struct snd_soc_codec *codec, int dai_id)
 {
 	int ret = 0, val;
@@ -1629,7 +1573,8 @@
 static int rt5640_hw_params(struct snd_pcm_substream *substream,
 	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
 {
-	struct snd_soc_codec *codec = dai->codec;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
 	struct rt5640_priv *rt5640 = snd_soc_codec_get_drvdata(codec);
 	unsigned int val_len = 0, val_clk, mask_clk;
 	int dai_sel, pre_div, bclk_ms, frame_size;
@@ -1657,16 +1602,16 @@
 	dev_dbg(dai->dev, "bclk_ms is %d and pre_div is %d for iis %d\n",
 				bclk_ms, pre_div, dai->id);
 
-	switch (params_width(params)) {
-	case 16:
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
 		break;
-	case 20:
+	case SNDRV_PCM_FORMAT_S20_3LE:
 		val_len |= RT5640_I2S_DL_20;
 		break;
-	case 24:
+	case SNDRV_PCM_FORMAT_S24_LE:
 		val_len |= RT5640_I2S_DL_24;
 		break;
-	case 8:
+	case SNDRV_PCM_FORMAT_S8:
 		val_len |= RT5640_I2S_DL_8;
 		break;
 	default:
@@ -1779,6 +1724,12 @@
 	case RT5640_SCLK_S_PLL1:
 		reg_val |= RT5640_SCLK_SRC_PLL1;
 		break;
+	case RT5640_SCLK_S_PLL1_TK:
+		reg_val |= RT5640_SCLK_SRC_PLL1T;
+		break;
+	case RT5640_SCLK_S_RCCLK:
+		reg_val |= RT5640_SCLK_SRC_RCCLK;
+		break;
 	default:
 		dev_err(codec->dev, "Invalid clock id (%d)\n", clk_id);
 		return -EINVAL;
@@ -1867,9 +1818,11 @@
 static int rt5640_set_bias_level(struct snd_soc_codec *codec,
 			enum snd_soc_bias_level level)
 {
+	struct rt5640_priv *rt5640 = snd_soc_codec_get_drvdata(codec);
 	switch (level) {
 	case SND_SOC_BIAS_STANDBY:
 		if (SND_SOC_BIAS_OFF == codec->dapm.bias_level) {
+			regcache_cache_only(rt5640->regmap, false);
 			snd_soc_update_bits(codec, RT5640_PWR_ANLG1,
 				RT5640_PWR_VREF1 | RT5640_PWR_MB |
 				RT5640_PWR_BG | RT5640_PWR_VREF2,
@@ -1879,6 +1832,7 @@
 			snd_soc_update_bits(codec, RT5640_PWR_ANLG1,
 				RT5640_PWR_FV1 | RT5640_PWR_FV2,
 				RT5640_PWR_FV1 | RT5640_PWR_FV2);
+			regcache_sync(rt5640->regmap);
 			snd_soc_update_bits(codec, RT5640_DUMMY1,
 						0x0301, 0x0301);
 			snd_soc_update_bits(codec, RT5640_MICBIAS,
@@ -1906,75 +1860,19 @@
 	return 0;
 }
 
-int rt5640_dmic_enable(struct snd_soc_codec *codec,
-		       bool dmic1_data_pin, bool dmic2_data_pin)
-{
-	struct rt5640_priv *rt5640 = snd_soc_codec_get_drvdata(codec);
-
-	regmap_update_bits(rt5640->regmap, RT5640_GPIO_CTRL1,
-		RT5640_GP2_PIN_MASK, RT5640_GP2_PIN_DMIC1_SCL);
-
-	if (dmic1_data_pin) {
-		regmap_update_bits(rt5640->regmap, RT5640_DMIC,
-			RT5640_DMIC_1_DP_MASK, RT5640_DMIC_1_DP_GPIO3);
-		regmap_update_bits(rt5640->regmap, RT5640_GPIO_CTRL1,
-			RT5640_GP3_PIN_MASK, RT5640_GP3_PIN_DMIC1_SDA);
-	}
-
-	if (dmic2_data_pin) {
-		regmap_update_bits(rt5640->regmap, RT5640_DMIC,
-			RT5640_DMIC_2_DP_MASK, RT5640_DMIC_2_DP_GPIO4);
-		regmap_update_bits(rt5640->regmap, RT5640_GPIO_CTRL1,
-			RT5640_GP4_PIN_MASK, RT5640_GP4_PIN_DMIC2_SDA);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(rt5640_dmic_enable);
-
 static int rt5640_probe(struct snd_soc_codec *codec)
 {
 	struct rt5640_priv *rt5640 = snd_soc_codec_get_drvdata(codec);
 
 	rt5640->codec = codec;
 
+	codec->dapm.idle_bias_off = 1;
 	rt5640_set_bias_level(codec, SND_SOC_BIAS_OFF);
 
 	snd_soc_update_bits(codec, RT5640_DUMMY1, 0x0301, 0x0301);
 	snd_soc_update_bits(codec, RT5640_MICBIAS, 0x0030, 0x0030);
 	snd_soc_update_bits(codec, RT5640_DSP_PATH2, 0xfc00, 0x0c00);
 
-	switch (snd_soc_read(codec, RT5640_RESET) & RT5640_ID_MASK) {
-	case RT5640_ID_5640:
-	case RT5640_ID_5642:
-		snd_soc_add_codec_controls(codec,
-			rt5640_specific_snd_controls,
-			ARRAY_SIZE(rt5640_specific_snd_controls));
-		snd_soc_dapm_new_controls(&codec->dapm,
-			rt5640_specific_dapm_widgets,
-			ARRAY_SIZE(rt5640_specific_dapm_widgets));
-		snd_soc_dapm_add_routes(&codec->dapm,
-			rt5640_specific_dapm_routes,
-			ARRAY_SIZE(rt5640_specific_dapm_routes));
-		break;
-	case RT5640_ID_5639:
-		snd_soc_dapm_new_controls(&codec->dapm,
-			rt5639_specific_dapm_widgets,
-			ARRAY_SIZE(rt5639_specific_dapm_widgets));
-		snd_soc_dapm_add_routes(&codec->dapm,
-			rt5639_specific_dapm_routes,
-			ARRAY_SIZE(rt5639_specific_dapm_routes));
-		break;
-	default:
-		dev_err(codec->dev,
-			"The driver is for RT5639 RT5640 or RT5642 only\n");
-		return -ENODEV;
-	}
-
-	if (rt5640->pdata.dmic_en)
-		rt5640_dmic_enable(codec, rt5640->pdata.dmic1_data_pin,
-					  rt5640->pdata.dmic2_data_pin);
-
 	return 0;
 }
 
@@ -2009,9 +1907,6 @@
 		msleep(400);
 	}
 
-	regcache_cache_only(rt5640->regmap, false);
-	regcache_sync(rt5640->regmap);
-
 	return 0;
 }
 #else
@@ -2077,7 +1972,6 @@
 	.suspend = rt5640_suspend,
 	.resume = rt5640_resume,
 	.set_bias_level = rt5640_set_bias_level,
-	.idle_bias_off = true,
 	.controls = rt5640_snd_controls,
 	.num_controls = ARRAY_SIZE(rt5640_snd_controls),
 	.dapm_widgets = rt5640_dapm_widgets,
@@ -2089,7 +1983,6 @@
 static const struct regmap_config rt5640_regmap = {
 	.reg_bits = 8,
 	.val_bits = 16,
-	.use_single_rw = true,
 
 	.max_register = RT5640_VENDOR_ID2 + 1 + (ARRAY_SIZE(rt5640_ranges) *
 					       RT5640_PR_SPACING),
@@ -2105,26 +1998,14 @@
 
 static const struct i2c_device_id rt5640_i2c_id[] = {
 	{ "rt5640", 0 },
-	{ "rt5639", 0 },
-	{ "rt5642", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, rt5640_i2c_id);
 
-#if defined(CONFIG_OF)
-static const struct of_device_id rt5640_of_match[] = {
-	{ .compatible = "realtek,rt5639", },
-	{ .compatible = "realtek,rt5640", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, rt5640_of_match);
-#endif
-
 #ifdef CONFIG_ACPI
 static struct acpi_device_id rt5640_acpi_match[] = {
 	{ "INT33CA", 0 },
 	{ "10EC5640", 0 },
-	{ "10EC5642", 0 },
 	{ },
 };
 MODULE_DEVICE_TABLE(acpi, rt5640_acpi_match);
@@ -2205,7 +2086,7 @@
 	}
 
 	regmap_read(rt5640->regmap, RT5640_VENDOR_ID2, &val);
-	if (val != RT5640_DEVICE_ID) {
+	if ((val != RT5640_DEVICE_ID)) {
 		dev_err(&i2c->dev,
 			"Device with ID register %x is not rt5640/39\n", val);
 		return -ENODEV;
@@ -2228,8 +2109,14 @@
 
 	rt5640->hp_mute = 1;
 
-	return snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5640,
-				      rt5640_dai, ARRAY_SIZE(rt5640_dai));
+	ret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5640,
+			rt5640_dai, ARRAY_SIZE(rt5640_dai));
+	if (ret < 0)
+		goto err;
+
+	return 0;
+err:
+	return ret;
 }
 
 static int rt5640_i2c_remove(struct i2c_client *i2c)
@@ -2244,7 +2131,6 @@
 		.name = "rt5640",
 		.owner = THIS_MODULE,
 		.acpi_match_table = ACPI_PTR(rt5640_acpi_match),
-		.of_match_table = of_match_ptr(rt5640_of_match),
 	},
 	.probe = rt5640_i2c_probe,
 	.remove   = rt5640_i2c_remove,
@@ -2252,6 +2138,6 @@
 };
 module_i2c_driver(rt5640_i2c_driver);
 
-MODULE_DESCRIPTION("ASoC RT5640/RT5639 driver");
+MODULE_DESCRIPTION("ASoC RT5640 driver");
 MODULE_AUTHOR("Johnny Hsu <johnnyhsu@realtek.com>");
 MODULE_LICENSE("GPL v2");
diff -Naur linux-3.19.old/sound/soc/codecs/rt5640.h linux-3.19/sound/soc/codecs/rt5640.h
--- linux-3.19.old/sound/soc/codecs/rt5640.h	2015-03-24 17:38:13.876510304 -0800
+++ linux-3.19/sound/soc/codecs/rt5640.h	2015-03-24 18:28:21.328013360 -0800
@@ -192,13 +192,6 @@
 #define RT5640_R_VOL_MASK			(0x3f)
 #define RT5640_R_VOL_SFT			0
 
-/* SW Reset & Device ID (0x00) */
-#define RT5640_ID_MASK				(0x3 << 1)
-#define RT5640_ID_5639				(0x0 << 1)
-#define RT5640_ID_5640				(0x2 << 1)
-#define RT5640_ID_5642				(0x3 << 1)
-
-
 /* IN1 and IN2 Control (0x0d) */
 /* IN3 and IN4 Control (0x0e) */
 #define RT5640_BST_SFT1				12
@@ -983,6 +976,8 @@
 #define RT5640_SCLK_SRC_SFT			14
 #define RT5640_SCLK_SRC_MCLK			(0x0 << 14)
 #define RT5640_SCLK_SRC_PLL1			(0x1 << 14)
+#define RT5640_SCLK_SRC_PLL1T			(0x2 << 14)
+#define RT5640_SCLK_SRC_RCCLK			(0x3 << 14) /* 15MHz */
 #define RT5640_PLL1_SRC_MASK			(0x3 << 12)
 #define RT5640_PLL1_SRC_SFT			12
 #define RT5640_PLL1_SRC_MCLK			(0x0 << 12)
@@ -2094,10 +2089,8 @@
 	int pll_in;
 	int pll_out;
 
+	int dmic_en;
 	bool hp_mute;
 };
 
-int rt5640_dmic_enable(struct snd_soc_codec *codec,
-		       bool dmic1_data_pin, bool dmic2_data_pin);
-
 #endif
diff -Naur linux-3.19.old/sound/soc/codecs/rt5677.c linux-3.19/sound/soc/codecs/rt5677.c
--- linux-3.19.old/sound/soc/codecs/rt5677.c	2015-03-24 20:38:34.976468486 -0800
+++ linux-3.19/sound/soc/codecs/rt5677.c	2015-03-24 18:31:09.268018369 -0800
@@ -20,8 +20,13 @@
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/acpi.h>
 #include <linux/firmware.h>
 #include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/workqueue.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -36,6 +41,10 @@
 
 #define RT5677_DEVICE_ID 0x6327
 
+/* Register controlling boot vector */
+#define RT5677_DSP_BOOT_VECTOR		0x1801f090
+#define RT5677_MODEL_ADDR		0x5FFC9800
+
 #define RT5677_PR_RANGE_BASE (0xff + 1)
 #define RT5677_PR_SPACING 0x100
 
@@ -293,6 +302,7 @@
 	case RT5677_I2C_MASTER_CTRL7:
 	case RT5677_I2C_MASTER_CTRL8:
 	case RT5677_HAP_GENE_CTRL2:
+	case RT5677_PWR_ANLG2: /* Modified by DSP firmware */
 	case RT5677_PWR_DSP_ST:
 	case RT5677_PRIV_DATA:
 	case RT5677_PLL1_CTRL2:
@@ -305,6 +315,8 @@
 	case RT5677_IRQ_CTRL1:
 	case RT5677_IRQ_CTRL2:
 	case RT5677_GPIO_ST:
+	case RT5677_GPIO_CTRL1: /* Modified by DSP firmware */
+	case RT5677_GPIO_CTRL2: /* Modified by DSP firmware */
 	case RT5677_DSP_INB1_SRC_CTRL4:
 	case RT5677_DSP_INB2_SRC_CTRL4:
 	case RT5677_DSP_INB3_SRC_CTRL4:
@@ -683,10 +695,8 @@
 	return ret;
 }
 
-static void rt5677_set_dsp_mode(struct snd_soc_codec *codec, bool on)
+static void rt5677_set_dsp_mode(struct rt5677_priv *rt5677, bool on)
 {
-	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
-
 	if (on) {
 		regmap_update_bits(rt5677->regmap, RT5677_PWR_DSP1, 0x2, 0x2);
 		rt5677->is_dsp_mode = true;
@@ -696,73 +706,259 @@
 	}
 }
 
+static unsigned int rt5677_set_vad_source(struct rt5677_priv *rt5677)
+{
+	struct snd_soc_dapm_context *dapm = &rt5677->codec->dapm;
+	/* The hotword audio path is from "DMIC L1" to "DSP Buffer".
+	 * "DSP Buffer" is then connected to "DSP Capture" which is the
+	 * rt5677-dsp-cpu-dai with a PCM interface in rt5677-spi.
+	 */
+	snd_soc_dapm_enable_pin(dapm, "DMIC L1");
+	snd_soc_dapm_sync(dapm);
+
+	/* Mono ADC Capture Switch = unmute (default) */
+	regmap_update_bits(rt5677->regmap, RT5677_MONO_ADC_DIG_VOL,
+			RT5677_L_MUTE, 0);
+
+	/* Mono ADC Boost Volume = 24dB */
+	regmap_update_bits(rt5677->regmap, RT5677_ADC_BST_CTRL2,
+		RT5677_MONO_ADC_L_BST_MASK | RT5677_MONO_ADC_R_BST_MASK,
+		0xa000);
+
+	/* Mono ADC MIXL = Mono ADC2 L Mux (unmute)
+	 *                 Mono ADC1 L Mux (mute)
+	 * Mono ADC2 L Mux = Mono DMIC L Mux
+	 * Mono DMIC L Mux = DMIC1 (left)
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_MONO_ADC_MIXER,
+		RT5677_M_MONO_ADC_L2 | RT5677_M_MONO_ADC_L1 |
+		RT5677_SEL_MONO_ADC_L2_MASK | RT5677_SEL_MONO_DMIC_L_SFT,
+		RT5677_M_MONO_ADC_L1 | (1 << RT5677_SEL_MONO_ADC_L2_SFT));
+
+	/* DMIC1 power = enabled
+	 * DMIC CLK = 256 * fs / 12
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_DMIC_CTRL1,
+		RT5677_DMIC_1_EN_MASK | RT5677_DMIC_CLK_MASK,
+		RT5677_DMIC_1_EN | (5 << RT5677_DMIC_CLK_SFT));
+
+	/* I2S pre divide 2 = /6 (clk_sys2) */
+	regmap_update_bits(rt5677->regmap, RT5677_CLK_TREE_CTRL1,
+		RT5677_I2S_PD2_MASK, RT5677_I2S_PD2_6);
+
+	/* System Clock = MCLK1
+	 * Stereo ADC/DAC over sample rate = 128Fs (default)
+	 */
+	regmap_write(rt5677->regmap, RT5677_GLB_CLK1, 0x0000);
+
+	/* DSP Clock = MCLK1 (bypassed PLL2) */
+	regmap_write(rt5677->regmap, RT5677_GLB_CLK2, 0x0080);
+
+	/* Clock source for Mono L ADC = clk_sys2 */
+	regmap_update_bits(rt5677->regmap, RT5677_ASRC_6, 0xf000, 0x7000);
+
+	/* SAD Threshold1 */
+	regmap_write(rt5677->regmap, RT5677_VAD_CTRL2, 0x013f);
+	/* SAD Threshold2 */
+	regmap_write(rt5677->regmap, RT5677_VAD_CTRL3, 0x0ae5);
+	/* SAD Sample Rate Converter = Up 6 (8K to 48K)
+	 * SAD Output Sample Rate = Same as I2S
+	 * VAD ADC Mux = MONO ADC MIX L
+	 * SAD Threshold3
+	 */
+	regmap_write(rt5677->regmap, RT5677_VAD_CTRL4, 0x017f);
+	/* Minimum frame level within a pre-determined duration = 32 frames
+	 * Bypass ADPCM Encoder/Decoder = Bypass ADPCM
+	 * Automatic Push Data to SAD Buffer Once SAD Flag is triggered = enable
+	 * SAD Buffer Over-Writing = enable
+	 * SAD Buffer Pop Mode Control = disable
+	 * SAD Buffer Push Mode Control = enable
+	 * SAD Detector Control = enable
+	 * SAD Function Control = enable
+	 * SAD Function Reset = normal
+	 */
+	regmap_write(rt5677->regmap, RT5677_VAD_CTRL1, 0x273c);
+
+	/* InBound0/1 Source = VAD ADC/DAC1 FS */
+	regmap_update_bits(rt5677->regmap, RT5677_DSP_INB_CTRL1,
+		RT5677_IB01_SRC_MASK, 4 << RT5677_IB01_SRC_SFT);
+
+	/* VAD/SAD is not routed to the IRQ output (i.e. MX-BE[14] = 0), but it
+	 * is routed to DSP_IRQ_0, so DSP firmware may use it to sleep and save
+	 * power. See ALC5677 datasheet section 9.17 "GPIO, Interrupt and Jack
+	 * Detection" for more info.
+	 */
+
+	/* Enable Gating Mode with MCLK = enable */
+	regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC, 0x1, 0x1);
+
+	/* Private register, no doc */
+	regmap_update_bits(rt5677->regmap, RT5677_PR_BASE + RT5677_BIAS_CUR4,
+		0x0f00, 0x0100);
+
+	/* adc mono left filter = power on */
+	regmap_update_bits(rt5677->regmap, RT5677_PWR_DIG2,
+		RT5677_PWR_ADC_MF_L, RT5677_PWR_ADC_MF_L);
+
+	/* LDO2 output = 1.2V
+	 * LDO1 output = 1.2V (LDO_IN = 1.8V)
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG1,
+		RT5677_LDO1_SEL_MASK | RT5677_LDO2_SEL_MASK,
+		0x0055);
+
+	/* Codec core power =  power on
+	 * LDO1 power = power on
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG2,
+		RT5677_PWR_CORE | RT5677_PWR_LDO1,
+		RT5677_PWR_CORE | RT5677_PWR_LDO1);
+
+	/* Isolation for DCVDD4 = normal (set during probe)
+	 * Isolation for DCVDD2 = normal (set during probe)
+	 * Isolation for DSP = normal
+	 * Isolation for Band 0~7 = disable
+	 * Isolation for InBound 4~10 and OutBound 4~10 = disable
+	 */
+	regmap_write(rt5677->regmap, RT5677_PWR_DSP2, 0x07ff);
+
+	/* System Band 0~7 = power on
+	 * InBound 4~10 and OutBound 4~10 = power on
+	 * DSP = power on
+	 * DSP CPU = stop (will be set to "run" after firmware loaded)
+	 */
+	regmap_write(rt5677->regmap, RT5677_PWR_DSP1, 0x07ff);
+
+	return 0;
+}
+
+static int rt5677_parse_and_load_dsp(struct rt5677_priv *rt5677, const u8 *buf,
+		unsigned int len)
+{
+	struct snd_soc_codec *codec = rt5677->codec;
+	Elf32_Ehdr *elf_hdr;
+	Elf32_Phdr *pr_hdr;
+	Elf32_Half i;
+	int ret = 0;
+
+	if (!buf || (len < sizeof(Elf32_Ehdr)))
+		return -ENOMEM;
+
+	elf_hdr = (Elf32_Ehdr *)buf;
+#ifndef EM_XTENSA
+#define EM_XTENSA	94
+#endif
+	if (strncmp(elf_hdr->e_ident, ELFMAG, sizeof(ELFMAG) - 1))
+		dev_err(codec->dev, "Wrong ELF header prefix\n");
+	if (elf_hdr->e_ehsize != sizeof(Elf32_Ehdr))
+		dev_err(codec->dev, "Wrong Elf header size\n");
+	if (elf_hdr->e_machine != EM_XTENSA)
+		dev_err(codec->dev, "Wrong DSP code file\n");
+
+	if (len < elf_hdr->e_phoff)
+		return -ENOMEM;
+	pr_hdr = (Elf32_Phdr *)(buf + elf_hdr->e_phoff);
+	for (i = 0; i < elf_hdr->e_phnum; i++) {
+		/* TODO: handle p_memsz != p_filesz */
+		if (pr_hdr->p_paddr && pr_hdr->p_filesz) {
+			dev_info(codec->dev, "Load 0x%x bytes to 0x%x\n",
+					pr_hdr->p_filesz, pr_hdr->p_paddr);
+
+			ret = rt5677_spi_write(pr_hdr->p_paddr,
+					buf + pr_hdr->p_offset,
+					pr_hdr->p_filesz);
+			if (ret)
+				dev_err(codec->dev, "Load firmware failed %d\n",
+						ret);
+		}
+		pr_hdr++;
+	}
+	return ret;
+}
+
+static int rt5677_load_dsp_from_file(struct rt5677_priv *rt5677)
+{
+	const struct firmware *fwp;
+	struct device *dev = rt5677->codec->dev;
+	int ret = 0;
+
+	/* Load dsp firmware from rt5677_elf_vad file */
+	ret = request_firmware(&fwp, "rt5677_elf_vad", dev);
+	if (ret) {
+		dev_err(dev, "Request rt5677_elf_vad failed %d\n", ret);
+		return ret;
+	}
+	dev_info(dev, "Requested rt5677_elf_vad (%zu)\n", fwp->size);
+
+	ret = rt5677_parse_and_load_dsp(rt5677, fwp->data, fwp->size);
+	release_firmware(fwp);
+	return ret;
+}
+
 static int rt5677_set_dsp_vad(struct snd_soc_codec *codec, bool on)
 {
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
-	static bool activity;
-	int ret;
+	rt5677->dsp_vad_en = on;
+	schedule_delayed_work(&rt5677->dsp_work, 0);
+	return 0;
+}
 
-	if (!IS_ENABLED(CONFIG_SND_SOC_RT5677_SPI))
-		return -ENXIO;
+static void rt5677_dsp_work(struct work_struct *work)
+{
+	struct rt5677_priv *rt5677 =
+		container_of(work, struct rt5677_priv, dsp_work.work);
+	static bool activity;
+	bool enable = rt5677->dsp_vad_en;
 
-	if (on && !activity) {
+	dev_info(rt5677->codec->dev, "DSP VAD: enable=%d, activity=%d\n",
+			enable, activity);
+	if (enable && !activity) {
 		activity = true;
 
-		regcache_cache_only(rt5677->regmap, false);
-		regcache_cache_bypass(rt5677->regmap, true);
+		/* Before a hotword is detected, GPIO1 pin is configured as IRQ
+		 * output so that jack detect works. When a hotword is detected,
+		 * the DSP firmware configures the GPIO1 pin as GPIO1 and
+		 * drives a 1. rt5677_irq() is called after a rising edge on
+		 * the GPIO1 pin, due to either jack detect event or hotword
+		 * event, or both. All possible events are checked and handled
+		 * in rt5677_irq() where GPIO1 pin is configured back to IRQ
+		 * output if a hotword is detected.
+		 */
 
-		regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC, 0x1, 0x1);
-		regmap_update_bits(rt5677->regmap,
-			RT5677_PR_BASE + RT5677_BIAS_CUR4, 0x0f00, 0x0f00);
-		regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG1,
-			RT5677_LDO1_SEL_MASK, 0x0);
-		regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG2,
-			RT5677_PWR_LDO1, RT5677_PWR_LDO1);
-		regmap_update_bits(rt5677->regmap, RT5677_GLB_CLK1,
-			RT5677_MCLK_SRC_MASK, RT5677_MCLK2_SRC);
-		regmap_update_bits(rt5677->regmap, RT5677_GLB_CLK2,
-			RT5677_PLL2_PR_SRC_MASK | RT5677_DSP_CLK_SRC_MASK,
-			RT5677_PLL2_PR_SRC_MCLK2 | RT5677_DSP_CLK_SRC_BYPASS);
-		regmap_write(rt5677->regmap, RT5677_PWR_DSP2, 0x07ff);
-		regmap_write(rt5677->regmap, RT5677_PWR_DSP1, 0x07fd);
-		rt5677_set_dsp_mode(codec, true);
-
-		ret = request_firmware(&rt5677->fw1, RT5677_FIRMWARE1,
-			codec->dev);
-		if (ret == 0) {
-			rt5677_spi_burst_write(0x50000000, rt5677->fw1);
-			release_firmware(rt5677->fw1);
-		}
+		rt5677_set_vad_source(rt5677);
+		rt5677_set_dsp_mode(rt5677, true);
 
-		ret = request_firmware(&rt5677->fw2, RT5677_FIRMWARE2,
-			codec->dev);
-		if (ret == 0) {
-			rt5677_spi_burst_write(0x60000000, rt5677->fw2);
-			release_firmware(rt5677->fw2);
-		}
+		/* Boot the firmware from IRAM instead of SRAM0. */
+		rt5677_dsp_mode_i2c_write_addr(rt5677, RT5677_DSP_BOOT_VECTOR,
+			0x0009, 0x0003);
+		rt5677_dsp_mode_i2c_write_addr(rt5677, RT5677_DSP_BOOT_VECTOR,
+			0x0019, 0x0003);
+		rt5677_dsp_mode_i2c_write_addr(rt5677, RT5677_DSP_BOOT_VECTOR,
+			0x0009, 0x0003);
 
-		regmap_update_bits(rt5677->regmap, RT5677_PWR_DSP1, 0x1, 0x0);
+		rt5677_load_dsp_from_file(rt5677);
 
-		regcache_cache_bypass(rt5677->regmap, false);
-		regcache_cache_only(rt5677->regmap, true);
-	} else if (!on && activity) {
+		/* Set DSP CPU to Run */
+		regmap_update_bits(rt5677->regmap, RT5677_PWR_DSP1, 0x1, 0x0);
+	} else if (!enable && activity) {
 		activity = false;
 
-		regcache_cache_only(rt5677->regmap, false);
-		regcache_cache_bypass(rt5677->regmap, true);
-
+		/* Don't turn off the DSP while handling irqs */
+		mutex_lock(&rt5677->irq_lock);
+		/* Set DSP CPU to Stop */
 		regmap_update_bits(rt5677->regmap, RT5677_PWR_DSP1, 0x1, 0x1);
-		rt5677_set_dsp_mode(codec, false);
+
+		rt5677_set_dsp_mode(rt5677, false);
 		regmap_write(rt5677->regmap, RT5677_PWR_DSP1, 0x0001);
 
-		regmap_write(rt5677->regmap, RT5677_RESET, 0x10ec);
+		/* Disable and clear VAD interrupt */
+		regmap_write(rt5677->regmap, RT5677_VAD_CTRL1, 0x2184);
 
-		regcache_cache_bypass(rt5677->regmap, false);
-		regcache_mark_dirty(rt5677->regmap);
-		regcache_sync(rt5677->regmap);
+		/* Set GPIO1 pin back to be IRQ output for jack detect */
+		regmap_update_bits(rt5677->regmap, RT5677_GPIO_CTRL1,
+			RT5677_GPIO1_PIN_MASK, RT5677_GPIO1_PIN_IRQ);
+		mutex_unlock(&rt5677->irq_lock);
 	}
-
-	return 0;
 }
 
 static const DECLARE_TLV_DB_SCALE(out_vol_tlv, -4650, 150, 0);
@@ -787,8 +983,8 @@
 static int rt5677_dsp_vad_get(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct rt5677_priv *rt5677 = snd_soc_component_get_drvdata(component);
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
 	ucontrol->value.integer.value[0] = rt5677->dsp_vad_en;
 
@@ -798,15 +994,8 @@
 static int rt5677_dsp_vad_put(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct rt5677_priv *rt5677 = snd_soc_component_get_drvdata(component);
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	rt5677->dsp_vad_en = !!ucontrol->value.integer.value[0];
-
-	if (codec->dapm.bias_level == SND_SOC_BIAS_OFF)
-		rt5677_set_dsp_vad(codec, rt5677->dsp_vad_en);
-
+	struct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);
+	rt5677_set_dsp_vad(codec, !!ucontrol->value.integer.value[0]);
 	return 0;
 }
 
@@ -821,13 +1010,13 @@
 
 	/* DAC Digital Volume */
 	SOC_DOUBLE_TLV("DAC1 Playback Volume", RT5677_DAC1_DIG_VOL,
-		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 87, 0, dac_vol_tlv),
+		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 127, 0, dac_vol_tlv),
 	SOC_DOUBLE_TLV("DAC2 Playback Volume", RT5677_DAC2_DIG_VOL,
-		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 87, 0, dac_vol_tlv),
+		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 127, 0, dac_vol_tlv),
 	SOC_DOUBLE_TLV("DAC3 Playback Volume", RT5677_DAC3_DIG_VOL,
-		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 87, 0, dac_vol_tlv),
+		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 127, 0, dac_vol_tlv),
 	SOC_DOUBLE_TLV("DAC4 Playback Volume", RT5677_DAC4_DIG_VOL,
-		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 87, 0, dac_vol_tlv),
+		RT5677_L_VOL_SFT, RT5677_R_VOL_SFT, 127, 0, dac_vol_tlv),
 
 	/* IN1/IN2 Control */
 	SOC_SINGLE_TLV("IN1 Boost", RT5677_IN1, RT5677_BST_SFT1, 8, 0, bst_tlv),
@@ -882,6 +1071,7 @@
 		RT5677_MONO_ADC_L_BST_SFT, RT5677_MONO_ADC_R_BST_SFT, 3, 0,
 		adc_bst_tlv),
 
+	/* TDM Control */
 	SOC_SINGLE_EXT("DSP VAD Switch", SND_SOC_NOPM, 0, 1, 0,
 		rt5677_dsp_vad_get, rt5677_dsp_vad_put),
 };
@@ -2086,14 +2276,10 @@
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
 	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		regmap_update_bits(rt5677->regmap, RT5677_PLL1_CTRL2, 0x2, 0x2);
-		break;
-
 	case SND_SOC_DAPM_POST_PMU:
+		regmap_update_bits(rt5677->regmap, RT5677_PLL1_CTRL2, 0x2, 0x2);
 		regmap_update_bits(rt5677->regmap, RT5677_PLL1_CTRL2, 0x2, 0x0);
 		break;
-
 	default:
 		return 0;
 	}
@@ -2108,14 +2294,10 @@
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
 	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		regmap_update_bits(rt5677->regmap, RT5677_PLL2_CTRL2, 0x2, 0x2);
-		break;
-
 	case SND_SOC_DAPM_POST_PMU:
+		regmap_update_bits(rt5677->regmap, RT5677_PLL2_CTRL2, 0x2, 0x2);
 		regmap_update_bits(rt5677->regmap, RT5677_PLL2_CTRL2, 0x2, 0x0);
 		break;
-
 	default:
 		return 0;
 	}
@@ -2223,11 +2405,9 @@
 
 static const struct snd_soc_dapm_widget rt5677_dapm_widgets[] = {
 	SND_SOC_DAPM_SUPPLY("PLL1", RT5677_PWR_ANLG2, RT5677_PWR_PLL1_BIT,
-		0, rt5677_set_pll1_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
+		0, rt5677_set_pll1_event, SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_SUPPLY("PLL2", RT5677_PWR_ANLG2, RT5677_PWR_PLL2_BIT,
-		0, rt5677_set_pll2_event, SND_SOC_DAPM_PRE_PMU |
-		SND_SOC_DAPM_POST_PMU),
+		0, rt5677_set_pll2_event, SND_SOC_DAPM_POST_PMU),
 
 	/* Input Side */
 	/* micbias */
@@ -2594,6 +2774,7 @@
 	SND_SOC_DAPM_AIF_OUT("AIF4TX", "AIF4 Capture", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_IN("SLBRX", "SLIMBus Playback", 0, SND_SOC_NOPM, 0, 0),
 	SND_SOC_DAPM_AIF_OUT("SLBTX", "SLIMBus Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("DSPTX", "DSP Buffer", 0, SND_SOC_NOPM, 0, 0),
 
 	/* Sidetone Mux */
 	SND_SOC_DAPM_MUX("Sidetone Mux", SND_SOC_NOPM, 0, 0,
@@ -3096,11 +3277,24 @@
 	{ "SLBTX", NULL, "SLB ADC3 Mux" },
 	{ "SLBTX", NULL, "SLB ADC4 Mux" },
 
+	{ "DSPTX", NULL, "IB01 Bypass Mux" },
+
 	{ "IB01 Mux", "IF1 DAC 01", "IF1 DAC01" },
 	{ "IB01 Mux", "IF2 DAC 01", "IF2 DAC01" },
 	{ "IB01 Mux", "SLB DAC 01", "SLB DAC01" },
 	{ "IB01 Mux", "STO1 ADC MIX", "Stereo1 ADC MIX" },
-	{ "IB01 Mux", "VAD ADC/DAC1 FS", "DAC1 FS" },
+	/* The IB01 Mux controls the source for InBound0 and InBound1.
+	 * When the mux option "VAD ADC/DAC1 FS" is selected, "VAD ADC" goes to
+	 * InBound0 and "DAC1 FS" goes to InBound1. "VAD ADC" is used for
+	 * hotwording. "DAC1 FS" is not used currently.
+	 *
+	 * Creating a common widget node for "VAD ADC" + "DAC1 FS" and
+	 * connecting the common widget to IB01 Mux causes the issue where
+	 * there is an active path going from system playback -> "DAC1 FS" ->
+	 * IB01 Mux -> DSP Buffer -> hotword stream. This wrong path confuses
+	 * DAPM. Therefore "DAC1 FS" is ignored for now.
+	 */
+	{ "IB01 Mux", "VAD ADC/DAC1 FS", "VAD ADC Mux" },
 
 	{ "IB01 Bypass Mux", "Bypass", "IB01 Mux" },
 	{ "IB01 Bypass Mux", "Pass SRC", "IB01 Mux" },
@@ -3936,59 +4130,6 @@
 	return 0;
 }
 
-static int rt5677_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
-			unsigned int rx_mask, int slots, int slot_width)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	unsigned int val = 0;
-
-	if (rx_mask || tx_mask)
-		val |= (1 << 12);
-
-	switch (slots) {
-	case 4:
-		val |= (1 << 10);
-		break;
-	case 6:
-		val |= (2 << 10);
-		break;
-	case 8:
-		val |= (3 << 10);
-		break;
-	case 2:
-	default:
-		break;
-	}
-
-	switch (slot_width) {
-	case 20:
-		val |= (1 << 8);
-		break;
-	case 24:
-		val |= (2 << 8);
-		break;
-	case 32:
-		val |= (3 << 8);
-		break;
-	case 16:
-	default:
-		break;
-	}
-
-	switch (dai->id) {
-	case RT5677_AIF1:
-		snd_soc_update_bits(codec, RT5677_TDM1_CTRL1, 0x1f00, val);
-		break;
-	case RT5677_AIF2:
-		snd_soc_update_bits(codec, RT5677_TDM2_CTRL1, 0x1f00, val);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
 static int rt5677_set_bias_level(struct snd_soc_codec *codec,
 			enum snd_soc_bias_level level)
 {
@@ -4000,8 +4141,6 @@
 
 	case SND_SOC_BIAS_PREPARE:
 		if (codec->dapm.bias_level == SND_SOC_BIAS_STANDBY) {
-			rt5677_set_dsp_vad(codec, false);
-
 			regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG1,
 				RT5677_LDO1_SEL_MASK | RT5677_LDO2_SEL_MASK,
 				0x0055);
@@ -4030,12 +4169,11 @@
 		regmap_write(rt5677->regmap, RT5677_PWR_DIG1, 0x0000);
 		regmap_write(rt5677->regmap, RT5677_PWR_DIG2, 0x0000);
 		regmap_write(rt5677->regmap, RT5677_PWR_ANLG1, 0x0022);
-		regmap_write(rt5677->regmap, RT5677_PWR_ANLG2, 0x0000);
+		regmap_update_bits(rt5677->regmap, RT5677_PWR_ANLG2,
+			RT5677_PWR_CORE, 0);
 		regmap_update_bits(rt5677->regmap,
 			RT5677_PR_BASE + RT5677_BIAS_CUR4, 0x0f00, 0x0000);
 
-		if (rt5677->dsp_vad_en)
-			rt5677_set_dsp_vad(codec, true);
 		break;
 
 	default:
@@ -4166,7 +4304,6 @@
 static int rt5677_to_irq(struct gpio_chip *chip, unsigned offset)
 {
 	struct rt5677_priv *rt5677 = gpio_to_rt5677(chip);
-	struct regmap_irq_chip_data *data = rt5677->irq_data;
 	int irq;
 
 	if (offset >= RT5677_GPIO1 && offset <= RT5677_GPIO3) {
@@ -4200,7 +4337,7 @@
 		}
 	}
 
-	return regmap_irq_get_virq(data, irq);
+	return irq_create_mapping(rt5677->domain, irq);
 }
 
 static struct gpio_chip rt5677_template_chip = {
@@ -4250,6 +4387,15 @@
 }
 #endif
 
+int rt5677_poll_gpios(struct snd_soc_codec *codec)
+{
+	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
+
+	schedule_delayed_work(&rt5677->irq_work, 50);
+	return 0;
+}
+EXPORT_SYMBOL(rt5677_poll_gpios);
+
 static int rt5677_probe(struct snd_soc_codec *codec)
 {
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
@@ -4269,37 +4415,13 @@
 
 	rt5677_set_bias_level(codec, SND_SOC_BIAS_OFF);
 
-	regmap_write(rt5677->regmap, RT5677_DIG_MISC, 0x0020);
+	regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC,
+			~RT5677_IRQ_DEBOUNCE_SEL_MASK, 0x0020);
 	regmap_write(rt5677->regmap, RT5677_PWR_DSP2, 0x0c00);
 
 	for (i = 0; i < RT5677_GPIO_NUM; i++)
 		rt5677_gpio_config(rt5677, i, rt5677->pdata.gpio_config[i]);
 
-	if (rt5677->irq_data) {
-		regmap_update_bits(rt5677->regmap, RT5677_GPIO_CTRL1, 0x8000,
-			0x8000);
-		regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC, 0x0018,
-			0x0008);
-
-		if (rt5677->pdata.jd1_gpio)
-			regmap_update_bits(rt5677->regmap, RT5677_JD_CTRL1,
-				RT5677_SEL_GPIO_JD1_MASK,
-				rt5677->pdata.jd1_gpio <<
-				RT5677_SEL_GPIO_JD1_SFT);
-
-		if (rt5677->pdata.jd2_gpio)
-			regmap_update_bits(rt5677->regmap, RT5677_JD_CTRL1,
-				RT5677_SEL_GPIO_JD2_MASK,
-				rt5677->pdata.jd2_gpio <<
-				RT5677_SEL_GPIO_JD2_SFT);
-
-		if (rt5677->pdata.jd3_gpio)
-			regmap_update_bits(rt5677->regmap, RT5677_JD_CTRL1,
-				RT5677_SEL_GPIO_JD3_MASK,
-				rt5677->pdata.jd3_gpio <<
-				RT5677_SEL_GPIO_JD3_SFT);
-	}
-
 	mutex_init(&rt5677->dsp_cmd_lock);
 	mutex_init(&rt5677->dsp_pri_lock);
 
@@ -4310,6 +4432,8 @@
 {
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
 
+	cancel_delayed_work_sync(&rt5677->dsp_work);
+
 	regmap_write(rt5677->regmap, RT5677_RESET, 0x10ec);
 	if (gpio_is_valid(rt5677->pow_ldo2))
 		gpio_set_value_cansleep(rt5677->pow_ldo2, 0);
@@ -4408,7 +4532,6 @@
 	.set_fmt = rt5677_set_dai_fmt,
 	.set_sysclk = rt5677_set_dai_sysclk,
 	.set_pll = rt5677_set_dai_pll,
-	.set_tdm_slot = rt5677_set_tdm_slot,
 };
 
 static struct snd_soc_dai_driver rt5677_dai[] = {
@@ -4507,6 +4630,17 @@
 		},
 		.ops = &rt5677_aif_dai_ops,
 	},
+	{
+		.name = "rt5677-dspbuffer",
+		.id = RT5677_DSPBUFF,
+		.capture = {
+			.stream_name = "DSP Buffer",
+			.channels_min = 1,
+			.channels_max = 1,
+			.rates = SNDRV_PCM_RATE_16000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,
+		},
+	},
 };
 
 static struct snd_soc_codec_driver soc_codec_dev_rt5677 = {
@@ -4565,6 +4699,9 @@
 
 static int rt5677_parse_dt(struct rt5677_priv *rt5677, struct device_node *np)
 {
+	of_property_read_u32(np, "realtek,micbias1", &rt5677->pdata.micbias1);
+	rt5677->pdata.internal_dacref_en = of_property_read_bool(np,
+					"realtek,internal-dacref-en");
 	rt5677->pdata.in1_diff = of_property_read_bool(np,
 					"realtek,in1-differential");
 	rt5677->pdata.in2_diff = of_property_read_bool(np,
@@ -4575,6 +4712,10 @@
 					"realtek,lout2-differential");
 	rt5677->pdata.lout3_diff = of_property_read_bool(np,
 					"realtek,lout3-differential");
+	of_property_read_u32(np, "realtek,pdm_clk_div",
+					&rt5677->pdata.pdm_clk_div);
+	rt5677->pdata.asrc_en = of_property_read_bool(np,
+					"realtek,asrc-en");
 
 	rt5677->pow_ldo2 = of_get_named_gpio(np,
 					"realtek,pow-ldo2-gpio", 0);
@@ -4599,65 +4740,293 @@
 	return 0;
 }
 
-static struct regmap_irq rt5677_irqs[] = {
+#ifdef CONFIG_ACPI
+
+static unsigned long long rt5677_parse_acpi_entry(struct device *dev,
+		acpi_string name)
+{
+	acpi_handle handle = ACPI_HANDLE(dev);
+	unsigned long long val;
+	acpi_status status;
+
+	status = acpi_evaluate_integer(handle, name, NULL, &val);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Failed to parse ACPI entry %s, default to 0: %d\n",
+				name, status);
+		return 0;
+	}
+	return val;
+}
+
+static void rt5677_parse_acpi(struct rt5677_priv *rt5677, struct device *dev)
+{
+	rt5677->pdata.micbias1 = (enum rt5677_micbias)
+		rt5677_parse_acpi_entry(dev, "MB1");
+	rt5677->pdata.internal_dacref_en = (bool)
+		rt5677_parse_acpi_entry(dev, "DACR");
+	rt5677->pdata.dmic2_clk_pin = (enum rt5677_dmic2_clk)
+		rt5677_parse_acpi_entry(dev, "DCLK");
+	rt5677->pdata.pdm_clk_div = (enum rt5677_pdm_clk_div)
+		rt5677_parse_acpi_entry(dev, "PCLK");
+	rt5677->pdata.in1_diff = (bool)rt5677_parse_acpi_entry(dev, "IN1");
+	rt5677->pdata.in2_diff = (bool)rt5677_parse_acpi_entry(dev, "IN2");
+	rt5677->pdata.lout1_diff = (bool)rt5677_parse_acpi_entry(dev, "OUT1");
+	rt5677->pdata.lout2_diff = (bool)rt5677_parse_acpi_entry(dev, "OUT2");
+	rt5677->pdata.lout3_diff = (bool)rt5677_parse_acpi_entry(dev, "OUT3");
+	rt5677->pdata.asrc_en = (bool)rt5677_parse_acpi_entry(dev, "ASRC");
+	rt5677->pdata.jd1_gpio = rt5677_parse_acpi_entry(dev, "JD1");
+	rt5677->pdata.jd2_gpio = rt5677_parse_acpi_entry(dev, "JD2");
+	rt5677->pdata.jd3_gpio = rt5677_parse_acpi_entry(dev, "JD3");
+}
+#else
+static void rt5677_parse_acpi(struct rt5677_priv *rt5677, struct device *dev)
+{
+}
+#endif
+
+struct rt5677_irq_desc {
+	unsigned int enable_mask;
+	unsigned int status_mask;
+	unsigned int polarity_mask;
+};
+
+static const struct rt5677_irq_desc rt5677_irq_descs[] = {
 	[RT5677_IRQ_JD1] = {
-		.reg_offset = 0,
-		.mask = RT5677_EN_IRQ_GPIO_JD1,
+		.enable_mask = RT5677_EN_IRQ_GPIO_JD1,
+		.status_mask = RT5677_STA_GPIO_JD1,
+		.polarity_mask = RT5677_INV_GPIO_JD1,
 	},
 	[RT5677_IRQ_JD2] = {
-		.reg_offset = 0,
-		.mask = RT5677_EN_IRQ_GPIO_JD2,
+		.enable_mask = RT5677_EN_IRQ_GPIO_JD2,
+		.status_mask = RT5677_STA_GPIO_JD2,
+		.polarity_mask = RT5677_INV_GPIO_JD2,
 	},
 	[RT5677_IRQ_JD3] = {
-		.reg_offset = 0,
-		.mask = RT5677_EN_IRQ_GPIO_JD3,
+		.enable_mask = RT5677_EN_IRQ_GPIO_JD3,
+		.status_mask = RT5677_STA_GPIO_JD3,
+		.polarity_mask = RT5677_INV_GPIO_JD3,
 	},
 };
 
-static struct regmap_irq_chip rt5677_irq_chip = {
-	.name = "rt5677",
-	.irqs = rt5677_irqs,
-	.num_irqs = ARRAY_SIZE(rt5677_irqs),
-
-	.num_regs = 1,
-	.status_base = RT5677_IRQ_CTRL1,
-	.mask_base = RT5677_IRQ_CTRL1,
-	.mask_invert = 1,
-};
+bool rt5677_check_hotword(struct rt5677_priv *rt5677)
+{
+	int reg_gpio;
+	if (!rt5677->is_dsp_mode)
+		return false;
 
-static int rt5677_init_irq(struct i2c_client *i2c)
+	if (regmap_read(rt5677->regmap, RT5677_GPIO_CTRL1, &reg_gpio))
+		return false;
+
+	/* Firmware sets GPIO1 pin to be GPIO1 after hotword is detected */
+	if ((reg_gpio & RT5677_GPIO1_PIN_MASK) == RT5677_GPIO1_PIN_IRQ)
+		return false;
+
+	/* Set GPIO1 pin back to be IRQ output for jack detect */
+	regmap_update_bits(rt5677->regmap, RT5677_GPIO_CTRL1,
+			RT5677_GPIO1_PIN_MASK, RT5677_GPIO1_PIN_IRQ);
+
+	rt5677_spi_hotword_detected();
+	return true;
+}
+
+static irqreturn_t rt5677_irq(int unused, void *data)
 {
-	int ret;
-	struct rt5677_priv *rt5677 = i2c_get_clientdata(i2c);
+	struct rt5677_priv *rt5677 = data;
+	struct snd_soc_codec *codec = rt5677->codec;
+	int ret = 0, i, loop, reg_irq, virq;
+	bool irq_fired;
 
-	if (!rt5677->pdata.jd1_gpio &&
-		!rt5677->pdata.jd2_gpio &&
-		!rt5677->pdata.jd3_gpio)
-		return 0;
+	mutex_lock(&rt5677->irq_lock);
+	dev_info(codec->dev, "rt5677_irq\n");
+	/*
+	 * Loop to handle interrupts until the last i2c read shows no pending
+	 * irqs. The interrupt line is shared by multiple interrupt sources.
+	 * After the regmap_read() below, a new interrupt source line may
+	 * become high before the regmap_write() finishes, so there isn't a
+	 * rising edge on the shared interrupt line for the new interrupt. Thus,
+	 * the loop is needed to avoid missing irqs.
+	 *
+	 * A safeguard of 20 loops is used to avoid hanging in the irq hander
+	 * if there is something wrong with the interrupt status update. The
+	 * interrupt sources here are audio jack plug/unplug events which
+	 * shouldn't happen at a high frequency for a long period of time.
+	 * Empirically, more than 3 loops have never been seen.
+	 */
+	for (loop = 0; loop < 20; loop++) {
+		/* Read interrupt status */
+		ret = regmap_read(rt5677->regmap, RT5677_IRQ_CTRL1, &reg_irq);
+		if (ret)
+			break;
+		/*
+		 * Clear the interrupt by flipping the polarity of the
+		 * interrupt source lines that just fired
+		 */
+		irq_fired = false;
+		for (i = 0; i < RT5677_IRQ_NUM; i++) {
+			if (reg_irq & rt5677_irq_descs[i].status_mask) {
+				reg_irq ^= rt5677_irq_descs[i].polarity_mask;
+				irq_fired = true;
+			}
+		}
 
-	if (!i2c->irq) {
-		dev_err(&i2c->dev, "No interrupt specified\n");
-		return -EINVAL;
-	}
+		/* Exit the loop only when we know for sure that GPIO1 pin
+		 * was low at some point since irq_lock was acquired. Any event
+		 * after that point creates a rising edge that triggers another
+		 * call to rt5677_irq().
+		 */
+		if (!irq_fired && !rt5677_check_hotword(rt5677))
+			break;
 
-	ret = regmap_add_irq_chip(rt5677->regmap, i2c->irq,
-		IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT, 0,
-		&rt5677_irq_chip, &rt5677->irq_data);
+		ret = regmap_write(rt5677->regmap, RT5677_IRQ_CTRL1, reg_irq);
+		if (ret)
+			break;
 
-	if (ret != 0) {
-		dev_err(&i2c->dev, "Failed to register IRQ chip: %d\n", ret);
-		return ret;
+		/* Process interrupts */
+		for (i = 0; i < RT5677_IRQ_NUM; i++) {
+			if ((reg_irq & rt5677_irq_descs[i].enable_mask) &&
+			    (reg_irq & rt5677_irq_descs[i].status_mask)) {
+				virq = irq_find_mapping(rt5677->domain, i);
+				if (virq)
+					handle_nested_irq(virq);
+			}
+		}
 	}
+	WARN_ON_ONCE(loop == 20);
+	mutex_unlock(&rt5677->irq_lock);
+
+	return IRQ_HANDLED;
+}
+static void rt5677_irq_work(struct work_struct *work)
+{
+	struct rt5677_priv *rt5677 =
+		container_of(work, struct rt5677_priv, irq_work.work);
+
+	rt5677_irq(0, rt5677);
+}
+
+static void rt5677_irq_bus_lock(struct irq_data *data)
+{
+	struct rt5677_priv *rt5677 = irq_data_get_irq_chip_data(data);
+	mutex_lock(&rt5677->irq_lock);
+}
+
+static void rt5677_irq_bus_sync_unlock(struct irq_data *data)
+{
+	struct rt5677_priv *rt5677 = irq_data_get_irq_chip_data(data);
+
+	regmap_update_bits(rt5677->regmap, RT5677_IRQ_CTRL1,
+			RT5677_EN_IRQ_GPIO_JD1 | RT5677_EN_IRQ_GPIO_JD2 |
+			RT5677_EN_IRQ_GPIO_JD3, rt5677->irq_en);
+	mutex_unlock(&rt5677->irq_lock);
+}
+
+static void rt5677_irq_enable(struct irq_data *data)
+{
+	struct rt5677_priv *rt5677 = irq_data_get_irq_chip_data(data);
+	rt5677->irq_en |= rt5677_irq_descs[data->hwirq].enable_mask;
+}
+
+static void rt5677_irq_disable(struct irq_data *data)
+{
+	struct rt5677_priv *rt5677 = irq_data_get_irq_chip_data(data);
+	rt5677->irq_en &= ~rt5677_irq_descs[data->hwirq].enable_mask;
+}
+
+static struct irq_chip rt5677_irq_chip = {
+	.name			= "rt5677_irq_chip",
+	.irq_bus_lock		= rt5677_irq_bus_lock,
+	.irq_bus_sync_unlock	= rt5677_irq_bus_sync_unlock,
+	.irq_disable		= rt5677_irq_disable,
+	.irq_enable		= rt5677_irq_enable,
+};
 
+static int rt5677_irq_map(struct irq_domain *h, unsigned int virq,
+			  irq_hw_number_t hw)
+{
+	struct rt5677_priv *rt5677 = h->host_data;
+
+	irq_set_chip_data(virq, rt5677);
+	irq_set_chip(virq, &rt5677_irq_chip);
+	irq_set_nested_thread(virq, 1);
+
+	/* ARM needs us to explicitly flag the IRQ as valid
+	 * and will set them noprobe when we do so. */
+#ifdef CONFIG_ARM
+	set_irq_flags(virq, IRQF_VALID);
+#else
+	irq_set_noprobe(virq);
+#endif
 	return 0;
 }
 
-static void rt5677_free_irq(struct i2c_client *i2c)
+static struct irq_domain_ops rt5677_domain_ops = {
+	.map	= rt5677_irq_map,
+	.xlate	= irq_domain_xlate_twocell,
+};
+
+static void rt5677_irq_init(struct i2c_client *i2c)
 {
 	struct rt5677_priv *rt5677 = i2c_get_clientdata(i2c);
+	int ret;
+	unsigned int jd_mask = 0, jd_val = 0;
 
-	if (rt5677->irq_data)
-		regmap_del_irq_chip(i2c->irq, rt5677->irq_data);
+	/* No irq has been assigned to the codec */
+	if (!i2c->irq)
+		return;
+
+	mutex_init(&rt5677->irq_lock);
+	INIT_DELAYED_WORK(&rt5677->irq_work, rt5677_irq_work);
+
+	/*
+	 * Select RC as the debounce clock so that GPIO works even when
+	 * MCLK is gated which happens when there is no audio stream
+	 * (SND_SOC_BIAS_OFF).
+	 */
+	regmap_update_bits(rt5677->regmap, RT5677_DIG_MISC,
+			RT5677_IRQ_DEBOUNCE_SEL_MASK,
+			RT5677_IRQ_DEBOUNCE_SEL_RC);
+	/* Enable auto power on RC when GPIO states are changed */
+	regmap_update_bits(rt5677->regmap, RT5677_GEN_CTRL1, 0xff, 0xff);
+
+	/* Select and enable jack detection sources per platform data */
+	if (rt5677->pdata.jd1_gpio) {
+		jd_mask	|= RT5677_SEL_GPIO_JD1_MASK;
+		jd_val	|= rt5677->pdata.jd1_gpio << RT5677_SEL_GPIO_JD1_SFT;
+	}
+	if (rt5677->pdata.jd2_gpio) {
+		jd_mask	|= RT5677_SEL_GPIO_JD2_MASK;
+		jd_val	|= rt5677->pdata.jd2_gpio << RT5677_SEL_GPIO_JD2_SFT;
+	}
+	if (rt5677->pdata.jd3_gpio) {
+		jd_mask	|= RT5677_SEL_GPIO_JD3_MASK;
+		jd_val	|= rt5677->pdata.jd3_gpio << RT5677_SEL_GPIO_JD3_SFT;
+	}
+	regmap_update_bits(rt5677->regmap, RT5677_JD_CTRL1, jd_mask, jd_val);
+
+	/* Set GPIO1 pin to be IRQ output */
+	regmap_update_bits(rt5677->regmap, RT5677_GPIO_CTRL1,
+			RT5677_GPIO1_PIN_MASK, RT5677_GPIO1_PIN_IRQ);
+
+	/* Ready to listen for interrupts */
+	rt5677->domain = irq_domain_add_linear(i2c->dev.of_node,
+			RT5677_IRQ_NUM, &rt5677_domain_ops, rt5677);
+	if (!rt5677->domain) {
+		dev_err(&i2c->dev, "Failed to create IRQ domain\n");
+		return;
+	}
+	ret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL, rt5677_irq,
+			IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+			"rt5677", rt5677);
+	if (ret) {
+		dev_err(&i2c->dev, "Failed to request IRQ: %d\n", ret);
+		return;
+	}
+}
+
+static void rt5677_irq_exit(struct i2c_client *i2c)
+{
+	struct rt5677_priv *rt5677 = i2c_get_clientdata(i2c);
+	cancel_delayed_work_sync(&rt5677->irq_work);
 }
 
 static int rt5677_i2c_probe(struct i2c_client *i2c,
@@ -4673,11 +5042,14 @@
 	if (rt5677 == NULL)
 		return -ENOMEM;
 
+	INIT_DELAYED_WORK(&rt5677->dsp_work, rt5677_dsp_work);
+	rt5677->set_dsp_vad = rt5677_set_dsp_vad;
 	i2c_set_clientdata(i2c, rt5677);
 
 	if (pdata)
 		rt5677->pdata = *pdata;
 
+	rt5677->pow_ldo2 = -EINVAL;
 	if (i2c->dev.of_node) {
 		ret = rt5677_parse_dt(rt5677, i2c->dev.of_node);
 		if (ret) {
@@ -4685,8 +5057,8 @@
 				ret);
 			return ret;
 		}
-	} else {
-		rt5677->pow_ldo2 = -EINVAL;
+	} else if (ACPI_HANDLE(&i2c->dev)) {
+		rt5677_parse_acpi(rt5677, &i2c->dev);
 	}
 
 	if (gpio_is_valid(rt5677->pow_ldo2)) {
@@ -4736,6 +5108,18 @@
 	if (ret != 0)
 		dev_warn(&i2c->dev, "Failed to apply regmap patch: %d\n", ret);
 
+	regmap_update_bits(rt5677->regmap, RT5677_MICBIAS,
+			RT5677_MICBIAS1_OUTVOLT_MASK |
+			RT5677_MICBIAS1_CTRL_VDD_MASK,
+			rt5677->pdata.micbias1 << RT5677_MICBIAS1_CTRL_VDD_SFT);
+
+	if (rt5677->pdata.internal_dacref_en) {
+		regmap_update_bits(rt5677->regmap, RT5677_PR_BASE +
+				RT5677_TEST_CTRL1, 1 << 9, 1 << 9);
+		regmap_update_bits(rt5677->regmap, RT5677_PR_BASE +
+				RT5677_SOFT_DEPOP_DAC_CLK_CTRL, 1 << 5, 1 << 5);
+	}
+
 	if (rt5677->pdata.in1_diff)
 		regmap_update_bits(rt5677->regmap, RT5677_IN1,
 					RT5677_IN_DF1, RT5677_IN_DF1);
@@ -4765,8 +5149,30 @@
 					RT5677_GPIO5_DIR_OUT);
 	}
 
+	regmap_update_bits(rt5677->regmap, RT5677_PDM_DATA_CTRL1,
+			RT5677_PDM_DIV_MASK, rt5677->pdata.pdm_clk_div);
+
+	if (rt5677->pdata.asrc_en) {
+		/* Enable I2S1 ASRC Function */
+		regmap_write(rt5677->regmap, RT5677_ASRC_1, 0x0001);
+		/*
+		 * Enable DAC ASRC for Stereo DAC
+		 * Enable DMIC ASRC for Stereo1 ADC
+		 * Enable ADC ASRC for Stereo1
+		 */
+		regmap_write(rt5677->regmap, RT5677_ASRC_2, 0x4820);
+		/* ASRC Clock Source for Stereo DAC = clk_i2s1_asrc */
+		regmap_write(rt5677->regmap, RT5677_ASRC_3, 0x1000);
+		/* ASRC Clock Source for Stereo1 ADC = clk_i2s1_asrc */
+		regmap_write(rt5677->regmap, RT5677_ASRC_5, 0x1000);
+		/* Initial value of ASRC tracking for I2S1 of 48K sample rate
+		and 24M MCLK */
+		regmap_write(rt5677->regmap, RT5677_ASRC_13, 0x126e);
+		regmap_write(rt5677->regmap, RT5677_ASRC_19, 0x0003);
+	}
+
 	rt5677_init_gpio(i2c);
-	rt5677_init_irq(i2c);
+	rt5677_irq_init(i2c);
 
 	return snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5677,
 				      rt5677_dai, ARRAY_SIZE(rt5677_dai));
@@ -4774,17 +5180,27 @@
 
 static int rt5677_i2c_remove(struct i2c_client *i2c)
 {
+	rt5677_irq_exit(i2c);
+
 	snd_soc_unregister_codec(&i2c->dev);
-	rt5677_free_irq(i2c);
 	rt5677_free_gpio(i2c);
 
 	return 0;
 }
 
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id rt5677_acpi_id[] = {
+	{ "RT5677CE", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, rt5677_acpi_id);
+#endif
+
 static struct i2c_driver rt5677_i2c_driver = {
 	.driver = {
 		.name = "rt5677",
 		.owner = THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(rt5677_acpi_id),
 	},
 	.probe = rt5677_i2c_probe,
 	.remove   = rt5677_i2c_remove,
diff -Naur linux-3.19.old/sound/soc/codecs/rt5677.h linux-3.19/sound/soc/codecs/rt5677.h
--- linux-3.19.old/sound/soc/codecs/rt5677.h	2015-03-24 17:38:13.919843635 -0800
+++ linux-3.19/sound/soc/codecs/rt5677.h	2015-03-24 18:28:21.328013360 -0800
@@ -1586,6 +1586,12 @@
 #define RT5677_GPIO6_P_NOR			(0x0 << 0)
 #define RT5677_GPIO6_P_INV			(0x1 << 0)
 
+/* General Control (0xfa) */
+#define RT5677_IRQ_DEBOUNCE_SEL_MASK		(0x3 << 3)
+#define RT5677_IRQ_DEBOUNCE_SEL_MCLK		(0x0 << 3)
+#define RT5677_IRQ_DEBOUNCE_SEL_RC		(0x1 << 3)
+#define RT5677_IRQ_DEBOUNCE_SEL_SLIM		(0x2 << 3)
+
 /* Virtual DSP Mixer Control (0xf7 0xf8 0xf9) */
 #define RT5677_DSP_IB_01_H			(0x1 << 15)
 #define RT5677_DSP_IB_01_H_SFT			15
@@ -1647,6 +1653,7 @@
 	RT5677_AIF4,
 	RT5677_AIF5,
 	RT5677_AIFS,
+	RT5677_DSPBUFF,
 };
 
 enum {
@@ -1663,6 +1670,7 @@
 	RT5677_IRQ_JD1,
 	RT5677_IRQ_JD2,
 	RT5677_IRQ_JD3,
+	RT5677_IRQ_NUM,
 };
 
 struct rt5677_priv {
@@ -1684,10 +1692,20 @@
 #ifdef CONFIG_GPIOLIB
 	struct gpio_chip gpio_chip;
 #endif
-	bool dsp_vad_en;
-	struct regmap_irq_chip_data *irq_data;
+	bool dsp_vad_en; /* DSP VAD enable/disable request */
 	bool is_dsp_mode;
 	bool is_vref_slow;
+	struct delayed_work dsp_work;
+
+	/* Interrupt handling */
+	struct irq_domain *domain;
+	struct mutex irq_lock;
+	unsigned int irq_en;
+	struct delayed_work irq_work;
+
+	int (*set_dsp_vad)(struct snd_soc_codec *codec, bool on);
 };
 
+int rt5677_poll_gpios(struct snd_soc_codec *codec);
+
 #endif /* __RT5677_H__ */
diff -Naur linux-3.19.old/sound/soc/codecs/rt5677-spi.c linux-3.19/sound/soc/codecs/rt5677-spi.c
--- linux-3.19.old/sound/soc/codecs/rt5677-spi.c	2015-03-24 17:38:13.903176969 -0800
+++ linux-3.19/sound/soc/codecs/rt5677-spi.c	2015-03-24 18:28:21.328013360 -0800
@@ -28,57 +28,484 @@
 #include <linux/sysfs.h>
 #include <linux/clk.h>
 #include <linux/firmware.h>
+#include <linux/acpi.h>
 
+#include <sound/soc.h>
+
+#include "rt5677.h"
 #include "rt5677-spi.h"
 
+#define SPI_BURST_LEN		240
+#define SPI_HEADER		5
+#define SPI_READ_FREQ		1000000
+
+#define RT5677_SPI_WRITE_BURST	0x5
+#define RT5677_SPI_READ_BURST	0x4
+#define RT5677_SPI_WRITE_32	0x3
+#define RT5677_SPI_READ_32	0x2
+#define RT5677_SPI_WRITE_16	0x1
+#define RT5677_SPI_READ_16	0x0
+
+#define RT5677_MIC_BUF_ADDR		0x60030000
+#define RT5677_MODEL_ADDR		0x5FFC9800
+#define RT5677_MIC_BUF_BYTES		(0x20000 - sizeof(u32))
+#define RT5677_MIC_BUF_FIRST_READ_SIZE	0x10000
+
 static struct spi_device *g_spi;
+static DEFINE_MUTEX(spi_mutex);
 
-/**
- * rt5677_spi_write - Write data to SPI.
- * @txbuf: Data Buffer for writing.
- * @len: Data length.
- *
- *
- * Returns true for success.
- */
-int rt5677_spi_write(u8 *txbuf, size_t len)
+struct rt5677_dsp {
+	struct device *dev;
+	struct delayed_work copy_work;
+	struct mutex dma_lock;
+	struct snd_pcm_substream *substream;
+	size_t dma_offset;	/* zero-based offset into runtime->dma_area */
+	size_t avail_bytes;	/* number of new bytes since last period */
+	u32 mic_read_offset;	/* zero-based offset into DSP's mic buffer */
+	bool new_hotword;	/* a new hotword is fired */
+};
+
+static const struct snd_pcm_hardware rt5677_spi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min	= PAGE_SIZE,
+	.period_bytes_max	= RT5677_MIC_BUF_BYTES / 2,
+	.periods_min		= 2,
+	.periods_max		= 2,
+	.channels_min		= 1,
+	.channels_max		= 1,
+	.buffer_bytes_max	= RT5677_MIC_BUF_BYTES,
+};
+
+static int rt5677_spi_dai_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
 {
-	int status;
+	return 0;
+}
 
-	status = spi_write(g_spi, txbuf, len);
+static struct snd_soc_dai_ops rt5677_spi_dai_ops = {
+	.hw_params = rt5677_spi_dai_hw_params,
+};
 
-	if (status)
-		dev_err(&g_spi->dev, "rt5677_spi_write error %d\n", status);
+static struct snd_soc_dai_driver rt5677_spi_dai = {
+	/* The DAI name "rt5677-dsp-cpu-dai" is not used. The actual DAI name
+	 * registered with ASoC is the name of the device "spi-RT5677AA:00",
+	 * because we only have one DAI. See snd_soc_register_dais().
+	 */
+	.name = "rt5677-dsp-cpu-dai",
+	.id = 0,
+	.capture = {
+		.stream_name = "DSP Capture",
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = SNDRV_PCM_RATE_16000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &rt5677_spi_dai_ops,
+};
 
-	return status;
+/* PCM for streaming audio from the DSP buffer */
+static int rt5677_spi_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(rtd->codec);
+
+	rt5677->set_dsp_vad(rtd->codec, true);
+	snd_soc_set_runtime_hwparams(substream, &rt5677_spi_pcm_hardware);
+	return 0;
 }
-EXPORT_SYMBOL_GPL(rt5677_spi_write);
 
-/**
- * rt5677_spi_burst_write - Write data to SPI by rt5677 dsp memory address.
- * @addr: Start address.
- * @txbuf: Data Buffer for writng.
- * @len: Data length, it must be a multiple of 8.
- *
+static int rt5677_spi_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(rtd->codec);
+	struct rt5677_dsp *rt5677_dsp =
+			snd_soc_platform_get_drvdata(rtd->platform);
+
+	cancel_delayed_work_sync(&rt5677_dsp->copy_work);
+	rt5677->set_dsp_vad(rtd->codec, false);
+	return 0;
+}
+
+static int rt5677_spi_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_dsp *rt5677_dsp =
+			snd_soc_platform_get_drvdata(rtd->platform);
+	int ret;
+
+	mutex_lock(&rt5677_dsp->dma_lock);
+	ret = snd_pcm_lib_alloc_vmalloc_buffer(substream,
+			params_buffer_bytes(hw_params));
+	rt5677_dsp->substream = substream;
+	mutex_unlock(&rt5677_dsp->dma_lock);
+
+	return ret;
+}
+
+static int rt5677_spi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_dsp *rt5677_dsp =
+			snd_soc_platform_get_drvdata(rtd->platform);
+
+	mutex_lock(&rt5677_dsp->dma_lock);
+	rt5677_dsp->substream = 0;
+	mutex_unlock(&rt5677_dsp->dma_lock);
+
+	return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int rt5677_spi_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_dsp *rt5677_dsp =
+			snd_soc_platform_get_drvdata(rtd->platform);
+
+	rt5677_dsp->dma_offset = 0;
+	rt5677_dsp->avail_bytes = 0;
+	return 0;
+}
+
+static snd_pcm_uframes_t rt5677_spi_pcm_pointer(
+		struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct rt5677_dsp *rt5677_dsp =
+		snd_soc_platform_get_drvdata(rtd->platform);
+
+	return bytes_to_frames(runtime, rt5677_dsp->dma_offset);
+}
+
+static int rt5677_spi_mic_write_offset(u32 *mic_write_offset)
+{
+	int ret;
+	/* Grab the first 4 bytes that hold the write pointer on the
+	 * dsp, and check to make sure that it points somewhere inside the
+	 * buffer.
+	 */
+	ret = rt5677_spi_read(RT5677_MIC_BUF_ADDR, mic_write_offset,
+			sizeof(u32));
+	if (ret)
+		return ret;
+	/* Adjust the offset so that it's zero-based */
+	*mic_write_offset = *mic_write_offset - sizeof(u32);
+	return *mic_write_offset < RT5677_MIC_BUF_BYTES ? 0 : -EFAULT;
+}
+
+/*
+ * Copy a block of audio samples from the DSP mic buffer to the dma_area of
+ * the pcm runtime. The receiving buffer may wrap around.
+ * @begin: start offset of the block to copy, in bytes.
+ * @end:   offset of the first byte after the block to copy, must be greater
+ *         than or equal to begin.
  *
- * Returns true for success.
+ * Return: Zero if successful, or a negative error code on failure.
  */
-int rt5677_spi_burst_write(u32 addr, const struct firmware *fw)
+static int rt5677_spi_append_data(struct rt5677_dsp *rt5677_dsp,
+		u32 begin, u32 end)
 {
-	u8 spi_cmd = RT5677_SPI_CMD_BURST_WRITE;
-	u8 *write_buf;
-	unsigned int i, end, offset = 0;
+	struct snd_pcm_runtime *runtime = rt5677_dsp->substream->runtime;
+	size_t bytes_per_frame = frames_to_bytes(runtime, 1);
+	size_t first_chunk_len, second_chunk_len;
+	int ret;
+
+	if (begin > end || runtime->dma_bytes < 2 * bytes_per_frame) {
+		dev_err(rt5677_dsp->dev,
+			"Invalid copy from (%u, %u), dma_area size %zu\n",
+			begin, end, runtime->dma_bytes);
+		return -EINVAL;
+	}
+
+	/* The block to copy is empty */
+	if (begin == end)
+		return 0;
+
+	/* If the incoming chunk is too big for the receiving buffer, only the
+	 * last "receiving buffer size - one frame" bytes are copied.
+	 */
+	if (end - begin > runtime->dma_bytes - bytes_per_frame)
+		begin = end - (runtime->dma_bytes - bytes_per_frame);
+
+	/* May need to split to two chunks, calculate the size of each */
+	first_chunk_len = end - begin;
+	second_chunk_len = 0;
+	if (rt5677_dsp->dma_offset + first_chunk_len > runtime->dma_bytes) {
+		/* Receiving buffer wrapped around */
+		second_chunk_len = first_chunk_len;
+		first_chunk_len = runtime->dma_bytes - rt5677_dsp->dma_offset;
+		second_chunk_len -= first_chunk_len;
+	}
+
+	/* Copy first chunk */
+	ret = rt5677_spi_read(RT5677_MIC_BUF_ADDR + sizeof(u32) + begin,
+			runtime->dma_area + rt5677_dsp->dma_offset,
+			first_chunk_len);
+	if (ret)
+		return ret;
+	rt5677_dsp->dma_offset += first_chunk_len;
+	if (rt5677_dsp->dma_offset == runtime->dma_bytes)
+		rt5677_dsp->dma_offset = 0;
+
+	/* Copy second chunk */
+	if (second_chunk_len) {
+		ret = rt5677_spi_read(RT5677_MIC_BUF_ADDR + sizeof(u32) +
+				begin + first_chunk_len, runtime->dma_area,
+				second_chunk_len);
+		if (!ret)
+			rt5677_dsp->dma_offset = second_chunk_len;
+	}
+	return ret;
+}
 
-	write_buf = kmalloc(RT5677_SPI_BUF_LEN + 6, GFP_KERNEL);
+/*
+ * A delayed work that streams audio samples from the DSP mic buffer to the
+ * dma_area of the pcm runtime via SPI.
+ */
+static void rt5677_spi_copy_work(struct work_struct *work)
+{
+	struct rt5677_dsp *rt5677_dsp =
+		container_of(work, struct rt5677_dsp, copy_work.work);
+	struct snd_pcm_runtime *runtime;
+	u32 mic_write_offset;
+	size_t bytes_copied, period_bytes;
+	int ret = 0;
+
+	/* Ensure runtime->dma_area buffer does not go away while copying. */
+	mutex_lock(&rt5677_dsp->dma_lock);
+	if (!rt5677_dsp->substream) {
+		dev_err(rt5677_dsp->dev, "No pcm substream\n");
+		goto done;
+	}
 
-	if (write_buf == NULL)
-		return -ENOMEM;
+	runtime = rt5677_dsp->substream->runtime;
 
-	while (offset < fw->size) {
-		if (offset + RT5677_SPI_BUF_LEN <= fw->size)
-			end = RT5677_SPI_BUF_LEN;
+	if (rt5677_spi_mic_write_offset(&mic_write_offset)) {
+		dev_err(rt5677_dsp->dev, "No mic_write_offset\n");
+		goto done;
+	}
+
+	/* If this is the first time that we've asked for streaming data after
+	 * a hotword is fired, we should start reading from the previous 2
+	 * seconds of audio from wherever the mic_write_offset is currently.
+	 */
+	if (rt5677_dsp->new_hotword) {
+		rt5677_dsp->new_hotword = false;
+		/* See if buffer wraparound happens */
+		if (mic_write_offset < RT5677_MIC_BUF_FIRST_READ_SIZE)
+			rt5677_dsp->mic_read_offset = RT5677_MIC_BUF_BYTES -
+					(RT5677_MIC_BUF_FIRST_READ_SIZE -
+					mic_write_offset);
 		else
-			end = fw->size % RT5677_SPI_BUF_LEN;
+			rt5677_dsp->mic_read_offset = mic_write_offset -
+					RT5677_MIC_BUF_FIRST_READ_SIZE;
+	}
+
+	/* Copy all new samples from DSP's mic buffer to dma_area */
+	if (rt5677_dsp->mic_read_offset < mic_write_offset) {
+		/* One chunk in DSP's mic buffer */
+		ret |= rt5677_spi_append_data(rt5677_dsp,
+				rt5677_dsp->mic_read_offset, mic_write_offset);
+		bytes_copied = mic_write_offset - rt5677_dsp->mic_read_offset;
+	} else if (rt5677_dsp->mic_read_offset > mic_write_offset) {
+		/* Wrap around, two chunks in DSP's mic buffer */
+		ret |= rt5677_spi_append_data(rt5677_dsp,
+				rt5677_dsp->mic_read_offset,
+				RT5677_MIC_BUF_BYTES);
+		ret |= rt5677_spi_append_data(rt5677_dsp, 0, mic_write_offset);
+		bytes_copied = RT5677_MIC_BUF_BYTES -
+				rt5677_dsp->mic_read_offset + mic_write_offset;
+	}
+	if (ret) {
+		dev_err(rt5677_dsp->dev, "Copy failed %d\n", ret);
+		goto done;
+	}
+
+	rt5677_dsp->mic_read_offset = mic_write_offset;
+	rt5677_dsp->avail_bytes += bytes_copied;
+	period_bytes = snd_pcm_lib_period_bytes(rt5677_dsp->substream);
+
+	if (rt5677_dsp->avail_bytes >= period_bytes) {
+		snd_pcm_period_elapsed(rt5677_dsp->substream);
+		rt5677_dsp->avail_bytes = 0;
+	}
+	/* TODO benzh: use better delay time based on period_bytes */
+	schedule_delayed_work(&rt5677_dsp->copy_work, msecs_to_jiffies(5));
+done:
+	mutex_unlock(&rt5677_dsp->dma_lock);
+}
+
+struct page *rt5677_spi_pcm_page(struct snd_pcm_substream *substream,
+		unsigned long offset)
+{
+	return snd_pcm_lib_get_vmalloc_page(substream, offset);
+}
+
+static struct snd_pcm_ops rt5677_spi_pcm_ops = {
+	.open		= rt5677_spi_pcm_open,
+	.close		= rt5677_spi_pcm_close,
+	.hw_params	= rt5677_spi_hw_params,
+	.hw_free	= rt5677_spi_hw_free,
+	.prepare	= rt5677_spi_prepare,
+	.pointer	= rt5677_spi_pcm_pointer,
+	.mmap		= snd_pcm_lib_mmap_vmalloc,
+	.page		= rt5677_spi_pcm_page,
+};
+
+static int rt5677_spi_pcm_probe(struct snd_soc_platform *platform)
+{
+	struct rt5677_dsp *rt5677_dsp;
+
+	rt5677_dsp = devm_kzalloc(platform->dev, sizeof(*rt5677_dsp),
+			GFP_KERNEL);
+	rt5677_dsp->dev = &g_spi->dev;
+	mutex_init(&rt5677_dsp->dma_lock);
+	INIT_DELAYED_WORK(&rt5677_dsp->copy_work, rt5677_spi_copy_work);
+
+	snd_soc_platform_set_drvdata(platform, rt5677_dsp);
+	return 0;
+}
+
+static struct snd_soc_platform_driver rt5677_spi_platform = {
+	.probe = rt5677_spi_pcm_probe,
+	.ops = &rt5677_spi_pcm_ops,
+};
+
+static const struct snd_soc_component_driver rt5677_spi_dai_component = {
+	.name		= "rt5677-spi-dai",
+};
+
+/* Read DSP memory using SPI. Addr and len have to be multiples of 16-bits. */
+int rt5677_spi_read(u32 addr, void *rxbuf, size_t len)
+{
+	unsigned int i, end, offset = 0;
+	int status = 0;
+	struct spi_transfer t[2];
+	struct spi_message m;
+	u8 *rx_buf;
+	u8 buf[SPI_BURST_LEN + SPI_HEADER + 4];
+	u8 spi_cmd;
+	u8 *rx_data = rxbuf;
+
+	if (!g_spi)
+		return -ENODEV;
+
+	rx_buf = buf + SPI_HEADER + 4;
+	memset(t, 0, sizeof(t));
+	t[0].tx_buf = buf;
+	t[0].len = SPI_HEADER + 4;
+	t[0].speed_hz = SPI_READ_FREQ;
+	t[1].rx_buf = rx_buf;
+	t[1].speed_hz = SPI_READ_FREQ;
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+
+	while (offset < len) {
+		/* TODO benzh: Clean up the read length selection logic */
+		switch (min(len - offset, (size_t)(addr + offset) & 0x7)) {
+		case 4:
+			spi_cmd = RT5677_SPI_READ_32;
+			end = 4;
+			break;
+		case 2:
+		case 6:
+			spi_cmd = RT5677_SPI_READ_16;
+			end = 2;
+			break;
+		case 0:
+			if (offset + SPI_BURST_LEN <= len) {
+				spi_cmd = RT5677_SPI_READ_BURST;
+				end = SPI_BURST_LEN;
+				break;
+			} else if (offset + 4 <= len) {
+				spi_cmd = RT5677_SPI_READ_32;
+				end = 4;
+				break;
+			} else if (offset + 2 <= len) {
+				spi_cmd = RT5677_SPI_READ_16;
+				end = 2;
+				break;
+			}
+			/* Fall through to default error case */
+		default:
+			pr_err("Bad section alignment\n");
+			return -EACCES;
+		}
+
+		buf[0] = spi_cmd;
+		buf[1] = ((addr + offset) & 0xff000000) >> 24;
+		buf[2] = ((addr + offset) & 0x00ff0000) >> 16;
+		buf[3] = ((addr + offset) & 0x0000ff00) >> 8;
+		buf[4] = ((addr + offset) & 0x000000ff) >> 0;
+
+		t[1].len = end;
+
+		mutex_lock(&spi_mutex);
+		status |= spi_sync(g_spi, &m);
+		mutex_unlock(&spi_mutex);
+
+		if (spi_cmd == RT5677_SPI_READ_BURST) {
+			for (i = 0; i < end; i += 8) {
+				rx_data[offset + i + 0] = rx_buf[i + 7];
+				rx_data[offset + i + 1] = rx_buf[i + 6];
+				rx_data[offset + i + 2] = rx_buf[i + 5];
+				rx_data[offset + i + 3] = rx_buf[i + 4];
+				rx_data[offset + i + 4] = rx_buf[i + 3];
+				rx_data[offset + i + 5] = rx_buf[i + 2];
+				rx_data[offset + i + 6] = rx_buf[i + 1];
+				rx_data[offset + i + 7] = rx_buf[i + 0];
+			}
+		} else {
+			for (i = 0; i < end; i++)
+				rx_data[offset + i] = rx_buf[end - i - 1];
+		}
+
+		offset += end;
+	}
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(rt5677_spi_read);
+
+int rt5677_spi_write(u32 addr, const u8 *txbuf, size_t len)
+{
+	unsigned int i, end, offset = 0;
+	int status = 0;
+	u8 write_buf[SPI_BURST_LEN + SPI_HEADER + 1];
+	u8 spi_cmd;
+
+	if (!g_spi)
+		return -ENODEV;
+
+	while (offset < len) {
+		switch ((addr + offset) & 0x7) {
+		case 4:
+			spi_cmd = RT5677_SPI_WRITE_32;
+			end = 4;
+			break;
+		case 2:
+		case 6:
+			spi_cmd = RT5677_SPI_WRITE_16;
+			end = 2;
+			break;
+		case 0:
+			spi_cmd = RT5677_SPI_WRITE_BURST;
+			if (offset + SPI_BURST_LEN <= len)
+				end = SPI_BURST_LEN;
+			else {
+				end = len - offset;
+				end = (((end - 1) >> 3) + 1) << 3;
+			}
+			break;
+		default:
+			pr_err("Bad section alignment\n");
+			return -EACCES;
+		}
 
 		write_buf[0] = spi_cmd;
 		write_buf[1] = ((addr + offset) & 0xff000000) >> 24;
@@ -86,42 +513,116 @@
 		write_buf[3] = ((addr + offset) & 0x0000ff00) >> 8;
 		write_buf[4] = ((addr + offset) & 0x000000ff) >> 0;
 
-		for (i = 0; i < end; i += 8) {
-			write_buf[i + 12] = fw->data[offset + i + 0];
-			write_buf[i + 11] = fw->data[offset + i + 1];
-			write_buf[i + 10] = fw->data[offset + i + 2];
-			write_buf[i +  9] = fw->data[offset + i + 3];
-			write_buf[i +  8] = fw->data[offset + i + 4];
-			write_buf[i +  7] = fw->data[offset + i + 5];
-			write_buf[i +  6] = fw->data[offset + i + 6];
-			write_buf[i +  5] = fw->data[offset + i + 7];
+		if (spi_cmd == RT5677_SPI_WRITE_BURST) {
+			for (i = 0; i < end; i += 8) {
+				write_buf[i + 12] = txbuf[offset + i + 0];
+				write_buf[i + 11] = txbuf[offset + i + 1];
+				write_buf[i + 10] = txbuf[offset + i + 2];
+				write_buf[i +  9] = txbuf[offset + i + 3];
+				write_buf[i +  8] = txbuf[offset + i + 4];
+				write_buf[i +  7] = txbuf[offset + i + 5];
+				write_buf[i +  6] = txbuf[offset + i + 6];
+				write_buf[i +  5] = txbuf[offset + i + 7];
+			}
+		} else {
+			unsigned int j = end + (SPI_HEADER - 1);
+			for (i = 0; i < end; i++, j--) {
+				if (offset + i < len)
+					write_buf[j] = txbuf[offset + i];
+				else
+					write_buf[j] = 0;
+			}
 		}
+		write_buf[end + SPI_HEADER] = spi_cmd;
 
-		write_buf[end + 5] = spi_cmd;
+		mutex_lock(&spi_mutex);
+		status |= spi_write(g_spi, write_buf, end + SPI_HEADER + 1);
+		mutex_unlock(&spi_mutex);
 
-		rt5677_spi_write(write_buf, end + 6);
+		offset += end;
+	}
 
-		offset += RT5677_SPI_BUF_LEN;
+	return status;
+}
+EXPORT_SYMBOL_GPL(rt5677_spi_write);
+
+void rt5677_spi_hotword_detected(void)
+{
+	struct snd_soc_platform *platform;
+	struct rt5677_dsp *rt5677_dsp;
+
+	if (!g_spi)
+		return;
+	platform = snd_soc_lookup_platform(&g_spi->dev);
+	if (!platform) {
+		dev_err(&g_spi->dev, "Can't get snd_soc_platform\n");
+		return;
 	}
 
-	kfree(write_buf);
+	rt5677_dsp = snd_soc_platform_get_drvdata(platform);
+	if (!rt5677_dsp) {
+		dev_err(&g_spi->dev, "Can't get rt5677_dsp\n");
+		return;
+	}
 
-	return 0;
+	mutex_lock(&rt5677_dsp->dma_lock);
+	dev_info(rt5677_dsp->dev, "Hotword detected\n");
+	rt5677_dsp->new_hotword = true;
+	mutex_unlock(&rt5677_dsp->dma_lock);
+
+	schedule_delayed_work(&rt5677_dsp->copy_work, 0);
 }
-EXPORT_SYMBOL_GPL(rt5677_spi_burst_write);
+EXPORT_SYMBOL_GPL(rt5677_spi_hotword_detected);
 
 static int rt5677_spi_probe(struct spi_device *spi)
 {
+	int ret;
+
 	g_spi = spi;
+
+	ret = snd_soc_register_platform(&spi->dev, &rt5677_spi_platform);
+	if (ret < 0) {
+		dev_err(&spi->dev, "Failed to register platform.\n");
+		goto err_plat;
+	}
+
+	ret = snd_soc_register_component(&spi->dev, &rt5677_spi_dai_component,
+					 &rt5677_spi_dai, 1);
+	if (ret < 0) {
+		dev_err(&spi->dev, "Failed to register component.\n");
+		goto err_comp;
+	}
 	return 0;
+
+err_comp:
+	snd_soc_unregister_platform(&spi->dev);
+err_plat:
+	return ret;
 }
 
+static int rt5677_spi_remove(struct spi_device *spi)
+{
+	snd_soc_unregister_component(&spi->dev);
+	snd_soc_unregister_platform(&spi->dev);
+	return 0;
+}
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id rt5677_spi_acpi_id[] = {
+	{ "RT5677AA", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, rt5677_spi_acpi_id);
+#endif
+
 static struct spi_driver rt5677_spi_driver = {
 	.driver = {
-		.name = "rt5677",
+		.name = "rt5677spi",
 		.owner = THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(rt5677_spi_acpi_id),
 	},
 	.probe = rt5677_spi_probe,
+	.remove = rt5677_spi_remove,
 };
 module_spi_driver(rt5677_spi_driver);
 
diff -Naur linux-3.19.old/sound/soc/codecs/rt5677-spi.h linux-3.19/sound/soc/codecs/rt5677-spi.h
--- linux-3.19.old/sound/soc/codecs/rt5677-spi.h	2015-03-24 17:38:13.906510302 -0800
+++ linux-3.19/sound/soc/codecs/rt5677-spi.h	2015-03-24 18:28:21.328013360 -0800
@@ -12,10 +12,8 @@
 #ifndef __RT5677_SPI_H__
 #define __RT5677_SPI_H__
 
-#define RT5677_SPI_BUF_LEN 240
-#define RT5677_SPI_CMD_BURST_WRITE 0x05
-
-int rt5677_spi_write(u8 *txbuf, size_t len);
-int rt5677_spi_burst_write(u32 addr, const struct firmware *fw);
+int rt5677_spi_write(u32 addr, const u8 *txbuf, size_t len);
+int rt5677_spi_read(u32 addr, void *rxbuf, size_t len);
+void rt5677_spi_hotword_detected(void);
 
 #endif /* __RT5677_SPI_H__ */
diff -Naur linux-3.19.old/sound/soc/codecs/sn95031.c linux-3.19/sound/soc/codecs/sn95031.c
--- linux-3.19.old/sound/soc/codecs/sn95031.c	2015-03-24 17:38:13.933176967 -0800
+++ linux-3.19/sound/soc/codecs/sn95031.c	2015-03-24 18:28:21.328013360 -0800
@@ -312,14 +312,14 @@
 /* mux controls */
 static const char *sn95031_mic_texts[] = { "AMIC", "LineIn" };
 
-static SOC_ENUM_SINGLE_DECL(sn95031_micl_enum,
-			    SN95031_ADCCONFIG, 1, sn95031_mic_texts);
+static const struct soc_enum sn95031_micl_enum =
+	SOC_ENUM_SINGLE(SN95031_ADCCONFIG, 1, 2, sn95031_mic_texts);
 
 static const struct snd_kcontrol_new sn95031_micl_mux_control =
 	SOC_DAPM_ENUM("Route", sn95031_micl_enum);
 
-static SOC_ENUM_SINGLE_DECL(sn95031_micr_enum,
-			    SN95031_ADCCONFIG, 3, sn95031_mic_texts);
+static const struct soc_enum sn95031_micr_enum =
+	SOC_ENUM_SINGLE(SN95031_ADCCONFIG, 3, 2, sn95031_mic_texts);
 
 static const struct snd_kcontrol_new sn95031_micr_mux_control =
 	SOC_DAPM_ENUM("Route", sn95031_micr_enum);
@@ -328,26 +328,26 @@
 						"DMIC4", "DMIC5", "DMIC6",
 						"ADC Left", "ADC Right" };
 
-static SOC_ENUM_SINGLE_DECL(sn95031_input1_enum,
-			    SN95031_AUDIOMUX12, 0, sn95031_input_texts);
+static const struct soc_enum sn95031_input1_enum =
+	SOC_ENUM_SINGLE(SN95031_AUDIOMUX12, 0, 8, sn95031_input_texts);
 
 static const struct snd_kcontrol_new sn95031_input1_mux_control =
 	SOC_DAPM_ENUM("Route", sn95031_input1_enum);
 
-static SOC_ENUM_SINGLE_DECL(sn95031_input2_enum,
-			    SN95031_AUDIOMUX12, 4, sn95031_input_texts);
+static const struct soc_enum sn95031_input2_enum =
+	SOC_ENUM_SINGLE(SN95031_AUDIOMUX12, 4, 8, sn95031_input_texts);
 
 static const struct snd_kcontrol_new sn95031_input2_mux_control =
 	SOC_DAPM_ENUM("Route", sn95031_input2_enum);
 
-static SOC_ENUM_SINGLE_DECL(sn95031_input3_enum,
-			    SN95031_AUDIOMUX34, 0, sn95031_input_texts);
+static const struct soc_enum sn95031_input3_enum =
+	SOC_ENUM_SINGLE(SN95031_AUDIOMUX34, 0, 8, sn95031_input_texts);
 
 static const struct snd_kcontrol_new sn95031_input3_mux_control =
 	SOC_DAPM_ENUM("Route", sn95031_input3_enum);
 
-static SOC_ENUM_SINGLE_DECL(sn95031_input4_enum,
-			    SN95031_AUDIOMUX34, 4, sn95031_input_texts);
+static const struct soc_enum sn95031_input4_enum =
+	SOC_ENUM_SINGLE(SN95031_AUDIOMUX34, 4, 8, sn95031_input_texts);
 
 static const struct snd_kcontrol_new sn95031_input4_mux_control =
 	SOC_DAPM_ENUM("Route", sn95031_input4_enum);
@@ -359,19 +359,19 @@
 /* 0dB to 30dB in 10dB steps */
 static const DECLARE_TLV_DB_SCALE(mic_tlv, 0, 10, 0);
 
-static SOC_ENUM_SINGLE_DECL(sn95031_micmode1_enum,
-			    SN95031_MICAMP1, 1, sn95031_micmode_text);
-static SOC_ENUM_SINGLE_DECL(sn95031_micmode2_enum,
-			    SN95031_MICAMP2, 1, sn95031_micmode_text);
+static const struct soc_enum sn95031_micmode1_enum =
+	SOC_ENUM_SINGLE(SN95031_MICAMP1, 1, 2, sn95031_micmode_text);
+static const struct soc_enum sn95031_micmode2_enum =
+	SOC_ENUM_SINGLE(SN95031_MICAMP2, 1, 2, sn95031_micmode_text);
 
 static const char *sn95031_dmic_cfg_text[] = {"GPO", "DMIC"};
 
-static SOC_ENUM_SINGLE_DECL(sn95031_dmic12_cfg_enum,
-			    SN95031_DMICMUX, 0, sn95031_dmic_cfg_text);
-static SOC_ENUM_SINGLE_DECL(sn95031_dmic34_cfg_enum,
-			    SN95031_DMICMUX, 1, sn95031_dmic_cfg_text);
-static SOC_ENUM_SINGLE_DECL(sn95031_dmic56_cfg_enum,
-			    SN95031_DMICMUX, 2, sn95031_dmic_cfg_text);
+static const struct soc_enum sn95031_dmic12_cfg_enum =
+	SOC_ENUM_SINGLE(SN95031_DMICMUX, 0, 2, sn95031_dmic_cfg_text);
+static const struct soc_enum sn95031_dmic34_cfg_enum =
+	SOC_ENUM_SINGLE(SN95031_DMICMUX, 1, 2, sn95031_dmic_cfg_text);
+static const struct soc_enum sn95031_dmic56_cfg_enum =
+	SOC_ENUM_SINGLE(SN95031_DMICMUX, 2, 2, sn95031_dmic_cfg_text);
 
 static const struct snd_kcontrol_new sn95031_snd_controls[] = {
 	SOC_ENUM("Mic1Mode Capture Route", sn95031_micmode1_enum),
@@ -661,12 +661,12 @@
 {
 	unsigned int format, rate;
 
-	switch (params_width(params)) {
-	case 16:
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
 		format = BIT(4)|BIT(5);
 		break;
 
-	case 24:
+	case SNDRV_PCM_FORMAT_S24_LE:
 		format = 0;
 		break;
 	default:
@@ -867,16 +867,25 @@
 	snd_soc_write(codec, SN95031_SSR2, 0x10);
 	snd_soc_write(codec, SN95031_SSR3, 0x40);
 
+	snd_soc_add_codec_controls(codec, sn95031_snd_controls,
+			     ARRAY_SIZE(sn95031_snd_controls));
+
+	return 0;
+}
+
+static int sn95031_codec_remove(struct snd_soc_codec *codec)
+{
+	pr_debug("codec_remove called\n");
+	sn95031_set_vaud_bias(codec, SND_SOC_BIAS_OFF);
+
 	return 0;
 }
 
 static struct snd_soc_codec_driver sn95031_codec = {
 	.probe		= sn95031_codec_probe,
+	.remove		= sn95031_codec_remove,
 	.set_bias_level	= sn95031_set_vaud_bias,
 	.idle_bias_off	= true,
-
-	.controls	= sn95031_snd_controls,
-	.num_controls	= ARRAY_SIZE(sn95031_snd_controls),
 	.dapm_widgets	= sn95031_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(sn95031_dapm_widgets),
 	.dapm_routes	= sn95031_audio_map,
@@ -907,6 +916,7 @@
 static struct platform_driver sn95031_codec_driver = {
 	.driver		= {
 		.name		= "sn95031",
+		.owner		= THIS_MODULE,
 	},
 	.probe		= sn95031_device_probe,
 	.remove		= sn95031_device_remove,
diff -Naur linux-3.19.old/sound/soc/intel/bdw-rt5677.c linux-3.19/sound/soc/intel/bdw-rt5677.c
--- linux-3.19.old/sound/soc/intel/bdw-rt5677.c	1969-12-31 14:00:00.000000000 -1000
+++ linux-3.19/sound/soc/intel/bdw-rt5677.c	2015-03-24 18:19:04.684663440 -0800
@@ -0,0 +1,364 @@
+/*
+ * ASoC machine driver for Intel Broadwell platforms with RT5677 codec
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+
+#include "sst-dsp.h"
+#include "sst-haswell-ipc.h"
+
+#include "../codecs/rt5677.h"
+
+/* GPIO indexes defined by ACPI */
+enum {
+	RT5677_GPIO_PLUG_DET,
+	RT5677_GPIO_MIC_PRESENT_L,
+	RT5677_GPIO_HOTWORD_DET_L,
+	RT5677_GPIO_DSP_INT,
+	RT5677_GPIO_HP_AMP_SHDN_L,
+};
+
+struct bdw_rt5677_priv {
+	struct gpio_desc *gpio_hp_en;
+	struct snd_soc_codec *codec;
+};
+
+static int bdw_rt5677_event_hp(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_soc_card *card = dapm->card;
+	struct bdw_rt5677_priv *bdw_rt5677 = snd_soc_card_get_drvdata(card);
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		msleep(70);
+
+	gpiod_set_value_cansleep(bdw_rt5677->gpio_hp_en,
+		SND_SOC_DAPM_EVENT_ON(event));
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget bdw_rt5677_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone", bdw_rt5677_event_hp),
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Local DMICs", NULL),
+	SND_SOC_DAPM_MIC("Remote DMICs", NULL),
+};
+
+static const struct snd_soc_dapm_route bdw_rt5677_map[] = {
+	/* Speakers */
+	{"Speaker", NULL, "PDM1L"},
+	{"Speaker", NULL, "PDM1R"},
+
+	/* Headset jack connectors */
+	{"Headphone", NULL, "LOUT1"},
+	{"Headphone", NULL, "LOUT2"},
+	{"IN1P", NULL, "Headset Mic"},
+	{"IN1N", NULL, "Headset Mic"},
+
+	/* Digital MICs
+	 * Local DMICs: the two DMICs on the mainboard
+	 * Remote DMICs: the two DMICs on the camera module
+	 */
+	{"DMIC L1", NULL, "Remote DMICs"},
+	{"DMIC R1", NULL, "Remote DMICs"},
+	{"DMIC L2", NULL, "Local DMICs"},
+	{"DMIC R2", NULL, "Local DMICs"},
+
+	/* CODEC BE connections */
+	{"SSP0 CODEC IN", NULL, "AIF1 Capture"},
+	{"AIF1 Playback", NULL, "SSP0 CODEC OUT"},
+};
+
+static const struct snd_kcontrol_new bdw_rt5677_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Speaker"),
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+	SOC_DAPM_PIN_SWITCH("Local DMICs"),
+	SOC_DAPM_PIN_SWITCH("Remote DMICs"),
+};
+
+
+static struct snd_soc_jack headphone_jack;
+static struct snd_soc_jack mic_jack;
+
+static struct snd_soc_jack_pin headphone_jack_pin = {
+	.pin	= "Headphone",
+	.mask	= SND_JACK_HEADPHONE,
+};
+
+static struct snd_soc_jack_pin mic_jack_pin = {
+	.pin	= "Headset Mic",
+	.mask	= SND_JACK_MICROPHONE,
+};
+
+static struct snd_soc_jack_gpio headphone_jack_gpio = {
+	.name			= "RT5677_GPIO_PLUG_DET",
+	.idx			= RT5677_GPIO_PLUG_DET,
+	.report			= SND_JACK_HEADPHONE,
+	.debounce_time		= 200,
+};
+
+static struct snd_soc_jack_gpio mic_jack_gpio = {
+	.name			= "RT5677_GPIO_MIC_PRESENT_L",
+	.idx			= RT5677_GPIO_MIC_PRESENT_L,
+	.report			= SND_JACK_MICROPHONE,
+	.debounce_time		= 200,
+	.invert			= 1,
+};
+
+static int broadwell_ssp0_fixup(struct snd_soc_pcm_runtime *rtd,
+			struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+						SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	/* The ADSP will covert the FE rate to 48k, stereo */
+	rate->min = rate->max = 48000;
+	channels->min = channels->max = 2;
+
+	/* set SSP0 to 16 bit */
+	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
+				    SNDRV_PCM_HW_PARAM_FIRST_MASK],
+				    SNDRV_PCM_FORMAT_S16_LE);
+	return 0;
+}
+
+static int bdw_rt5677_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, RT5677_SCLK_S_MCLK, 24576000,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		dev_err(rtd->dev, "can't set codec sysclk configuration\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static struct snd_soc_ops bdw_rt5677_ops = {
+	.hw_params = bdw_rt5677_hw_params,
+};
+
+static int bdw_rt5677_rtd_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct sst_pdata *pdata = dev_get_platdata(rtd->platform->dev);
+	struct sst_hsw *broadwell = pdata->dsp;
+	int ret;
+
+	/* Set ADSP SSP port settings */
+	ret = sst_hsw_device_set_config(broadwell, SST_HSW_DEVICE_SSP_0,
+		SST_HSW_DEVICE_MCLK_FREQ_24_MHZ,
+		SST_HSW_DEVICE_CLOCK_MASTER, 9);
+	if (ret < 0) {
+		dev_err(rtd->dev, "error: failed to set device config\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int bdw_rt5677_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct bdw_rt5677_priv *bdw_rt5677 =
+			snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	/* Request rt5677 GPIO for headphone amp control */
+	bdw_rt5677->gpio_hp_en = devm_gpiod_get_index(codec->dev,
+		"RT5677_GPIO_HP_AMP_SHDN_L", RT5677_GPIO_HP_AMP_SHDN_L);
+	if (IS_ERR(bdw_rt5677->gpio_hp_en)) {
+		dev_err(codec->dev, "Can't find HP_AMP_SHDN_L gpio\n");
+		return PTR_ERR(bdw_rt5677->gpio_hp_en);
+	}
+	gpiod_direction_output(bdw_rt5677->gpio_hp_en, 0);
+
+	/* Create and initialize headphone jack */
+	if (!snd_soc_jack_new(codec, "Headphone Jack", SND_JACK_HEADPHONE,
+			&headphone_jack)) {
+		if (snd_soc_jack_add_pins(&headphone_jack, 1,
+				&headphone_jack_pin))
+			dev_err(codec->dev, "Can't add headphone jack pin\n");
+
+		headphone_jack_gpio.gpiod_dev = codec->dev;
+		if (snd_soc_jack_add_gpios(&headphone_jack, 1,
+				&headphone_jack_gpio))
+			dev_err(codec->dev, "Can't add headphone jack gpio\n");
+	} else {
+		dev_err(codec->dev, "Can't create headphone jack\n");
+	}
+
+	/* Create and initialize mic jack */
+	if (!snd_soc_jack_new(codec, "Mic Jack", SND_JACK_MICROPHONE,
+			&mic_jack)) {
+		if (snd_soc_jack_add_pins(&mic_jack, 1, &mic_jack_pin))
+			dev_err(codec->dev, "Can't add mic jack pin\n");
+
+		mic_jack_gpio.gpiod_dev = codec->dev;
+		if (snd_soc_jack_add_gpios(&mic_jack, 1, &mic_jack_gpio))
+			dev_err(codec->dev, "Can't add mic jack gpio\n");
+	} else {
+		dev_err(codec->dev, "Can't create mic jack\n");
+	}
+	bdw_rt5677->codec = codec;
+
+	snd_soc_dapm_force_enable_pin(dapm, "MICBIAS1");
+	return 0;
+}
+
+/* broadwell digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link bdw_rt5677_dais[] = {
+	/* Front End DAI links */
+	{
+		.name = "System PCM",
+		.stream_name = "System Playback",
+		.cpu_dai_name = "System Pin",
+		.platform_name = "haswell-pcm-audio",
+		.dynamic = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.init = bdw_rt5677_rtd_init,
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST
+		},
+		.dpcm_playback = 1,
+	},
+	{
+		.name = "Capture PCM",
+		.stream_name = "Capture",
+		.cpu_dai_name = "Capture Pin",
+		.platform_name = "haswell-pcm-audio",
+		.dynamic = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.trigger = {
+			SND_SOC_DPCM_TRIGGER_POST,
+			SND_SOC_DPCM_TRIGGER_POST
+		},
+		.dpcm_capture = 1,
+	},
+
+	/* Non-DPCM links */
+	{
+		.name = "Codec DSP",
+		.stream_name = "Wake on Voice",
+		.cpu_name = "spi-RT5677AA:00",
+		.cpu_dai_name = "spi-RT5677AA:00",
+		.codec_name = "i2c-RT5677CE:00",
+		.codec_dai_name = "rt5677-dspbuffer",
+		.platform_name = "spi-RT5677AA:00",
+	},
+
+	/* Back End DAI links */
+	{
+		/* SSP0 - Codec */
+		.name = "Codec",
+		.be_id = 0,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "i2c-RT5677CE:00",
+		.codec_dai_name = "rt5677-aif1",
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+		.ignore_suspend = 1,
+		.ignore_pmdown_time = 1,
+		.be_hw_params_fixup = broadwell_ssp0_fixup,
+		.ops = &bdw_rt5677_ops,
+		.dpcm_playback = 1,
+		.dpcm_capture = 1,
+		.init = bdw_rt5677_init,
+	},
+};
+
+/* ASoC machine driver for Broadwell DSP + RT5677 */
+static struct snd_soc_card bdw_rt5677_card = {
+	.name = "bdw-rt5677",
+	.owner = THIS_MODULE,
+	.dai_link = bdw_rt5677_dais,
+	.num_links = ARRAY_SIZE(bdw_rt5677_dais),
+	.dapm_widgets = bdw_rt5677_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(bdw_rt5677_widgets),
+	.dapm_routes = bdw_rt5677_map,
+	.num_dapm_routes = ARRAY_SIZE(bdw_rt5677_map),
+	.controls = bdw_rt5677_controls,
+	.num_controls = ARRAY_SIZE(bdw_rt5677_controls),
+	.fully_routed = true,
+	.pop_time = 20,
+};
+
+static int bdw_rt5677_probe(struct platform_device *pdev)
+{
+	struct bdw_rt5677_priv *bdw_rt5677;
+
+	bdw_rt5677_card.dev = &pdev->dev;
+
+	/* Allocate driver private struct */
+	bdw_rt5677 = devm_kzalloc(&pdev->dev, sizeof(struct bdw_rt5677_priv),
+		GFP_KERNEL);
+	if (!bdw_rt5677) {
+		dev_err(&pdev->dev, "Can't allocate bdw_rt5677\n");
+		return -ENOMEM;
+	}
+	snd_soc_card_set_drvdata(&bdw_rt5677_card, bdw_rt5677);
+
+	return snd_soc_register_card(&bdw_rt5677_card);
+}
+
+static int bdw_rt5677_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_card(&bdw_rt5677_card);
+	return 0;
+}
+
+static int snd_soc_bdw_rt5677_resume(struct device *dev)
+{
+	struct snd_soc_card *card = dev_get_drvdata(dev);
+	struct bdw_rt5677_priv *bdw_rt5677 = snd_soc_card_get_drvdata(card);
+
+	if (bdw_rt5677->codec)
+		rt5677_poll_gpios(bdw_rt5677->codec);
+
+	return snd_soc_resume(dev);
+}
+
+const struct dev_pm_ops snd_soc_bdw_rt5677_pm_ops = {
+	.resume = snd_soc_bdw_rt5677_resume,
+};
+
+static struct platform_driver bdw_rt5677_audio = {
+	.probe = bdw_rt5677_probe,
+	.remove = bdw_rt5677_remove,
+	.driver = {
+		.name = "bdw-rt5677",
+		.owner = THIS_MODULE,
+		.pm = &snd_soc_bdw_rt5677_pm_ops,
+	},
+};
+
+module_platform_driver(bdw_rt5677_audio)
+
+/* Module information */
+MODULE_AUTHOR("Ben Zhang");
+MODULE_DESCRIPTION("Intel Broadwell RT5677 machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:bdw-rt5677");
diff -Naur linux-3.19.old/sound/soc/intel/broadwell.c linux-3.19/sound/soc/intel/broadwell.c
--- linux-3.19.old/sound/soc/intel/broadwell.c	2015-03-24 17:38:14.389843614 -0800
+++ linux-3.19/sound/soc/intel/broadwell.c	2015-03-24 18:19:04.684663440 -0800
@@ -27,19 +27,24 @@
 
 #include "../codecs/rt286.h"
 
-static struct snd_soc_jack broadwell_headset;
+static struct snd_soc_jack broadwell_hp;
+static struct snd_soc_jack broadwell_mic;
+
 /* Headset jack detection DAPM pins */
-static struct snd_soc_jack_pin broadwell_headset_pins[] = {
-	{
-		.pin = "Mic Jack",
-		.mask = SND_JACK_MICROPHONE,
-	},
+static struct snd_soc_jack_pin broadwell_hp_pins[] = {
 	{
 		.pin = "Headphone Jack",
 		.mask = SND_JACK_HEADPHONE,
 	},
 };
 
+static struct snd_soc_jack_pin broadwell_mic_pins[] = {
+	{
+		.pin = "Mic Jack",
+		.mask = SND_JACK_MICROPHONE,
+	},
+};
+
 static const struct snd_kcontrol_new broadwell_controls[] = {
 	SOC_DAPM_PIN_SWITCH("Speaker"),
 	SOC_DAPM_PIN_SWITCH("Headphone Jack"),
@@ -80,19 +85,26 @@
 {
 	struct snd_soc_codec *codec = rtd->codec;
 	int ret = 0;
-	ret = snd_soc_jack_new(codec, "Headset",
-		SND_JACK_HEADSET | SND_JACK_BTN_0, &broadwell_headset);
 
+	ret = snd_soc_jack_new(codec, "Headphone Jack", SND_JACK_HEADPHONE,
+				&broadwell_hp);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_jack_add_pins(&broadwell_hp, 1, broadwell_hp_pins);
 	if (ret)
 		return ret;
 
-	ret = snd_soc_jack_add_pins(&broadwell_headset,
-		ARRAY_SIZE(broadwell_headset_pins),
-		broadwell_headset_pins);
+	ret = snd_soc_jack_new(codec, "Mic Jack", SND_JACK_MICROPHONE,
+				&broadwell_mic);
 	if (ret)
 		return ret;
 
-	rt286_mic_detect(codec, &broadwell_headset);
+	ret = snd_soc_jack_add_pins(&broadwell_mic, 1, broadwell_mic_pins);
+	if (ret)
+		return ret;
+
+	rt286_mic_detect(codec, &broadwell_hp, &broadwell_mic);
 	return 0;
 }
 
@@ -171,7 +183,7 @@
 	/* Front End DAI links */
 	{
 		.name = "System PCM",
-		.stream_name = "System Playback/Capture",
+		.stream_name = "System Playback",
 		.cpu_dai_name = "System Pin",
 		.platform_name = "haswell-pcm-audio",
 		.dynamic = 1,
@@ -180,7 +192,6 @@
 		.init = broadwell_rtd_init,
 		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
 		.dpcm_playback = 1,
-		.dpcm_capture = 1,
 	},
 	{
 		.name = "Offload0",
@@ -215,6 +226,18 @@
 		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
 		.dpcm_capture = 1,
 	},
+	{
+		.name = "Capture PCM",
+		.stream_name = "Capture",
+		.cpu_dai_name = "Capture Pin",
+		.platform_name = "haswell-pcm-audio",
+		.dynamic = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.dpcm_capture = 1,
+	},
+
 	/* Back End DAI links */
 	{
 		/* SSP0 - Codec */
@@ -270,6 +293,7 @@
 	.remove = broadwell_audio_remove,
 	.driver = {
 		.name = "broadwell-audio",
+		.owner = THIS_MODULE,
 	},
 };
 
diff -Naur linux-3.19.old/sound/soc/intel/bytcr_dpcm_rt5640.c linux-3.19/sound/soc/intel/bytcr_dpcm_rt5640.c
--- linux-3.19.old/sound/soc/intel/bytcr_dpcm_rt5640.c	2015-03-24 17:38:14.396510281 -0800
+++ linux-3.19/sound/soc/intel/bytcr_dpcm_rt5640.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,230 +0,0 @@
-/*
- *  byt_cr_dpcm_rt5640.c - ASoc Machine driver for Intel Byt CR platform
- *
- *  Copyright (C) 2014 Intel Corp
- *  Author: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/device.h>
-#include <linux/slab.h>
-#include <linux/input.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include "../codecs/rt5640.h"
-#include "sst-atom-controls.h"
-
-static const struct snd_soc_dapm_widget byt_dapm_widgets[] = {
-	SND_SOC_DAPM_HP("Headphone", NULL),
-	SND_SOC_DAPM_MIC("Headset Mic", NULL),
-	SND_SOC_DAPM_MIC("Int Mic", NULL),
-	SND_SOC_DAPM_SPK("Ext Spk", NULL),
-};
-
-static const struct snd_soc_dapm_route byt_audio_map[] = {
-	{"IN2P", NULL, "Headset Mic"},
-	{"IN2N", NULL, "Headset Mic"},
-	{"Headset Mic", NULL, "MICBIAS1"},
-	{"IN1P", NULL, "MICBIAS1"},
-	{"LDO2", NULL, "Int Mic"},
-	{"Headphone", NULL, "HPOL"},
-	{"Headphone", NULL, "HPOR"},
-	{"Ext Spk", NULL, "SPOLP"},
-	{"Ext Spk", NULL, "SPOLN"},
-	{"Ext Spk", NULL, "SPORP"},
-	{"Ext Spk", NULL, "SPORN"},
-
-	{"AIF1 Playback", NULL, "ssp2 Tx"},
-	{"ssp2 Tx", NULL, "codec_out0"},
-	{"ssp2 Tx", NULL, "codec_out1"},
-	{"codec_in0", NULL, "ssp2 Rx"},
-	{"codec_in1", NULL, "ssp2 Rx"},
-	{"ssp2 Rx", NULL, "AIF1 Capture"},
-};
-
-static const struct snd_kcontrol_new byt_mc_controls[] = {
-	SOC_DAPM_PIN_SWITCH("Headphone"),
-	SOC_DAPM_PIN_SWITCH("Headset Mic"),
-	SOC_DAPM_PIN_SWITCH("Int Mic"),
-	SOC_DAPM_PIN_SWITCH("Ext Spk"),
-};
-
-static int byt_aif1_hw_params(struct snd_pcm_substream *substream,
-					struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	int ret;
-
-	snd_soc_dai_set_bclk_ratio(codec_dai, 50);
-
-	ret = snd_soc_dai_set_sysclk(codec_dai, RT5640_SCLK_S_PLL1,
-				     params_rate(params) * 512,
-				     SND_SOC_CLOCK_IN);
-	if (ret < 0) {
-		dev_err(rtd->dev, "can't set codec clock %d\n", ret);
-		return ret;
-	}
-
-	ret = snd_soc_dai_set_pll(codec_dai, 0, RT5640_PLL1_S_BCLK1,
-				  params_rate(params) * 50,
-				  params_rate(params) * 512);
-	if (ret < 0) {
-		dev_err(rtd->dev, "can't set codec pll: %d\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static const struct snd_soc_pcm_stream byt_dai_params = {
-	.formats = SNDRV_PCM_FMTBIT_S24_LE,
-	.rate_min = 48000,
-	.rate_max = 48000,
-	.channels_min = 2,
-	.channels_max = 2,
-};
-
-static int byt_codec_fixup(struct snd_soc_pcm_runtime *rtd,
-			    struct snd_pcm_hw_params *params)
-{
-	struct snd_interval *rate = hw_param_interval(params,
-			SNDRV_PCM_HW_PARAM_RATE);
-	struct snd_interval *channels = hw_param_interval(params,
-						SNDRV_PCM_HW_PARAM_CHANNELS);
-
-	/* The DSP will covert the FE rate to 48k, stereo, 24bits */
-	rate->min = rate->max = 48000;
-	channels->min = channels->max = 2;
-
-	/* set SSP2 to 24-bit */
-	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
-				    SNDRV_PCM_HW_PARAM_FIRST_MASK],
-				    SNDRV_PCM_FORMAT_S24_LE);
-	return 0;
-}
-
-static unsigned int rates_48000[] = {
-	48000,
-};
-
-static struct snd_pcm_hw_constraint_list constraints_48000 = {
-	.count = ARRAY_SIZE(rates_48000),
-	.list  = rates_48000,
-};
-
-static int byt_aif1_startup(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_hw_constraint_list(substream->runtime, 0,
-			SNDRV_PCM_HW_PARAM_RATE,
-			&constraints_48000);
-}
-
-static struct snd_soc_ops byt_aif1_ops = {
-	.startup = byt_aif1_startup,
-};
-
-static struct snd_soc_ops byt_be_ssp2_ops = {
-	.hw_params = byt_aif1_hw_params,
-};
-
-static struct snd_soc_dai_link byt_dailink[] = {
-	[MERR_DPCM_AUDIO] = {
-		.name = "Baytrail Audio Port",
-		.stream_name = "Baytrail Audio",
-		.cpu_dai_name = "media-cpu-dai",
-		.codec_dai_name = "snd-soc-dummy-dai",
-		.codec_name = "snd-soc-dummy",
-		.platform_name = "sst-mfld-platform",
-		.ignore_suspend = 1,
-		.dynamic = 1,
-		.dpcm_playback = 1,
-		.dpcm_capture = 1,
-		.ops = &byt_aif1_ops,
-	},
-	[MERR_DPCM_COMPR] = {
-		.name = "Baytrail Compressed Port",
-		.stream_name = "Baytrail Compress",
-		.cpu_dai_name = "compress-cpu-dai",
-		.codec_dai_name = "snd-soc-dummy-dai",
-		.codec_name = "snd-soc-dummy",
-		.platform_name = "sst-mfld-platform",
-	},
-		/* back ends */
-	{
-		.name = "SSP2-Codec",
-		.be_id = 1,
-		.cpu_dai_name = "ssp2-port",
-		.platform_name = "sst-mfld-platform",
-		.no_pcm = 1,
-		.codec_dai_name = "rt5640-aif1",
-		.codec_name = "i2c-10EC5640:00",
-		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
-						| SND_SOC_DAIFMT_CBS_CFS,
-		.be_hw_params_fixup = byt_codec_fixup,
-		.ignore_suspend = 1,
-		.dpcm_playback = 1,
-		.dpcm_capture = 1,
-		.ops = &byt_be_ssp2_ops,
-	},
-};
-
-/* SoC card */
-static struct snd_soc_card snd_soc_card_byt = {
-	.name = "baytrailcraudio",
-	.dai_link = byt_dailink,
-	.num_links = ARRAY_SIZE(byt_dailink),
-	.dapm_widgets = byt_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(byt_dapm_widgets),
-	.dapm_routes = byt_audio_map,
-	.num_dapm_routes = ARRAY_SIZE(byt_audio_map),
-	.controls = byt_mc_controls,
-	.num_controls = ARRAY_SIZE(byt_mc_controls),
-};
-
-static int snd_byt_mc_probe(struct platform_device *pdev)
-{
-	int ret_val = 0;
-
-	/* register the soc card */
-	snd_soc_card_byt.dev = &pdev->dev;
-
-	ret_val = devm_snd_soc_register_card(&pdev->dev, &snd_soc_card_byt);
-	if (ret_val) {
-		dev_err(&pdev->dev, "devm_snd_soc_register_card failed %d\n", ret_val);
-		return ret_val;
-	}
-	platform_set_drvdata(pdev, &snd_soc_card_byt);
-	return ret_val;
-}
-
-static struct platform_driver snd_byt_mc_driver = {
-	.driver = {
-		.owner = THIS_MODULE,
-		.name = "bytt100_rt5640",
-		.pm = &snd_soc_pm_ops,
-	},
-	.probe = snd_byt_mc_probe,
-};
-
-module_platform_driver(snd_byt_mc_driver);
-
-MODULE_DESCRIPTION("ASoC Intel(R) Baytrail CR Machine driver");
-MODULE_AUTHOR("Subhransu S. Prusty <subhransu.s.prusty@intel.com>");
-MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:bytt100_rt5640");
diff -Naur linux-3.19.old/sound/soc/intel/byt-max98090.c linux-3.19/sound/soc/intel/byt-max98090.c
--- linux-3.19.old/sound/soc/intel/byt-max98090.c	2015-03-24 17:38:14.389843614 -0800
+++ linux-3.19/sound/soc/intel/byt-max98090.c	2015-03-24 18:19:04.684663440 -0800
@@ -12,6 +12,8 @@
  * more details.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
@@ -25,21 +27,27 @@
 #include <sound/soc.h>
 #include <sound/jack.h>
 #include "../codecs/max98090.h"
+#include "sst-dsp.h"
+#include "sst-baytrail-ipc.h"
+
+#define BYT_PLAT_CLK_3_HZ      25000000
 
-struct byt_max98090_private {
-	struct snd_soc_jack jack;
+struct byt_mc_private {
+	struct snd_soc_jack hp_jack;
+	struct snd_soc_jack mic_jack;
 };
 
-static const struct snd_soc_dapm_widget byt_max98090_widgets[] = {
+static const struct snd_soc_dapm_widget byt_dapm_widgets[] = {
 	SND_SOC_DAPM_HP("Headphone", NULL),
 	SND_SOC_DAPM_MIC("Headset Mic", NULL),
 	SND_SOC_DAPM_MIC("Int Mic", NULL),
 	SND_SOC_DAPM_SPK("Ext Spk", NULL),
 };
 
-static const struct snd_soc_dapm_route byt_max98090_audio_map[] = {
+static const struct snd_soc_dapm_route byt_audio_map[] = {
 	{"IN34", NULL, "Headset Mic"},
-	{"Headset Mic", NULL, "MICBIAS"},
+	{"IN34", NULL, "MICBIAS"},
+	{"MICBIAS", NULL, "Headset Mic"},
 	{"DMICL", NULL, "Int Mic"},
 	{"Headphone", NULL, "HPL"},
 	{"Headphone", NULL, "HPR"},
@@ -47,144 +55,295 @@
 	{"Ext Spk", NULL, "SPKR"},
 };
 
-static const struct snd_kcontrol_new byt_max98090_controls[] = {
+static const struct snd_kcontrol_new byt_mc_controls[] = {
 	SOC_DAPM_PIN_SWITCH("Headphone"),
 	SOC_DAPM_PIN_SWITCH("Headset Mic"),
 	SOC_DAPM_PIN_SWITCH("Int Mic"),
 	SOC_DAPM_PIN_SWITCH("Ext Spk"),
 };
 
-static struct snd_soc_jack_pin hs_jack_pins[] = {
-	{
-		.pin	= "Headphone",
-		.mask	= SND_JACK_HEADPHONE,
-	},
-	{
-		.pin	= "Headset Mic",
-		.mask	= SND_JACK_MICROPHONE,
-	},
+static int byt_aif1_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int ret;
+
+	pr_debug("Enter:%s", __func__);
+
+	/*
+	 * The particular clock id specified below does not matter since the
+	 * max98090 driver ignores it.
+	 */
+	ret = snd_soc_dai_set_sysclk(codec_dai, M98090_REG_SYSTEM_CLOCK,
+				     BYT_PLAT_CLK_3_HZ,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		dev_err(codec_dai->dev, "Can't set codec clock %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_jack_pin hp_jack_pin = {
+	.pin	= "Headphone",
+	.mask	= SND_JACK_HEADPHONE,
 };
 
-static struct snd_soc_jack_gpio hs_jack_gpios[] = {
-	{
-		.name		= "hp-gpio",
-		.idx		= 0,
-		.report		= SND_JACK_HEADPHONE | SND_JACK_LINEOUT,
-		.debounce_time	= 200,
-	},
-	{
-		.name		= "mic-gpio",
-		.idx		= 1,
-		.invert		= 1,
-		.report		= SND_JACK_MICROPHONE,
-		.debounce_time	= 200,
-	},
+static struct snd_soc_jack_pin mic_jack_pin = {
+	.pin	= "Headset Mic",
+	.mask	= SND_JACK_MICROPHONE,
+};
+
+static struct snd_soc_jack_gpio hp_jack_gpio = {
+	.name			= "hp-gpio",
+	.report			= SND_JACK_HEADPHONE,
+	.debounce_time		= 200,
+};
+
+static struct snd_soc_jack_gpio mic_jack_gpio = {
+	.name			= "mic-gpio",
+	.report			= SND_JACK_MICROPHONE,
+	.debounce_time		= 200,
+	.invert			= 1,
 };
 
-static int byt_max98090_init(struct snd_soc_pcm_runtime *runtime)
+/* enable the codec SHDN after LRCLK and BCLK have been activated by DSP FW */
+static void byt_max98090_start(struct sst_dsp *dsp, void *data)
+{
+	struct snd_soc_pcm_runtime *runtime = data;
+	struct snd_soc_codec *codec = runtime->codec;
+
+	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+}
+
+static void byt_max98090_stop(struct sst_dsp *dsp, void *data)
+{
+	struct snd_soc_pcm_runtime *runtime = data;
+	struct snd_soc_codec *codec = runtime->codec;
+
+	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+					M98090_SHDNN_MASK, 0);
+}
+
+static int byt_init(struct snd_soc_pcm_runtime *runtime)
 {
 	int ret;
 	struct snd_soc_codec *codec = runtime->codec;
+	struct snd_soc_platform *platform = runtime->platform;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	struct snd_soc_card *card = runtime->card;
-	struct byt_max98090_private *drv = snd_soc_card_get_drvdata(card);
-	struct snd_soc_jack *jack = &drv->jack;
+	struct byt_mc_private *drv = snd_soc_card_get_drvdata(card);
+	struct sst_pdata *pdata = dev_get_platdata(platform->dev);
+	struct snd_soc_jack *hp_jack = &drv->hp_jack;
+	struct snd_soc_jack *mic_jack = &drv->mic_jack;
+
+	pr_debug("Enter:%s", __func__);
+	sst_byt_register_notifier(platform->dev, pdata,
+		byt_max98090_start, byt_max98090_stop, runtime);
 
 	card->dapm.idle_bias_off = true;
 
-	ret = snd_soc_dai_set_sysclk(runtime->codec_dai,
-				     M98090_REG_SYSTEM_CLOCK,
-				     25000000, SND_SOC_CLOCK_IN);
-	if (ret < 0) {
-		dev_err(card->dev, "Can't set codec clock %d\n", ret);
+	ret = snd_soc_add_card_controls(card, byt_mc_controls,
+					ARRAY_SIZE(byt_mc_controls));
+	if (ret) {
+		pr_err("unable to add card controls\n");
 		return ret;
 	}
 
-	/* Enable jack detection */
-	ret = snd_soc_jack_new(codec, "Headset",
-			       SND_JACK_LINEOUT | SND_JACK_HEADSET, jack);
+	snd_soc_dapm_enable_pin(dapm, "Headset Mic");
+	snd_soc_dapm_enable_pin(dapm, "Headphone");
+	snd_soc_dapm_enable_pin(dapm, "Ext Spk");
+	snd_soc_dapm_enable_pin(dapm, "Int Mic");
+
+	snd_soc_dapm_sync(dapm);
+
+
+	/* Enable headphone jack detection */
+	ret = snd_soc_jack_new(codec, "Headphone Jack", SND_JACK_HEADPHONE,
+			       hp_jack);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_jack_add_pins(hp_jack, 1, &hp_jack_pin);
+	if (ret)
+		return ret;
+
+	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S, M98090_IJDET_MASK,
+				1 << M98090_IJDET_SHIFT);
+
+	ret = snd_soc_jack_add_gpios(hp_jack, 1, &hp_jack_gpio);
 	if (ret)
 		return ret;
 
-	ret = snd_soc_jack_add_pins(jack, ARRAY_SIZE(hs_jack_pins),
-				    hs_jack_pins);
+	/* Enable mic jack detection */
+	ret = snd_soc_jack_new(codec, "Mic Jack", SND_JACK_MICROPHONE,
+			       mic_jack);
+	if (ret)
+		return ret;
+	ret = snd_soc_jack_add_pins(mic_jack, 1, &mic_jack_pin);
 	if (ret)
 		return ret;
+	ret = snd_soc_jack_add_gpios(mic_jack, 1, &mic_jack_gpio);
 
-	return snd_soc_jack_add_gpiods(card->dev->parent, jack,
-				       ARRAY_SIZE(hs_jack_gpios),
-				       hs_jack_gpios);
+	return ret;
 }
 
-static struct snd_soc_dai_link byt_max98090_dais[] = {
+static struct snd_soc_ops byt_aif1_ops = {
+	.hw_params = byt_aif1_hw_params,
+};
+
+static struct snd_soc_dai_link byt_dailink[] = {
 	{
 		.name = "Baytrail Audio",
 		.stream_name = "Audio",
-		.cpu_dai_name = "baytrail-pcm-audio",
+		.cpu_dai_name = "Front-cpu-dai",
 		.codec_dai_name = "HiFi",
-		.codec_name = "i2c-193C9890:00",
+		.codec_name = "max98090.1-0010",
 		.platform_name = "baytrail-pcm-audio",
-		.init = byt_max98090_init,
+		.init = byt_init,
+		.ops = &byt_aif1_ops,
 		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-			   SND_SOC_DAIFMT_CBS_CFS,
+			SND_SOC_DAIFMT_CBS_CFS,
+	},
+	{
+		.name = "Baytrail Voice",
+		.stream_name = "Voice",
+		.cpu_dai_name = "Front-cpu-dai",
+		.codec_dai_name = "HiFi",
+		.codec_name = "max98090.1-0010",
+		.platform_name = "baytrail-pcm-audio",
+		.init = NULL,
+		.ops = &byt_aif1_ops,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
 	},
 };
 
-static struct snd_soc_card byt_max98090_card = {
+static struct snd_soc_card snd_soc_card_byt = {
 	.name = "byt-max98090",
-	.dai_link = byt_max98090_dais,
-	.num_links = ARRAY_SIZE(byt_max98090_dais),
-	.dapm_widgets = byt_max98090_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(byt_max98090_widgets),
-	.dapm_routes = byt_max98090_audio_map,
-	.num_dapm_routes = ARRAY_SIZE(byt_max98090_audio_map),
-	.controls = byt_max98090_controls,
-	.num_controls = ARRAY_SIZE(byt_max98090_controls),
-	.fully_routed = true,
+	.dai_link = byt_dailink,
+	.num_links = ARRAY_SIZE(byt_dailink),
+	.dapm_widgets = byt_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(byt_dapm_widgets),
+	.dapm_routes = byt_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(byt_audio_map),
+	.controls = byt_mc_controls,
+	.num_controls = ARRAY_SIZE(byt_mc_controls),
 };
 
-static int byt_max98090_probe(struct platform_device *pdev)
+#ifdef CONFIG_PM_SLEEP
+static int snd_byt_prepare(struct device *dev)
 {
-	int ret_val = 0;
-	struct byt_max98090_private *priv;
+	struct snd_soc_card *card = dev_get_drvdata(dev);
+	struct byt_mc_private *drv = snd_soc_card_get_drvdata(card);
+
+	snd_soc_jack_free_gpios(&drv->hp_jack, 1, &hp_jack_gpio);
+	snd_soc_jack_free_gpios(&drv->mic_jack, 1, &mic_jack_gpio);
 
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_ATOMIC);
-	if (!priv) {
-		dev_err(&pdev->dev, "allocation failed\n");
+	return snd_soc_suspend(dev);
+}
+
+static void snd_byt_complete(struct device *dev)
+{
+	struct snd_soc_card *card = dev_get_drvdata(dev);
+	struct byt_mc_private *drv = snd_soc_card_get_drvdata(card);
+
+	snd_soc_jack_add_gpios(&drv->hp_jack, 1, &hp_jack_gpio);
+	snd_soc_jack_add_gpios(&drv->mic_jack, 1, &mic_jack_gpio);
+
+	snd_soc_resume(dev);
+}
+
+static const struct dev_pm_ops byt_max98090_pm_ops = {
+	.prepare = snd_byt_prepare,
+	.complete = snd_byt_complete,
+};
+
+#define BYT_MAX98090_PM_OPS	(&byt_max98090_pm_ops)
+#else
+#define BYT_MAX98090_PM_OPS	NULL
+#endif
+
+static int snd_byt_mc_probe(struct platform_device *pdev)
+{
+	int ret_val = 0;
+	struct byt_mc_private *drv;
+	struct gpio_desc *mic_desc;
+	struct gpio_desc *hp_desc;
+
+	pr_debug("Entry %s\n", __func__);
+
+	drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_ATOMIC);
+	if (!drv) {
+		pr_err("allocation failed\n");
 		return -ENOMEM;
 	}
 
-	byt_max98090_card.dev = &pdev->dev;
-	snd_soc_card_set_drvdata(&byt_max98090_card, priv);
-	ret_val = devm_snd_soc_register_card(&pdev->dev, &byt_max98090_card);
+	/*
+	 * ASoC still uses legacy GPIOs so we look both GPIOs using
+	 * descriptors here, convert them to numbers and release the
+	 * acquired descriptors. Once ASoC switches over to GPIO descriptor
+	 * APIs we can pass them directly.
+	 */
+	hp_desc = gpiod_get_index(pdev->dev.parent, NULL, 0);
+	if (IS_ERR(hp_desc)) {
+		pr_err("unable to get hp-gpio\n");
+		return PTR_ERR(hp_desc);
+	}
+	mic_desc = gpiod_get_index(pdev->dev.parent, NULL, 1);
+	if (IS_ERR(mic_desc)) {
+		pr_err("unable to get mic-gpio\n");
+		gpiod_put(hp_desc);
+		return PTR_ERR(mic_desc);
+	}
+
+	hp_jack_gpio.gpio = desc_to_gpio(hp_desc);
+	mic_jack_gpio.gpio = desc_to_gpio(mic_desc);
+
+	gpiod_put(mic_desc);
+	gpiod_put(hp_desc);
+
+	/* register the soc card */
+	snd_soc_card_byt.dev = &pdev->dev;
+	snd_soc_card_set_drvdata(&snd_soc_card_byt, drv);
+	ret_val = snd_soc_register_card(&snd_soc_card_byt);
 	if (ret_val) {
-		dev_err(&pdev->dev,
-			"snd_soc_register_card failed %d\n", ret_val);
+		pr_err("snd_soc_register_card failed %d\n", ret_val);
 		return ret_val;
 	}
-
+	platform_set_drvdata(pdev, &snd_soc_card_byt);
+	pr_info("%s successful\n", __func__);
 	return ret_val;
 }
 
-static int byt_max98090_remove(struct platform_device *pdev)
+static int snd_byt_mc_remove(struct platform_device *pdev)
 {
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
-	struct byt_max98090_private *priv = snd_soc_card_get_drvdata(card);
-
-	snd_soc_jack_free_gpios(&priv->jack, ARRAY_SIZE(hs_jack_gpios),
-				hs_jack_gpios);
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct byt_mc_private *drv = snd_soc_card_get_drvdata(soc_card);
 
+	pr_debug("In %s\n", __func__);
+	snd_soc_jack_free_gpios(&drv->hp_jack, 1, &hp_jack_gpio);
+	snd_soc_jack_free_gpios(&drv->mic_jack, 1, &mic_jack_gpio);
+
+	snd_soc_card_set_drvdata(soc_card, NULL);
+	snd_soc_unregister_card(soc_card);
+	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
 
-static struct platform_driver byt_max98090_driver = {
-	.probe = byt_max98090_probe,
-	.remove = byt_max98090_remove,
+static struct platform_driver snd_byt_mc_driver = {
+	.probe = snd_byt_mc_probe,
+	.remove = snd_byt_mc_remove,
 	.driver = {
 		.name = "byt-max98090",
-		.pm = &snd_soc_pm_ops,
+		.owner = THIS_MODULE,
+		.pm = BYT_MAX98090_PM_OPS,
 	},
 };
-module_platform_driver(byt_max98090_driver)
+module_platform_driver(snd_byt_mc_driver)
 
 MODULE_DESCRIPTION("ASoC Intel(R) Baytrail Machine driver");
 MODULE_AUTHOR("Omair Md Abdullah, Jarkko Nikula");
diff -Naur linux-3.19.old/sound/soc/intel/byt-rt5640.c linux-3.19/sound/soc/intel/byt-rt5640.c
--- linux-3.19.old/sound/soc/intel/byt-rt5640.c	2015-03-24 17:38:14.389843614 -0800
+++ linux-3.19/sound/soc/intel/byt-rt5640.c	2015-03-24 18:19:04.684663440 -0800
@@ -17,7 +17,6 @@
 #include <linux/platform_device.h>
 #include <linux/acpi.h>
 #include <linux/device.h>
-#include <linux/dmi.h>
 #include <linux/slab.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -35,8 +34,9 @@
 };
 
 static const struct snd_soc_dapm_route byt_rt5640_audio_map[] = {
-	{"Headset Mic", NULL, "MICBIAS1"},
 	{"IN2P", NULL, "Headset Mic"},
+	{"IN2N", NULL, "Headset Mic"},
+	{"DMIC1", NULL, "Internal Mic"},
 	{"Headphone", NULL, "HPOL"},
 	{"Headphone", NULL, "HPOR"},
 	{"Speaker", NULL, "SPOLP"},
@@ -45,31 +45,6 @@
 	{"Speaker", NULL, "SPORN"},
 };
 
-static const struct snd_soc_dapm_route byt_rt5640_intmic_dmic1_map[] = {
-	{"DMIC1", NULL, "Internal Mic"},
-};
-
-static const struct snd_soc_dapm_route byt_rt5640_intmic_dmic2_map[] = {
-	{"DMIC2", NULL, "Internal Mic"},
-};
-
-static const struct snd_soc_dapm_route byt_rt5640_intmic_in1_map[] = {
-	{"Internal Mic", NULL, "MICBIAS1"},
-	{"IN1P", NULL, "Internal Mic"},
-};
-
-enum {
-	BYT_RT5640_DMIC1_MAP,
-	BYT_RT5640_DMIC2_MAP,
-	BYT_RT5640_IN1_MAP,
-};
-
-#define BYT_RT5640_MAP(quirk)	((quirk) & 0xff)
-#define BYT_RT5640_DMIC_EN	BIT(16)
-
-static unsigned long byt_rt5640_quirk = BYT_RT5640_DMIC1_MAP |
-					BYT_RT5640_DMIC_EN;
-
 static const struct snd_kcontrol_new byt_rt5640_controls[] = {
 	SOC_DAPM_PIN_SWITCH("Headphone"),
 	SOC_DAPM_PIN_SWITCH("Headset Mic"),
@@ -101,41 +76,12 @@
 	return 0;
 }
 
-static int byt_rt5640_quirk_cb(const struct dmi_system_id *id)
-{
-	byt_rt5640_quirk = (unsigned long)id->driver_data;
-	return 1;
-}
-
-static const struct dmi_system_id byt_rt5640_quirk_table[] = {
-	{
-		.callback = byt_rt5640_quirk_cb,
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "T100TA"),
-		},
-		.driver_data = (unsigned long *)BYT_RT5640_IN1_MAP,
-	},
-	{
-		.callback = byt_rt5640_quirk_cb,
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "DellInc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Venue 8 Pro 5830"),
-		},
-		.driver_data = (unsigned long *)(BYT_RT5640_DMIC2_MAP |
-						 BYT_RT5640_DMIC_EN),
-	},
-	{}
-};
-
 static int byt_rt5640_init(struct snd_soc_pcm_runtime *runtime)
 {
 	int ret;
 	struct snd_soc_codec *codec = runtime->codec;
 	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	struct snd_soc_card *card = runtime->card;
-	const struct snd_soc_dapm_route *custom_map;
-	int num_routes;
 
 	card->dapm.idle_bias_off = true;
 
@@ -146,31 +92,6 @@
 		return ret;
 	}
 
-	dmi_check_system(byt_rt5640_quirk_table);
-	switch (BYT_RT5640_MAP(byt_rt5640_quirk)) {
-	case BYT_RT5640_IN1_MAP:
-		custom_map = byt_rt5640_intmic_in1_map;
-		num_routes = ARRAY_SIZE(byt_rt5640_intmic_in1_map);
-		break;
-	case BYT_RT5640_DMIC2_MAP:
-		custom_map = byt_rt5640_intmic_dmic2_map;
-		num_routes = ARRAY_SIZE(byt_rt5640_intmic_dmic2_map);
-		break;
-	default:
-		custom_map = byt_rt5640_intmic_dmic1_map;
-		num_routes = ARRAY_SIZE(byt_rt5640_intmic_dmic1_map);
-	}
-
-	ret = snd_soc_dapm_add_routes(dapm, custom_map, num_routes);
-	if (ret)
-		return ret;
-
-	if (byt_rt5640_quirk & BYT_RT5640_DMIC_EN) {
-		ret = rt5640_dmic_enable(codec, 0, 0);
-		if (ret)
-			return ret;
-	}
-
 	snd_soc_dapm_ignore_suspend(dapm, "HPOL");
 	snd_soc_dapm_ignore_suspend(dapm, "HPOR");
 
@@ -179,6 +100,11 @@
 	snd_soc_dapm_ignore_suspend(dapm, "SPORP");
 	snd_soc_dapm_ignore_suspend(dapm, "SPORN");
 
+	snd_soc_dapm_enable_pin(dapm, "Headset Mic");
+	snd_soc_dapm_enable_pin(dapm, "Headphone");
+	snd_soc_dapm_enable_pin(dapm, "Speaker");
+	snd_soc_dapm_enable_pin(dapm, "Internal Mic");
+
 	return ret;
 }
 
@@ -190,7 +116,7 @@
 	{
 		.name = "Baytrail Audio",
 		.stream_name = "Audio",
-		.cpu_dai_name = "baytrail-pcm-audio",
+		.cpu_dai_name = "Front-cpu-dai",
 		.codec_dai_name = "rt5640-aif1",
 		.codec_name = "i2c-10EC5640:00",
 		.platform_name = "baytrail-pcm-audio",
@@ -199,6 +125,18 @@
 		.init = byt_rt5640_init,
 		.ops = &byt_rt5640_ops,
 	},
+	{
+		.name = "Baytrail Voice",
+		.stream_name = "Voice",
+		.cpu_dai_name = "Mic1-cpu-dai",
+		.codec_dai_name = "rt5640-aif1",
+		.codec_name = "i2c-10EC5640:00",
+		.platform_name = "baytrail-pcm-audio",
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			   SND_SOC_DAIFMT_CBS_CFS,
+		.init = NULL,
+		.ops = &byt_rt5640_ops,
+	},
 };
 
 static struct snd_soc_card byt_rt5640_card = {
@@ -209,9 +147,19 @@
 	.num_dapm_widgets = ARRAY_SIZE(byt_rt5640_widgets),
 	.dapm_routes = byt_rt5640_audio_map,
 	.num_dapm_routes = ARRAY_SIZE(byt_rt5640_audio_map),
-	.fully_routed = true,
 };
 
+#ifdef CONFIG_PM_SLEEP
+static const struct dev_pm_ops byt_rt5640_pm_ops = {
+	.suspend = snd_soc_suspend,
+	.resume = snd_soc_resume,
+};
+
+#define BYT_RT5640_PM_OPS	(&byt_rt5640_pm_ops)
+#else
+#define BYT_RT5640_PM_OPS	NULL
+#endif
+
 static int byt_rt5640_probe(struct platform_device *pdev)
 {
 	struct snd_soc_card *card = &byt_rt5640_card;
@@ -224,7 +172,8 @@
 	.probe = byt_rt5640_probe,
 	.driver = {
 		.name = "byt-rt5640",
-		.pm = &snd_soc_pm_ops,
+		.owner = THIS_MODULE,
+		.pm = BYT_RT5640_PM_OPS,
 	},
 };
 module_platform_driver(byt_rt5640_audio)
diff -Naur linux-3.19.old/sound/soc/intel/cht_bsw_rt5672.c linux-3.19/sound/soc/intel/cht_bsw_rt5672.c
--- linux-3.19.old/sound/soc/intel/cht_bsw_rt5672.c	2015-03-24 17:38:14.396510281 -0800
+++ linux-3.19/sound/soc/intel/cht_bsw_rt5672.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,285 +0,0 @@
-/*
- *  cht_bsw_rt5672.c - ASoc Machine driver for Intel Cherryview-based platforms
- *                     Cherrytrail and Braswell, with RT5672 codec.
- *
- *  Copyright (C) 2014 Intel Corp
- *  Author: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
- *          Mengdong Lin <mengdong.lin@intel.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- */
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include "../codecs/rt5670.h"
-#include "sst-atom-controls.h"
-
-/* The platform clock #3 outputs 19.2Mhz clock to codec as I2S MCLK */
-#define CHT_PLAT_CLK_3_HZ	19200000
-#define CHT_CODEC_DAI	"rt5670-aif1"
-
-static inline struct snd_soc_dai *cht_get_codec_dai(struct snd_soc_card *card)
-{
-	int i;
-
-	for (i = 0; i < card->num_rtd; i++) {
-		struct snd_soc_pcm_runtime *rtd;
-
-		rtd = card->rtd + i;
-		if (!strncmp(rtd->codec_dai->name, CHT_CODEC_DAI,
-			     strlen(CHT_CODEC_DAI)))
-			return rtd->codec_dai;
-	}
-	return NULL;
-}
-
-static int platform_clock_control(struct snd_soc_dapm_widget *w,
-		struct snd_kcontrol *k, int  event)
-{
-	struct snd_soc_dapm_context *dapm = w->dapm;
-	struct snd_soc_card *card = dapm->card;
-	struct snd_soc_dai *codec_dai;
-
-	codec_dai = cht_get_codec_dai(card);
-	if (!codec_dai) {
-		dev_err(card->dev, "Codec dai not found; Unable to set platform clock\n");
-		return -EIO;
-	}
-
-	if (!SND_SOC_DAPM_EVENT_OFF(event))
-		return 0;
-
-	/* Set codec sysclk source to its internal clock because codec PLL will
-	 * be off when idle and MCLK will also be off by ACPI when codec is
-	 * runtime suspended. Codec needs clock for jack detection and button
-	 * press.
-	 */
-	snd_soc_dai_set_sysclk(codec_dai, RT5670_SCLK_S_RCCLK,
-			       0, SND_SOC_CLOCK_IN);
-
-	return 0;
-}
-
-static const struct snd_soc_dapm_widget cht_dapm_widgets[] = {
-	SND_SOC_DAPM_HP("Headphone", NULL),
-	SND_SOC_DAPM_MIC("Headset Mic", NULL),
-	SND_SOC_DAPM_MIC("Int Mic", NULL),
-	SND_SOC_DAPM_SPK("Ext Spk", NULL),
-	SND_SOC_DAPM_SUPPLY("Platform Clock", SND_SOC_NOPM, 0, 0,
-			platform_clock_control, SND_SOC_DAPM_POST_PMD),
-};
-
-static const struct snd_soc_dapm_route cht_audio_map[] = {
-	{"IN1P", NULL, "Headset Mic"},
-	{"IN1N", NULL, "Headset Mic"},
-	{"DMIC L1", NULL, "Int Mic"},
-	{"DMIC R1", NULL, "Int Mic"},
-	{"Headphone", NULL, "HPOL"},
-	{"Headphone", NULL, "HPOR"},
-	{"Ext Spk", NULL, "SPOLP"},
-	{"Ext Spk", NULL, "SPOLN"},
-	{"Ext Spk", NULL, "SPORP"},
-	{"Ext Spk", NULL, "SPORN"},
-	{"AIF1 Playback", NULL, "ssp2 Tx"},
-	{"ssp2 Tx", NULL, "codec_out0"},
-	{"ssp2 Tx", NULL, "codec_out1"},
-	{"codec_in0", NULL, "ssp2 Rx"},
-	{"codec_in1", NULL, "ssp2 Rx"},
-	{"ssp2 Rx", NULL, "AIF1 Capture"},
-	{"Headphone", NULL, "Platform Clock"},
-	{"Headset Mic", NULL, "Platform Clock"},
-	{"Int Mic", NULL, "Platform Clock"},
-	{"Ext Spk", NULL, "Platform Clock"},
-};
-
-static const struct snd_kcontrol_new cht_mc_controls[] = {
-	SOC_DAPM_PIN_SWITCH("Headphone"),
-	SOC_DAPM_PIN_SWITCH("Headset Mic"),
-	SOC_DAPM_PIN_SWITCH("Int Mic"),
-	SOC_DAPM_PIN_SWITCH("Ext Spk"),
-};
-
-static int cht_aif1_hw_params(struct snd_pcm_substream *substream,
-					struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	int ret;
-
-	/* set codec PLL source to the 19.2MHz platform clock (MCLK) */
-	ret = snd_soc_dai_set_pll(codec_dai, 0, RT5670_PLL1_S_MCLK,
-				  CHT_PLAT_CLK_3_HZ, params_rate(params) * 512);
-	if (ret < 0) {
-		dev_err(rtd->dev, "can't set codec pll: %d\n", ret);
-		return ret;
-	}
-
-	/* set codec sysclk source to PLL */
-	ret = snd_soc_dai_set_sysclk(codec_dai, RT5670_SCLK_S_PLL1,
-				     params_rate(params) * 512,
-				     SND_SOC_CLOCK_IN);
-	if (ret < 0) {
-		dev_err(rtd->dev, "can't set codec sysclk: %d\n", ret);
-		return ret;
-	}
-	return 0;
-}
-
-static int cht_codec_init(struct snd_soc_pcm_runtime *runtime)
-{
-	int ret;
-	struct snd_soc_dai *codec_dai = runtime->codec_dai;
-
-	/* TDM 4 slots 24 bit, set Rx & Tx bitmask to 4 active slots */
-	ret = snd_soc_dai_set_tdm_slot(codec_dai, 0xF, 0xF, 4, 24);
-	if (ret < 0) {
-		dev_err(runtime->dev, "can't set codec TDM slot %d\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int cht_codec_fixup(struct snd_soc_pcm_runtime *rtd,
-			    struct snd_pcm_hw_params *params)
-{
-	struct snd_interval *rate = hw_param_interval(params,
-			SNDRV_PCM_HW_PARAM_RATE);
-	struct snd_interval *channels = hw_param_interval(params,
-						SNDRV_PCM_HW_PARAM_CHANNELS);
-
-	/* The DSP will covert the FE rate to 48k, stereo, 24bits */
-	rate->min = rate->max = 48000;
-	channels->min = channels->max = 2;
-
-	/* set SSP2 to 24-bit */
-	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
-				    SNDRV_PCM_HW_PARAM_FIRST_MASK],
-				    SNDRV_PCM_FORMAT_S24_LE);
-	return 0;
-}
-
-static unsigned int rates_48000[] = {
-	48000,
-};
-
-static struct snd_pcm_hw_constraint_list constraints_48000 = {
-	.count = ARRAY_SIZE(rates_48000),
-	.list  = rates_48000,
-};
-
-static int cht_aif1_startup(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_hw_constraint_list(substream->runtime, 0,
-			SNDRV_PCM_HW_PARAM_RATE,
-			&constraints_48000);
-}
-
-static struct snd_soc_ops cht_aif1_ops = {
-	.startup = cht_aif1_startup,
-};
-
-static struct snd_soc_ops cht_be_ssp2_ops = {
-	.hw_params = cht_aif1_hw_params,
-};
-
-static struct snd_soc_dai_link cht_dailink[] = {
-	/* Front End DAI links */
-	[MERR_DPCM_AUDIO] = {
-		.name = "Audio Port",
-		.stream_name = "Audio",
-		.cpu_dai_name = "media-cpu-dai",
-		.codec_dai_name = "snd-soc-dummy-dai",
-		.codec_name = "snd-soc-dummy",
-		.platform_name = "sst-mfld-platform",
-		.ignore_suspend = 1,
-		.dynamic = 1,
-		.dpcm_playback = 1,
-		.dpcm_capture = 1,
-		.ops = &cht_aif1_ops,
-	},
-	[MERR_DPCM_COMPR] = {
-		.name = "Compressed Port",
-		.stream_name = "Compress",
-		.cpu_dai_name = "compress-cpu-dai",
-		.codec_dai_name = "snd-soc-dummy-dai",
-		.codec_name = "snd-soc-dummy",
-		.platform_name = "sst-mfld-platform",
-	},
-
-	/* Back End DAI links */
-	{
-		/* SSP2 - Codec */
-		.name = "SSP2-Codec",
-		.be_id = 1,
-		.cpu_dai_name = "ssp2-port",
-		.platform_name = "sst-mfld-platform",
-		.no_pcm = 1,
-		.codec_dai_name = "rt5670-aif1",
-		.codec_name = "i2c-10EC5670:00",
-		.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF
-					| SND_SOC_DAIFMT_CBS_CFS,
-		.init = cht_codec_init,
-		.be_hw_params_fixup = cht_codec_fixup,
-		.ignore_suspend = 1,
-		.dpcm_playback = 1,
-		.dpcm_capture = 1,
-		.ops = &cht_be_ssp2_ops,
-	},
-};
-
-/* SoC card */
-static struct snd_soc_card snd_soc_card_cht = {
-	.name = "cherrytrailcraudio",
-	.dai_link = cht_dailink,
-	.num_links = ARRAY_SIZE(cht_dailink),
-	.dapm_widgets = cht_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(cht_dapm_widgets),
-	.dapm_routes = cht_audio_map,
-	.num_dapm_routes = ARRAY_SIZE(cht_audio_map),
-	.controls = cht_mc_controls,
-	.num_controls = ARRAY_SIZE(cht_mc_controls),
-};
-
-static int snd_cht_mc_probe(struct platform_device *pdev)
-{
-	int ret_val = 0;
-
-	/* register the soc card */
-	snd_soc_card_cht.dev = &pdev->dev;
-	ret_val = devm_snd_soc_register_card(&pdev->dev, &snd_soc_card_cht);
-	if (ret_val) {
-		dev_err(&pdev->dev,
-			"snd_soc_register_card failed %d\n", ret_val);
-		return ret_val;
-	}
-	platform_set_drvdata(pdev, &snd_soc_card_cht);
-	return ret_val;
-}
-
-static struct platform_driver snd_cht_mc_driver = {
-	.driver = {
-		.owner = THIS_MODULE,
-		.name = "cht-bsw-rt5672",
-		.pm = &snd_soc_pm_ops,
-	},
-	.probe = snd_cht_mc_probe,
-};
-
-module_platform_driver(snd_cht_mc_driver);
-
-MODULE_DESCRIPTION("ASoC Intel(R) Baytrail CR Machine driver");
-MODULE_AUTHOR("Subhransu S. Prusty, Mengdong Lin");
-MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:cht-bsw-rt5672");
diff -Naur linux-3.19.old/sound/soc/intel/haswell.c linux-3.19/sound/soc/intel/haswell.c
--- linux-3.19.old/sound/soc/intel/haswell.c	2015-03-24 17:38:14.396510281 -0800
+++ linux-3.19/sound/soc/intel/haswell.c	2015-03-24 18:19:04.684663440 -0800
@@ -89,6 +89,8 @@
 
 static int haswell_rtd_init(struct snd_soc_pcm_runtime *rtd)
 {
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	struct sst_pdata *pdata = dev_get_platdata(rtd->platform->dev);
 	struct sst_hsw *haswell = pdata->dsp;
 	int ret;
@@ -102,6 +104,10 @@
 		return ret;
 	}
 
+	/* always connected */
+	snd_soc_dapm_enable_pin(dapm, "Headphones");
+	snd_soc_dapm_enable_pin(dapm, "Mic");
+
 	return 0;
 }
 
@@ -109,7 +115,7 @@
 	/* Front End DAI links */
 	{
 		.name = "System",
-		.stream_name = "System Playback/Capture",
+		.stream_name = "System Playback",
 		.cpu_dai_name = "System Pin",
 		.platform_name = "haswell-pcm-audio",
 		.dynamic = 1,
@@ -118,7 +124,6 @@
 		.init = haswell_rtd_init,
 		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
 		.dpcm_playback = 1,
-		.dpcm_capture = 1,
 	},
 	{
 		.name = "Offload0",
@@ -153,6 +158,17 @@
 		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
 		.dpcm_capture = 1,
 	},
+	{
+		.name = "Capture",
+		.stream_name = "Capture",
+		.cpu_dai_name = "Capture Pin",
+		.platform_name = "haswell-pcm-audio",
+		.dynamic = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.trigger = {SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST},
+		.dpcm_capture = 1,
+	},
 
 	/* Back End DAI links */
 	{
@@ -199,6 +215,7 @@
 	.probe = haswell_audio_probe,
 	.driver = {
 		.name = "haswell-audio",
+		.owner = THIS_MODULE,
 	},
 };
 
diff -Naur linux-3.19.old/sound/soc/intel/Kconfig linux-3.19/sound/soc/intel/Kconfig
--- linux-3.19.old/sound/soc/intel/Kconfig	2015-03-24 17:38:14.389843614 -0800
+++ linux-3.19/sound/soc/intel/Kconfig	2015-03-24 18:19:04.687996773 -0800
@@ -3,7 +3,6 @@
 	depends on INTEL_SCU_IPC
 	select SND_SOC_SN95031
 	select SND_SST_MFLD_PLATFORM
-	select SND_SST_IPC_PCI
 	help
           This adds support for ASoC machine driver for Intel(R) MID Medfield platform
           used as alsa device in audio substem in Intel(R) MID devices
@@ -13,23 +12,10 @@
 config SND_SST_MFLD_PLATFORM
 	tristate
 
-config SND_SST_IPC
-	tristate
-
-config SND_SST_IPC_PCI
-	tristate
-	select SND_SST_IPC
-
-config SND_SST_IPC_ACPI
-	tristate
-	select SND_SST_IPC
-	depends on ACPI
-
 config SND_SOC_INTEL_SST
 	tristate "ASoC support for Intel(R) Smart Sound Technology"
 	select SND_SOC_INTEL_SST_ACPI if ACPI
-	depends on (X86 || COMPILE_TEST)
-	depends on DW_DMAC_CORE
+	depends on (X86 || COMPILE_TEST) && DW_DMAC
 	help
           This adds support for Intel(R) Smart Sound Technology (SST).
           Say Y if you have such a device
@@ -45,20 +31,19 @@
 	tristate
 
 config SND_SOC_INTEL_HASWELL_MACH
-	tristate "ASoC Audio DSP support for Intel Haswell Lynxpoint"
-	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && I2C && \\
-		   I2C_DESIGNWARE_PLATFORM
+        tristate "ASoC Audio DSP support for Intel Haswell Lynxpoint"
+        depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
 	select SND_SOC_INTEL_HASWELL
 	select SND_SOC_RT5640
 	help
-	  This adds support for the Lynxpoint Audio DSP on Intel(R) Haswell
+          This adds support for the Lynxpoint Audio DSP on Intel(R) Haswell
 	  Ultrabook platforms.
-	  Say Y if you have such a device
-	  If unsure select "N".
+          Say Y if you have such a device
+          If unsure select "N".
 
 config SND_SOC_INTEL_BYT_RT5640_MACH
 	tristate "ASoC Audio driver for Intel Baytrail with RT5640 codec"
-	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && I2C
+	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
 	select SND_SOC_INTEL_BAYTRAIL
 	select SND_SOC_RT5640
 	help
@@ -67,9 +52,10 @@
 
 config SND_SOC_INTEL_BYT_MAX98090_MACH
 	tristate "ASoC Audio driver for Intel Baytrail with MAX98090 codec"
-	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && I2C
+	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
 	select SND_SOC_INTEL_BAYTRAIL
 	select SND_SOC_MAX98090
+	select VLV2_PLAT_CLK
 	help
 	  This adds audio driver for Intel Baytrail platform based boards
 	  with the MAX98090 audio codec.
@@ -87,26 +73,13 @@
 	  Say Y if you have such a device
 	  If unsure select "N".
 
-config SND_SOC_INTEL_BYTCR_RT5640_MACH
-	tristate "ASoC Audio DSP Support for MID BYT Platform"
-	depends on X86 && I2C
-	select SND_SOC_RT5640
-	select SND_SST_MFLD_PLATFORM
-	select SND_SST_IPC_ACPI
+config SND_SOC_INTEL_BDW_RT5677_MACH
+	tristate "ASoC driver for Intel Broadwell platforms with RT5677 codec"
+	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS && DW_DMAC
+	select SND_SOC_INTEL_HASWELL
+	select SND_COMPRESS_OFFLOAD
+	select SND_SOC_RT5677
 	help
-	  This adds support for ASoC machine driver for Intel(R) MID Baytrail platform
-          used as alsa device in audio substem in Intel(R) MID devices
-          Say Y if you have such a device
-          If unsure select "N".
-
-config SND_SOC_INTEL_CHT_BSW_RT5672_MACH
-        tristate "ASoC Audio driver for Intel Cherrytrail & Braswell with RT5672 codec"
-        depends on X86_INTEL_LPSS && I2C
-        select SND_SOC_RT5670
-        select SND_SST_MFLD_PLATFORM
-        select SND_SST_IPC_ACPI
-        help
-          This adds support for ASoC machine driver for Intel(R) Cherrytrail & Braswell
-          platforms with RT5672 audio codec.
-          Say Y if you have such a device
-          If unsure select "N".
+	  This adds the ASoC machine driver for Intel Broadwell platforms with RT5677 codec
+	  Say Y if you have such a device
+	  If unsure select "N".
diff -Naur linux-3.19.old/sound/soc/intel/Makefile linux-3.19/sound/soc/intel/Makefile
--- linux-3.19.old/sound/soc/intel/Makefile	2015-03-24 17:38:14.389843614 -0800
+++ linux-3.19/sound/soc/intel/Makefile	2015-03-24 18:19:04.687996773 -0800
@@ -2,8 +2,7 @@
 snd-soc-sst-dsp-objs := sst-dsp.o sst-firmware.o
 snd-soc-sst-acpi-objs := sst-acpi.o
 
-snd-soc-sst-mfld-platform-objs := sst-mfld-platform-pcm.o \
-	sst-mfld-platform-compress.o sst-atom-controls.o
+snd-soc-sst-mfld-platform-objs := sst-mfld-platform-pcm.o sst-mfld-platform-compress.o
 snd-soc-mfld-machine-objs := mfld_machine.o
 
 obj-$(CONFIG_SND_SST_MFLD_PLATFORM) += snd-soc-sst-mfld-platform.o
@@ -15,6 +14,10 @@
 # Platform Support
 snd-soc-sst-haswell-pcm-objs := \
 	sst-haswell-ipc.o sst-haswell-pcm.o sst-haswell-dsp.o
+ifdef CONFIG_DEBUG_FS
+	snd-soc-sst-haswell-pcm-objs += sst-debugfs.o
+endif
+
 snd-soc-sst-baytrail-pcm-objs := \
 	sst-baytrail-ipc.o sst-baytrail-pcm.o sst-baytrail-dsp.o
 
@@ -26,15 +29,10 @@
 snd-soc-sst-byt-rt5640-mach-objs := byt-rt5640.o
 snd-soc-sst-byt-max98090-mach-objs := byt-max98090.o
 snd-soc-sst-broadwell-objs := broadwell.o
-snd-soc-sst-bytcr-dpcm-rt5640-objs := bytcr_dpcm_rt5640.o
-snd-soc-sst-cht-bsw-rt5672-objs := cht_bsw_rt5672.o
+snd-soc-sst-bdw-rt5677-mach-objs := bdw-rt5677.o
 
 obj-$(CONFIG_SND_SOC_INTEL_HASWELL_MACH) += snd-soc-sst-haswell.o
 obj-$(CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH) += snd-soc-sst-byt-rt5640-mach.o
 obj-$(CONFIG_SND_SOC_INTEL_BYT_MAX98090_MACH) += snd-soc-sst-byt-max98090-mach.o
 obj-$(CONFIG_SND_SOC_INTEL_BROADWELL_MACH) += snd-soc-sst-broadwell.o
-obj-$(CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH) += snd-soc-sst-bytcr-dpcm-rt5640.o
-obj-$(CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH) += snd-soc-sst-cht-bsw-rt5672.o
-
-# DSP driver
-obj-$(CONFIG_SND_SST_IPC) += sst/
+obj-$(CONFIG_SND_SOC_INTEL_BDW_RT5677_MACH) += snd-soc-sst-bdw-rt5677-mach.o
diff -Naur linux-3.19.old/sound/soc/intel/mfld_machine.c linux-3.19/sound/soc/intel/mfld_machine.c
--- linux-3.19.old/sound/soc/intel/mfld_machine.c	2015-03-24 17:38:14.396510281 -0800
+++ linux-3.19/sound/soc/intel/mfld_machine.c	2015-03-24 18:19:04.684663440 -0800
@@ -53,7 +53,6 @@
 
 static unsigned int	hs_switch;
 static unsigned int	lo_dac;
-static struct snd_soc_codec *mfld_codec;
 
 struct mfld_mc_private {
 	void __iomem *int_base;
@@ -101,8 +100,8 @@
 static int headset_set_switch(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_dapm_context *dapm = &card->dapm;
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
 
 	if (ucontrol->value.integer.value[0] == hs_switch)
 		return 0;
@@ -128,8 +127,10 @@
 	return 0;
 }
 
-static void lo_enable_out_pins(struct snd_soc_dapm_context *dapm)
+static void lo_enable_out_pins(struct snd_soc_codec *codec)
 {
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
 	snd_soc_dapm_enable_pin_unlocked(dapm, "IHFOUTL");
 	snd_soc_dapm_enable_pin_unlocked(dapm, "IHFOUTR");
 	snd_soc_dapm_enable_pin_unlocked(dapm, "LINEOUTL");
@@ -155,8 +156,8 @@
 static int lo_set_switch(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
-	struct snd_soc_dapm_context *dapm = &card->dapm;
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
 
 	if (ucontrol->value.integer.value[0] == lo_dac)
 		return 0;
@@ -166,35 +167,35 @@
 	/* we dont want to work with last state of lineout so just enable all
 	 * pins and then disable pins not required
 	 */
-	lo_enable_out_pins(dapm);
+	lo_enable_out_pins(codec);
 
 	switch (ucontrol->value.integer.value[0]) {
 	case 0:
 		pr_debug("set vibra path\n");
 		snd_soc_dapm_disable_pin_unlocked(dapm, "VIB1OUT");
 		snd_soc_dapm_disable_pin_unlocked(dapm, "VIB2OUT");
-		snd_soc_update_bits(mfld_codec, SN95031_LOCTL, 0x66, 0);
+		snd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0);
 		break;
 
 	case 1:
 		pr_debug("set hs  path\n");
 		snd_soc_dapm_disable_pin_unlocked(dapm, "Headphones");
 		snd_soc_dapm_disable_pin_unlocked(dapm, "EPOUT");
-		snd_soc_update_bits(mfld_codec, SN95031_LOCTL, 0x66, 0x22);
+		snd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0x22);
 		break;
 
 	case 2:
 		pr_debug("set spkr path\n");
 		snd_soc_dapm_disable_pin_unlocked(dapm, "IHFOUTL");
 		snd_soc_dapm_disable_pin_unlocked(dapm, "IHFOUTR");
-		snd_soc_update_bits(mfld_codec, SN95031_LOCTL, 0x66, 0x44);
+		snd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0x44);
 		break;
 
 	case 3:
 		pr_debug("set null path\n");
 		snd_soc_dapm_disable_pin_unlocked(dapm, "LINEOUTL");
 		snd_soc_dapm_disable_pin_unlocked(dapm, "LINEOUTR");
-		snd_soc_update_bits(mfld_codec, SN95031_LOCTL, 0x66, 0x66);
+		snd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0x66);
 		break;
 	}
 
@@ -237,11 +238,26 @@
 
 static int mfld_init(struct snd_soc_pcm_runtime *runtime)
 {
-	struct snd_soc_dapm_context *dapm = &runtime->card->dapm;
+	struct snd_soc_codec *codec = runtime->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	int ret_val;
 
-	mfld_codec = runtime->codec;
+	/* Add jack sense widgets */
+	snd_soc_dapm_new_controls(dapm, mfld_widgets, ARRAY_SIZE(mfld_widgets));
+
+	/* Set up the map */
+	snd_soc_dapm_add_routes(dapm, mfld_map, ARRAY_SIZE(mfld_map));
 
+	/* always connected */
+	snd_soc_dapm_enable_pin(dapm, "Headphones");
+	snd_soc_dapm_enable_pin(dapm, "Mic");
+
+	ret_val = snd_soc_add_codec_controls(codec, mfld_snd_controls,
+				ARRAY_SIZE(mfld_snd_controls));
+	if (ret_val) {
+		pr_err("soc_add_controls failed %d", ret_val);
+		return ret_val;
+	}
 	/* default is earpiece pin, userspace sets it explcitly */
 	snd_soc_dapm_disable_pin(dapm, "Headphones");
 	/* default is lineout NC, userspace sets it explcitly */
@@ -254,7 +270,7 @@
 	snd_soc_dapm_disable_pin(dapm, "LINEINR");
 
 	/* Headset and button jack detection */
-	ret_val = snd_soc_jack_new(mfld_codec, "Intel(R) MID Audio Jack",
+	ret_val = snd_soc_jack_new(codec, "Intel(R) MID Audio Jack",
 			SND_JACK_HEADSET | SND_JACK_BTN_0 |
 			SND_JACK_BTN_1, &mfld_jack);
 	if (ret_val) {
@@ -336,13 +352,6 @@
 	.owner = THIS_MODULE,
 	.dai_link = mfld_msic_dailink,
 	.num_links = ARRAY_SIZE(mfld_msic_dailink),
-
-	.controls = mfld_snd_controls,
-	.num_controls = ARRAY_SIZE(mfld_snd_controls),
-	.dapm_widgets = mfld_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(mfld_widgets),
-	.dapm_routes = mfld_map,
-	.num_dapm_routes = ARRAY_SIZE(mfld_map),
 };
 
 static irqreturn_t snd_mfld_jack_intr_handler(int irq, void *dev)
@@ -420,6 +429,7 @@
 
 static struct platform_driver snd_mfld_mc_driver = {
 	.driver = {
+		.owner = THIS_MODULE,
 		.name = "msic_audio",
 	},
 	.probe = snd_mfld_mc_probe,
diff -Naur linux-3.19.old/sound/soc/intel/sst/Makefile linux-3.19/sound/soc/intel/sst/Makefile
--- linux-3.19.old/sound/soc/intel/sst/Makefile	2015-03-24 17:38:14.429843612 -0800
+++ linux-3.19/sound/soc/intel/sst/Makefile	1969-12-31 14:00:00.000000000 -1000
@@ -1,7 +0,0 @@
-snd-intel-sst-core-objs := sst.o sst_ipc.o sst_stream.o sst_drv_interface.o sst_loader.o sst_pvt.o
-snd-intel-sst-pci-objs += sst_pci.o
-snd-intel-sst-acpi-objs += sst_acpi.o
-
-obj-$(CONFIG_SND_SST_IPC) += snd-intel-sst-core.o
-obj-$(CONFIG_SND_SST_IPC_PCI) += snd-intel-sst-pci.o
-obj-$(CONFIG_SND_SST_IPC_ACPI) += snd-intel-sst-acpi.o
diff -Naur linux-3.19.old/sound/soc/intel/sst/sst_acpi.c linux-3.19/sound/soc/intel/sst/sst_acpi.c
--- linux-3.19.old/sound/soc/intel/sst/sst_acpi.c	2015-03-24 20:39:05.899801778 -0800
+++ linux-3.19/sound/soc/intel/sst/sst_acpi.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,383 +0,0 @@
-/*
- * sst_acpi.c - SST (LPE) driver init file for ACPI enumeration.
- *
- * Copyright (c) 2013, Intel Corporation.
- *
- *  Authors:	Ramesh Babu K V <Ramesh.Babu@intel.com>
- *  Authors:	Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- *
- */
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/interrupt.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/miscdevice.h>
-#include <linux/platform_device.h>
-#include <linux/firmware.h>
-#include <linux/pm_runtime.h>
-#include <linux/pm_qos.h>
-#include <linux/acpi.h>
-#include <asm/platform_sst_audio.h>
-#include <sound/core.h>
-#include <sound/soc.h>
-#include <sound/compress_driver.h>
-#include <acpi/acbuffer.h>
-#include <acpi/platform/acenv.h>
-#include <acpi/platform/aclinux.h>
-#include <acpi/actypes.h>
-#include <acpi/acpi_bus.h>
-#include "../sst-mfld-platform.h"
-#include "../sst-dsp.h"
-#include "sst.h"
-
-struct sst_machines {
-	char *codec_id;
-	char board[32];
-	char machine[32];
-	void (*machine_quirk)(void);
-	char firmware[FW_NAME_SIZE];
-	struct sst_platform_info *pdata;
-
-};
-
-/* LPE viewpoint addresses */
-#define SST_BYT_IRAM_PHY_START	0xff2c0000
-#define SST_BYT_IRAM_PHY_END	0xff2d4000
-#define SST_BYT_DRAM_PHY_START	0xff300000
-#define SST_BYT_DRAM_PHY_END	0xff320000
-#define SST_BYT_IMR_VIRT_START	0xc0000000 /* virtual addr in LPE */
-#define SST_BYT_IMR_VIRT_END	0xc01fffff
-#define SST_BYT_SHIM_PHY_ADDR	0xff340000
-#define SST_BYT_MBOX_PHY_ADDR	0xff344000
-#define SST_BYT_DMA0_PHY_ADDR	0xff298000
-#define SST_BYT_DMA1_PHY_ADDR	0xff29c000
-#define SST_BYT_SSP0_PHY_ADDR	0xff2a0000
-#define SST_BYT_SSP2_PHY_ADDR	0xff2a2000
-
-#define BYT_FW_MOD_TABLE_OFFSET	0x80000
-#define BYT_FW_MOD_TABLE_SIZE	0x100
-#define BYT_FW_MOD_OFFSET	(BYT_FW_MOD_TABLE_OFFSET + BYT_FW_MOD_TABLE_SIZE)
-
-static const struct sst_info byt_fwparse_info = {
-	.use_elf	= false,
-	.max_streams	= 25,
-	.iram_start	= SST_BYT_IRAM_PHY_START,
-	.iram_end	= SST_BYT_IRAM_PHY_END,
-	.iram_use	= true,
-	.dram_start	= SST_BYT_DRAM_PHY_START,
-	.dram_end	= SST_BYT_DRAM_PHY_END,
-	.dram_use	= true,
-	.imr_start	= SST_BYT_IMR_VIRT_START,
-	.imr_end	= SST_BYT_IMR_VIRT_END,
-	.imr_use	= true,
-	.mailbox_start	= SST_BYT_MBOX_PHY_ADDR,
-	.num_probes	= 0,
-	.lpe_viewpt_rqd  = true,
-};
-
-static const struct sst_ipc_info byt_ipc_info = {
-	.ipc_offset = 0,
-	.mbox_recv_off = 0x400,
-};
-
-static const struct sst_lib_dnld_info  byt_lib_dnld_info = {
-	.mod_base           = SST_BYT_IMR_VIRT_START,
-	.mod_end            = SST_BYT_IMR_VIRT_END,
-	.mod_table_offset   = BYT_FW_MOD_TABLE_OFFSET,
-	.mod_table_size     = BYT_FW_MOD_TABLE_SIZE,
-	.mod_ddr_dnld       = false,
-};
-
-static const struct sst_res_info byt_rvp_res_info = {
-	.shim_offset = 0x140000,
-	.shim_size = 0x000100,
-	.shim_phy_addr = SST_BYT_SHIM_PHY_ADDR,
-	.ssp0_offset = 0xa0000,
-	.ssp0_size = 0x1000,
-	.dma0_offset = 0x98000,
-	.dma0_size = 0x4000,
-	.dma1_offset = 0x9c000,
-	.dma1_size = 0x4000,
-	.iram_offset = 0x0c0000,
-	.iram_size = 0x14000,
-	.dram_offset = 0x100000,
-	.dram_size = 0x28000,
-	.mbox_offset = 0x144000,
-	.mbox_size = 0x1000,
-	.acpi_lpe_res_index = 0,
-	.acpi_ddr_index = 2,
-	.acpi_ipc_irq_index = 5,
-};
-
-static struct sst_platform_info byt_rvp_platform_data = {
-	.probe_data = &byt_fwparse_info,
-	.ipc_info = &byt_ipc_info,
-	.lib_info = &byt_lib_dnld_info,
-	.res_info = &byt_rvp_res_info,
-	.platform = "sst-mfld-platform",
-};
-
-/* Cherryview (Cherrytrail and Braswell) uses same mrfld dpcm fw as Baytrail,
- * so pdata is same as Baytrail.
- */
-static struct sst_platform_info chv_platform_data = {
-	.probe_data = &byt_fwparse_info,
-	.ipc_info = &byt_ipc_info,
-	.lib_info = &byt_lib_dnld_info,
-	.res_info = &byt_rvp_res_info,
-	.platform = "sst-mfld-platform",
-};
-
-static int sst_platform_get_resources(struct intel_sst_drv *ctx)
-{
-	struct resource *rsrc;
-	struct platform_device *pdev = to_platform_device(ctx->dev);
-
-	/* All ACPI resource request here */
-	/* Get Shim addr */
-	rsrc = platform_get_resource(pdev, IORESOURCE_MEM,
-					ctx->pdata->res_info->acpi_lpe_res_index);
-	if (!rsrc) {
-		dev_err(ctx->dev, "Invalid SHIM base from IFWI");
-		return -EIO;
-	}
-	dev_info(ctx->dev, "LPE base: %#x size:%#x", (unsigned int) rsrc->start,
-					(unsigned int)resource_size(rsrc));
-
-	ctx->iram_base = rsrc->start + ctx->pdata->res_info->iram_offset;
-	ctx->iram_end =  ctx->iram_base + ctx->pdata->res_info->iram_size - 1;
-	dev_info(ctx->dev, "IRAM base: %#x", ctx->iram_base);
-	ctx->iram = devm_ioremap_nocache(ctx->dev, ctx->iram_base,
-					 ctx->pdata->res_info->iram_size);
-	if (!ctx->iram) {
-		dev_err(ctx->dev, "unable to map IRAM");
-		return -EIO;
-	}
-
-	ctx->dram_base = rsrc->start + ctx->pdata->res_info->dram_offset;
-	ctx->dram_end = ctx->dram_base + ctx->pdata->res_info->dram_size - 1;
-	dev_info(ctx->dev, "DRAM base: %#x", ctx->dram_base);
-	ctx->dram = devm_ioremap_nocache(ctx->dev, ctx->dram_base,
-					 ctx->pdata->res_info->dram_size);
-	if (!ctx->dram) {
-		dev_err(ctx->dev, "unable to map DRAM");
-		return -EIO;
-	}
-
-	ctx->shim_phy_add = rsrc->start + ctx->pdata->res_info->shim_offset;
-	dev_info(ctx->dev, "SHIM base: %#x", ctx->shim_phy_add);
-	ctx->shim = devm_ioremap_nocache(ctx->dev, ctx->shim_phy_add,
-					ctx->pdata->res_info->shim_size);
-	if (!ctx->shim) {
-		dev_err(ctx->dev, "unable to map SHIM");
-		return -EIO;
-	}
-
-	/* reassign physical address to LPE viewpoint address */
-	ctx->shim_phy_add = ctx->pdata->res_info->shim_phy_addr;
-
-	/* Get mailbox addr */
-	ctx->mailbox_add = rsrc->start + ctx->pdata->res_info->mbox_offset;
-	dev_info(ctx->dev, "Mailbox base: %#x", ctx->mailbox_add);
-	ctx->mailbox = devm_ioremap_nocache(ctx->dev, ctx->mailbox_add,
-					    ctx->pdata->res_info->mbox_size);
-	if (!ctx->mailbox) {
-		dev_err(ctx->dev, "unable to map mailbox");
-		return -EIO;
-	}
-
-	/* reassign physical address to LPE viewpoint address */
-	ctx->mailbox_add = ctx->info.mailbox_start;
-
-	rsrc = platform_get_resource(pdev, IORESOURCE_MEM,
-					ctx->pdata->res_info->acpi_ddr_index);
-	if (!rsrc) {
-		dev_err(ctx->dev, "Invalid DDR base from IFWI");
-		return -EIO;
-	}
-	ctx->ddr_base = rsrc->start;
-	ctx->ddr_end = rsrc->end;
-	dev_info(ctx->dev, "DDR base: %#x", ctx->ddr_base);
-	ctx->ddr = devm_ioremap_nocache(ctx->dev, ctx->ddr_base,
-					resource_size(rsrc));
-	if (!ctx->ddr) {
-		dev_err(ctx->dev, "unable to map DDR");
-		return -EIO;
-	}
-
-	/* Find the IRQ */
-	ctx->irq_num = platform_get_irq(pdev,
-				ctx->pdata->res_info->acpi_ipc_irq_index);
-	return 0;
-}
-
-static acpi_status sst_acpi_mach_match(acpi_handle handle, u32 level,
-				       void *context, void **ret)
-{
-	*(bool *)context = true;
-	return AE_OK;
-}
-
-static struct sst_machines *sst_acpi_find_machine(
-	struct sst_machines *machines)
-{
-	struct sst_machines *mach;
-	bool found = false;
-
-	for (mach = machines; mach->codec_id; mach++)
-		if (ACPI_SUCCESS(acpi_get_devices(mach->codec_id,
-						  sst_acpi_mach_match,
-						  &found, NULL)) && found)
-			return mach;
-
-	return NULL;
-}
-
-int sst_acpi_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	int ret = 0;
-	struct intel_sst_drv *ctx;
-	const struct acpi_device_id *id;
-	struct sst_machines *mach;
-	struct platform_device *mdev;
-	struct platform_device *plat_dev;
-	unsigned int dev_id;
-
-	id = acpi_match_device(dev->driver->acpi_match_table, dev);
-	if (!id)
-		return -ENODEV;
-	dev_dbg(dev, "for %s", id->id);
-
-	mach = (struct sst_machines *)id->driver_data;
-	mach = sst_acpi_find_machine(mach);
-	if (mach == NULL) {
-		dev_err(dev, "No matching machine driver found\n");
-		return -ENODEV;
-	}
-
-	ret = kstrtouint(id->id, 16, &dev_id);
-	if (ret < 0) {
-		dev_err(dev, "Unique device id conversion error: %d\n", ret);
-		return ret;
-	}
-
-	dev_dbg(dev, "ACPI device id: %x\n", dev_id);
-
-	plat_dev = platform_device_register_data(dev, mach->pdata->platform, -1, NULL, 0);
-	if (IS_ERR(plat_dev)) {
-		dev_err(dev, "Failed to create machine device: %s\n", mach->pdata->platform);
-		return PTR_ERR(plat_dev);
-	}
-
-	/* Create platform device for sst machine driver */
-	mdev = platform_device_register_data(dev, mach->machine, -1, NULL, 0);
-	if (IS_ERR(mdev)) {
-		dev_err(dev, "Failed to create machine device: %s\n", mach->machine);
-		return PTR_ERR(mdev);
-	}
-
-	ret = sst_alloc_drv_context(&ctx, dev, dev_id);
-	if (ret < 0)
-		return ret;
-
-	/* Fill sst platform data */
-	ctx->pdata = mach->pdata;
-	strcpy(ctx->firmware_name, mach->firmware);
-
-	ret = sst_platform_get_resources(ctx);
-	if (ret)
-		return ret;
-
-	ret = sst_context_init(ctx);
-	if (ret < 0)
-		return ret;
-
-	/* need to save shim registers in BYT */
-	ctx->shim_regs64 = devm_kzalloc(ctx->dev, sizeof(*ctx->shim_regs64),
-					GFP_KERNEL);
-	if (!ctx->shim_regs64) {
-		return -ENOMEM;
-		goto do_sst_cleanup;
-	}
-
-	sst_configure_runtime_pm(ctx);
-	platform_set_drvdata(pdev, ctx);
-	return ret;
-
-do_sst_cleanup:
-	sst_context_cleanup(ctx);
-	platform_set_drvdata(pdev, NULL);
-	dev_err(ctx->dev, "failed with %d\n", ret);
-	return ret;
-}
-
-/**
-* intel_sst_remove - remove function
-*
-* @pdev:	platform device structure
-*
-* This function is called by OS when a device is unloaded
-* This frees the interrupt etc
-*/
-int sst_acpi_remove(struct platform_device *pdev)
-{
-	struct intel_sst_drv *ctx;
-
-	ctx = platform_get_drvdata(pdev);
-	sst_context_cleanup(ctx);
-	platform_set_drvdata(pdev, NULL);
-	return 0;
-}
-
-static struct sst_machines sst_acpi_bytcr[] = {
-	{"10EC5640", "T100", "bytt100_rt5640", NULL, "intel/fw_sst_0f28.bin",
-						&byt_rvp_platform_data },
-	{},
-};
-
-/* Cherryview-based platforms: CherryTrail and Braswell */
-static struct sst_machines sst_acpi_chv[] = {
-	{"10EC5670", "cht-bsw", "cht-bsw-rt5672", NULL, "intel/fw_sst_22a8.bin",
-						&chv_platform_data },
-	{},
-};
-
-static const struct acpi_device_id sst_acpi_ids[] = {
-	{ "80860F28", (unsigned long)&sst_acpi_bytcr},
-	{ "808622A8", (unsigned long) &sst_acpi_chv},
-	{ },
-};
-
-MODULE_DEVICE_TABLE(acpi, sst_acpi_ids);
-
-static struct platform_driver sst_acpi_driver = {
-	.driver = {
-		.name			= "intel_sst_acpi",
-		.owner			= THIS_MODULE,
-		.acpi_match_table	= ACPI_PTR(sst_acpi_ids),
-		.pm			= &intel_sst_pm,
-	},
-	.probe	= sst_acpi_probe,
-	.remove	= sst_acpi_remove,
-};
-
-module_platform_driver(sst_acpi_driver);
-
-MODULE_DESCRIPTION("Intel (R) SST(R) Audio Engine ACPI Driver");
-MODULE_AUTHOR("Ramesh Babu K V");
-MODULE_AUTHOR("Omair Mohammed Abdullah");
-MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("sst");
diff -Naur linux-3.19.old/sound/soc/intel/sst/sst.c linux-3.19/sound/soc/intel/sst/sst.c
--- linux-3.19.old/sound/soc/intel/sst/sst.c	2015-03-24 17:38:14.436510279 -0800
+++ linux-3.19/sound/soc/intel/sst/sst.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,437 +0,0 @@
-/*
- *  sst.c - Intel SST Driver for audio engine
- *
- *  Copyright (C) 2008-14	Intel Corp
- *  Authors:	Vinod Koul <vinod.koul@intel.com>
- *		Harsha Priya <priya.harsha@intel.com>
- *		Dharageswari R <dharageswari.r@intel.com>
- *		KP Jeeja <jeeja.kp@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/interrupt.h>
-#include <linux/firmware.h>
-#include <linux/pm_runtime.h>
-#include <linux/pm_qos.h>
-#include <linux/async.h>
-#include <linux/acpi.h>
-#include <sound/core.h>
-#include <sound/soc.h>
-#include <asm/platform_sst_audio.h>
-#include "../sst-mfld-platform.h"
-#include "sst.h"
-#include "../sst-dsp.h"
-
-MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
-MODULE_AUTHOR("Harsha Priya <priya.harsha@intel.com>");
-MODULE_DESCRIPTION("Intel (R) SST(R) Audio Engine Driver");
-MODULE_LICENSE("GPL v2");
-
-static inline bool sst_is_process_reply(u32 msg_id)
-{
-	return ((msg_id & PROCESS_MSG) ? true : false);
-}
-
-static inline bool sst_validate_mailbox_size(unsigned int size)
-{
-	return ((size <= SST_MAILBOX_SIZE) ? true : false);
-}
-
-static irqreturn_t intel_sst_interrupt_mrfld(int irq, void *context)
-{
-	union interrupt_reg_mrfld isr;
-	union ipc_header_mrfld header;
-	union sst_imr_reg_mrfld imr;
-	struct ipc_post *msg = NULL;
-	unsigned int size = 0;
-	struct intel_sst_drv *drv = (struct intel_sst_drv *) context;
-	irqreturn_t retval = IRQ_HANDLED;
-
-	/* Interrupt arrived, check src */
-	isr.full = sst_shim_read64(drv->shim, SST_ISRX);
-
-	if (isr.part.done_interrupt) {
-		/* Clear done bit */
-		spin_lock(&drv->ipc_spin_lock);
-		header.full = sst_shim_read64(drv->shim,
-					drv->ipc_reg.ipcx);
-		header.p.header_high.part.done = 0;
-		sst_shim_write64(drv->shim, drv->ipc_reg.ipcx, header.full);
-
-		/* write 1 to clear status register */;
-		isr.part.done_interrupt = 1;
-		sst_shim_write64(drv->shim, SST_ISRX, isr.full);
-		spin_unlock(&drv->ipc_spin_lock);
-
-		/* we can send more messages to DSP so trigger work */
-		queue_work(drv->post_msg_wq, &drv->ipc_post_msg_wq);
-		retval = IRQ_HANDLED;
-	}
-
-	if (isr.part.busy_interrupt) {
-		/* message from dsp so copy that */
-		spin_lock(&drv->ipc_spin_lock);
-		imr.full = sst_shim_read64(drv->shim, SST_IMRX);
-		imr.part.busy_interrupt = 1;
-		sst_shim_write64(drv->shim, SST_IMRX, imr.full);
-		spin_unlock(&drv->ipc_spin_lock);
-		header.full =  sst_shim_read64(drv->shim, drv->ipc_reg.ipcd);
-
-		if (sst_create_ipc_msg(&msg, header.p.header_high.part.large)) {
-			drv->ops->clear_interrupt(drv);
-			return IRQ_HANDLED;
-		}
-
-		if (header.p.header_high.part.large) {
-			size = header.p.header_low_payload;
-			if (sst_validate_mailbox_size(size)) {
-				memcpy_fromio(msg->mailbox_data,
-					drv->mailbox + drv->mailbox_recv_offset, size);
-			} else {
-				dev_err(drv->dev,
-					"Mailbox not copied, payload size is: %u\n", size);
-				header.p.header_low_payload = 0;
-			}
-		}
-
-		msg->mrfld_header = header;
-		msg->is_process_reply =
-			sst_is_process_reply(header.p.header_high.part.msg_id);
-		spin_lock(&drv->rx_msg_lock);
-		list_add_tail(&msg->node, &drv->rx_list);
-		spin_unlock(&drv->rx_msg_lock);
-		drv->ops->clear_interrupt(drv);
-		retval = IRQ_WAKE_THREAD;
-	}
-	return retval;
-}
-
-static irqreturn_t intel_sst_irq_thread_mrfld(int irq, void *context)
-{
-	struct intel_sst_drv *drv = (struct intel_sst_drv *) context;
-	struct ipc_post *__msg, *msg = NULL;
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&drv->rx_msg_lock, irq_flags);
-	if (list_empty(&drv->rx_list)) {
-		spin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);
-		return IRQ_HANDLED;
-	}
-
-	list_for_each_entry_safe(msg, __msg, &drv->rx_list, node) {
-		list_del(&msg->node);
-		spin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);
-		if (msg->is_process_reply)
-			drv->ops->process_message(msg);
-		else
-			drv->ops->process_reply(drv, msg);
-
-		if (msg->is_large)
-			kfree(msg->mailbox_data);
-		kfree(msg);
-		spin_lock_irqsave(&drv->rx_msg_lock, irq_flags);
-	}
-	spin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);
-	return IRQ_HANDLED;
-}
-
-static int sst_save_dsp_context_v2(struct intel_sst_drv *sst)
-{
-	int ret = 0;
-
-	ret = sst_prepare_and_post_msg(sst, SST_TASK_ID_MEDIA, IPC_CMD,
-			IPC_PREP_D3, PIPE_RSVD, 0, NULL, NULL,
-			true, true, false, true);
-
-	if (ret < 0) {
-		dev_err(sst->dev, "not suspending FW!!, Err: %d\n", ret);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-
-static struct intel_sst_ops mrfld_ops = {
-	.interrupt = intel_sst_interrupt_mrfld,
-	.irq_thread = intel_sst_irq_thread_mrfld,
-	.clear_interrupt = intel_sst_clear_intr_mrfld,
-	.start = sst_start_mrfld,
-	.reset = intel_sst_reset_dsp_mrfld,
-	.post_message = sst_post_message_mrfld,
-	.process_reply = sst_process_reply_mrfld,
-	.save_dsp_context =  sst_save_dsp_context_v2,
-	.alloc_stream = sst_alloc_stream_mrfld,
-	.post_download = sst_post_download_mrfld,
-};
-
-int sst_driver_ops(struct intel_sst_drv *sst)
-{
-
-	switch (sst->dev_id) {
-	case SST_MRFLD_PCI_ID:
-	case SST_BYT_ACPI_ID:
-	case SST_CHV_ACPI_ID:
-		sst->tstamp = SST_TIME_STAMP_MRFLD;
-		sst->ops = &mrfld_ops;
-		return 0;
-
-	default:
-		dev_err(sst->dev,
-			"SST Driver capablities missing for dev_id: %x", sst->dev_id);
-		return -EINVAL;
-	};
-}
-
-void sst_process_pending_msg(struct work_struct *work)
-{
-	struct intel_sst_drv *ctx = container_of(work,
-			struct intel_sst_drv, ipc_post_msg_wq);
-
-	ctx->ops->post_message(ctx, NULL, false);
-}
-
-static int sst_workqueue_init(struct intel_sst_drv *ctx)
-{
-	INIT_LIST_HEAD(&ctx->memcpy_list);
-	INIT_LIST_HEAD(&ctx->rx_list);
-	INIT_LIST_HEAD(&ctx->ipc_dispatch_list);
-	INIT_LIST_HEAD(&ctx->block_list);
-	INIT_WORK(&ctx->ipc_post_msg_wq, sst_process_pending_msg);
-	init_waitqueue_head(&ctx->wait_queue);
-
-	ctx->post_msg_wq =
-		create_singlethread_workqueue("sst_post_msg_wq");
-	if (!ctx->post_msg_wq)
-		return -EBUSY;
-	return 0;
-}
-
-static void sst_init_locks(struct intel_sst_drv *ctx)
-{
-	mutex_init(&ctx->sst_lock);
-	spin_lock_init(&ctx->rx_msg_lock);
-	spin_lock_init(&ctx->ipc_spin_lock);
-	spin_lock_init(&ctx->block_lock);
-}
-
-int sst_alloc_drv_context(struct intel_sst_drv **ctx,
-		struct device *dev, unsigned int dev_id)
-{
-	*ctx = devm_kzalloc(dev, sizeof(struct intel_sst_drv), GFP_KERNEL);
-	if (!(*ctx))
-		return -ENOMEM;
-
-	(*ctx)->dev = dev;
-	(*ctx)->dev_id = dev_id;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(sst_alloc_drv_context);
-
-int sst_context_init(struct intel_sst_drv *ctx)
-{
-	int ret = 0, i;
-
-	if (!ctx->pdata)
-		return -EINVAL;
-
-	if (!ctx->pdata->probe_data)
-		return -EINVAL;
-
-	memcpy(&ctx->info, ctx->pdata->probe_data, sizeof(ctx->info));
-
-	ret = sst_driver_ops(ctx);
-	if (ret != 0)
-		return -EINVAL;
-
-	sst_init_locks(ctx);
-	sst_set_fw_state_locked(ctx, SST_RESET);
-
-	/* pvt_id 0 reserved for async messages */
-	ctx->pvt_id = 1;
-	ctx->stream_cnt = 0;
-	ctx->fw_in_mem = NULL;
-	/* we use memcpy, so set to 0 */
-	ctx->use_dma = 0;
-	ctx->use_lli = 0;
-
-	if (sst_workqueue_init(ctx))
-		return -EINVAL;
-
-	ctx->mailbox_recv_offset = ctx->pdata->ipc_info->mbox_recv_off;
-	ctx->ipc_reg.ipcx = SST_IPCX + ctx->pdata->ipc_info->ipc_offset;
-	ctx->ipc_reg.ipcd = SST_IPCD + ctx->pdata->ipc_info->ipc_offset;
-
-	dev_info(ctx->dev, "Got drv data max stream %d\n",
-				ctx->info.max_streams);
-
-	for (i = 1; i <= ctx->info.max_streams; i++) {
-		struct stream_info *stream = &ctx->streams[i];
-
-		memset(stream, 0, sizeof(*stream));
-		stream->pipe_id = PIPE_RSVD;
-		mutex_init(&stream->lock);
-	}
-
-	/* Register the ISR */
-	ret = devm_request_threaded_irq(ctx->dev, ctx->irq_num, ctx->ops->interrupt,
-					ctx->ops->irq_thread, 0, SST_DRV_NAME,
-					ctx);
-	if (ret)
-		goto do_free_mem;
-
-	dev_dbg(ctx->dev, "Registered IRQ %#x\n", ctx->irq_num);
-
-	/* default intr are unmasked so set this as masked */
-	sst_shim_write64(ctx->shim, SST_IMRX, 0xFFFF0038);
-
-	ctx->qos = devm_kzalloc(ctx->dev,
-		sizeof(struct pm_qos_request), GFP_KERNEL);
-	if (!ctx->qos) {
-		ret = -ENOMEM;
-		goto do_free_mem;
-	}
-	pm_qos_add_request(ctx->qos, PM_QOS_CPU_DMA_LATENCY,
-				PM_QOS_DEFAULT_VALUE);
-
-	dev_dbg(ctx->dev, "Requesting FW %s now...\n", ctx->firmware_name);
-	ret = request_firmware_nowait(THIS_MODULE, true, ctx->firmware_name,
-				      ctx->dev, GFP_KERNEL, ctx, sst_firmware_load_cb);
-	if (ret) {
-		dev_err(ctx->dev, "Firmware download failed:%d\n", ret);
-		goto do_free_mem;
-	}
-	sst_register(ctx->dev);
-	return 0;
-
-do_free_mem:
-	destroy_workqueue(ctx->post_msg_wq);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(sst_context_init);
-
-void sst_context_cleanup(struct intel_sst_drv *ctx)
-{
-	pm_runtime_get_noresume(ctx->dev);
-	pm_runtime_disable(ctx->dev);
-	sst_unregister(ctx->dev);
-	sst_set_fw_state_locked(ctx, SST_SHUTDOWN);
-	flush_scheduled_work();
-	destroy_workqueue(ctx->post_msg_wq);
-	pm_qos_remove_request(ctx->qos);
-	kfree(ctx->fw_sg_list.src);
-	kfree(ctx->fw_sg_list.dst);
-	ctx->fw_sg_list.list_len = 0;
-	kfree(ctx->fw_in_mem);
-	ctx->fw_in_mem = NULL;
-	sst_memcpy_free_resources(ctx);
-	ctx = NULL;
-}
-EXPORT_SYMBOL_GPL(sst_context_cleanup);
-
-static inline void sst_save_shim64(struct intel_sst_drv *ctx,
-			    void __iomem *shim,
-			    struct sst_shim_regs64 *shim_regs)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&ctx->ipc_spin_lock, irq_flags);
-
-	shim_regs->imrx = sst_shim_read64(shim, SST_IMRX),
-
-	spin_unlock_irqrestore(&ctx->ipc_spin_lock, irq_flags);
-}
-
-static inline void sst_restore_shim64(struct intel_sst_drv *ctx,
-				      void __iomem *shim,
-				      struct sst_shim_regs64 *shim_regs)
-{
-	unsigned long irq_flags;
-
-	/*
-	 * we only need to restore IMRX for this case, rest will be
-	 * initialize by FW or driver when firmware is loaded
-	 */
-	spin_lock_irqsave(&ctx->ipc_spin_lock, irq_flags);
-	sst_shim_write64(shim, SST_IMRX, shim_regs->imrx),
-	spin_unlock_irqrestore(&ctx->ipc_spin_lock, irq_flags);
-}
-
-void sst_configure_runtime_pm(struct intel_sst_drv *ctx)
-{
-	pm_runtime_set_autosuspend_delay(ctx->dev, SST_SUSPEND_DELAY);
-	pm_runtime_use_autosuspend(ctx->dev);
-	/*
-	 * For acpi devices, the actual physical device state is
-	 * initially active. So change the state to active before
-	 * enabling the pm
-	 */
-	pm_runtime_enable(ctx->dev);
-
-	if (acpi_disabled)
-		pm_runtime_set_active(ctx->dev);
-	else
-		pm_runtime_put_noidle(ctx->dev);
-
-	sst_save_shim64(ctx, ctx->shim, ctx->shim_regs64);
-}
-EXPORT_SYMBOL_GPL(sst_configure_runtime_pm);
-
-static int intel_sst_runtime_suspend(struct device *dev)
-{
-	int ret = 0;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	if (ctx->sst_state == SST_RESET) {
-		dev_dbg(dev, "LPE is already in RESET state, No action\n");
-		return 0;
-	}
-	/* save fw context */
-	if (ctx->ops->save_dsp_context(ctx))
-		return -EBUSY;
-
-	/* Move the SST state to Reset */
-	sst_set_fw_state_locked(ctx, SST_RESET);
-
-	synchronize_irq(ctx->irq_num);
-	flush_workqueue(ctx->post_msg_wq);
-
-	/* save the shim registers because PMC doesn't save state */
-	sst_save_shim64(ctx, ctx->shim, ctx->shim_regs64);
-
-	return ret;
-}
-
-static int intel_sst_runtime_resume(struct device *dev)
-{
-	int ret = 0;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	if (ctx->sst_state == SST_RESET) {
-		ret = sst_load_fw(ctx);
-		if (ret) {
-			dev_err(dev, "FW download fail %d\n", ret);
-			sst_set_fw_state_locked(ctx, SST_RESET);
-		}
-	}
-	return ret;
-}
-
-const struct dev_pm_ops intel_sst_pm = {
-	.runtime_suspend = intel_sst_runtime_suspend,
-	.runtime_resume = intel_sst_runtime_resume,
-};
-EXPORT_SYMBOL_GPL(intel_sst_pm);
diff -Naur linux-3.19.old/sound/soc/intel/sst/sst_drv_interface.c linux-3.19/sound/soc/intel/sst/sst_drv_interface.c
--- linux-3.19.old/sound/soc/intel/sst/sst_drv_interface.c	2015-03-24 17:38:14.436510279 -0800
+++ linux-3.19/sound/soc/intel/sst/sst_drv_interface.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,686 +0,0 @@
-/*
- *  sst_drv_interface.c - Intel SST Driver for audio engine
- *
- *  Copyright (C) 2008-14 Intel Corp
- *  Authors:	Vinod Koul <vinod.koul@intel.com>
- *		Harsha Priya <priya.harsha@intel.com>
- *		Dharageswari R <dharageswari.r@intel.com)
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-#include <linux/delay.h>
-#include <linux/pci.h>
-#include <linux/fs.h>
-#include <linux/firmware.h>
-#include <linux/pm_runtime.h>
-#include <linux/pm_qos.h>
-#include <linux/math64.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/soc.h>
-#include <sound/compress_driver.h>
-#include <asm/platform_sst_audio.h>
-#include "../sst-mfld-platform.h"
-#include "sst.h"
-#include "../sst-dsp.h"
-
-
-
-#define NUM_CODEC 2
-#define MIN_FRAGMENT 2
-#define MAX_FRAGMENT 4
-#define MIN_FRAGMENT_SIZE (50 * 1024)
-#define MAX_FRAGMENT_SIZE (1024 * 1024)
-#define SST_GET_BYTES_PER_SAMPLE(pcm_wd_sz)  (((pcm_wd_sz + 15) >> 4) << 1)
-
-int free_stream_context(struct intel_sst_drv *ctx, unsigned int str_id)
-{
-	struct stream_info *stream;
-	int ret = 0;
-
-	stream = get_stream_info(ctx, str_id);
-	if (stream) {
-		/* str_id is valid, so stream is alloacted */
-		ret = sst_free_stream(ctx, str_id);
-		if (ret)
-			sst_clean_stream(&ctx->streams[str_id]);
-		return ret;
-	} else {
-		dev_err(ctx->dev, "we tried to free stream context %d which was freed!!!\n", str_id);
-	}
-	return ret;
-}
-
-int sst_get_stream_allocated(struct intel_sst_drv *ctx,
-	struct snd_sst_params *str_param,
-	struct snd_sst_lib_download **lib_dnld)
-{
-	int retval;
-
-	retval = ctx->ops->alloc_stream(ctx, str_param);
-	if (retval > 0)
-		dev_dbg(ctx->dev, "Stream allocated %d\n", retval);
-	return retval;
-
-}
-
-/*
- * sst_get_sfreq - this function returns the frequency of the stream
- *
- * @str_param : stream params
- */
-int sst_get_sfreq(struct snd_sst_params *str_param)
-{
-	switch (str_param->codec) {
-	case SST_CODEC_TYPE_PCM:
-		return str_param->sparams.uc.pcm_params.sfreq;
-	case SST_CODEC_TYPE_AAC:
-		return str_param->sparams.uc.aac_params.externalsr;
-	case SST_CODEC_TYPE_MP3:
-		return 0;
-	default:
-		return -EINVAL;
-	}
-}
-
-/*
- * sst_get_num_channel - get number of channels for the stream
- *
- * @str_param : stream params
- */
-int sst_get_num_channel(struct snd_sst_params *str_param)
-{
-	switch (str_param->codec) {
-	case SST_CODEC_TYPE_PCM:
-		return str_param->sparams.uc.pcm_params.num_chan;
-	case SST_CODEC_TYPE_MP3:
-		return str_param->sparams.uc.mp3_params.num_chan;
-	case SST_CODEC_TYPE_AAC:
-		return str_param->sparams.uc.aac_params.num_chan;
-	default:
-		return -EINVAL;
-	}
-}
-
-/*
- * sst_get_stream - this function prepares for stream allocation
- *
- * @str_param : stream param
- */
-int sst_get_stream(struct intel_sst_drv *ctx,
-			struct snd_sst_params *str_param)
-{
-	int retval;
-	struct stream_info *str_info;
-
-	/* stream is not allocated, we are allocating */
-	retval = ctx->ops->alloc_stream(ctx, str_param);
-	if (retval <= 0) {
-		return -EIO;
-	}
-	/* store sampling freq */
-	str_info = &ctx->streams[retval];
-	str_info->sfreq = sst_get_sfreq(str_param);
-
-	return retval;
-}
-
-static int sst_power_control(struct device *dev, bool state)
-{
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	dev_dbg(ctx->dev, "state:%d", state);
-	if (state == true)
-		return pm_runtime_get_sync(dev);
-	else
-		return sst_pm_runtime_put(ctx);
-}
-
-/*
- * sst_open_pcm_stream - Open PCM interface
- *
- * @str_param: parameters of pcm stream
- *
- * This function is called by MID sound card driver to open
- * a new pcm interface
- */
-static int sst_open_pcm_stream(struct device *dev,
-		struct snd_sst_params *str_param)
-{
-	int retval;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	if (!str_param)
-		return -EINVAL;
-
-	retval = sst_get_stream(ctx, str_param);
-	if (retval > 0)
-		ctx->stream_cnt++;
-	else
-		dev_err(ctx->dev, "sst_get_stream returned err %d\n", retval);
-
-	return retval;
-}
-
-static int sst_cdev_open(struct device *dev,
-		struct snd_sst_params *str_params, struct sst_compress_cb *cb)
-{
-	int str_id, retval;
-	struct stream_info *stream;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	retval = pm_runtime_get_sync(ctx->dev);
-	if (retval < 0)
-		return retval;
-
-	str_id = sst_get_stream(ctx, str_params);
-	if (str_id > 0) {
-		dev_dbg(dev, "stream allocated in sst_cdev_open %d\n", str_id);
-		stream = &ctx->streams[str_id];
-		stream->compr_cb = cb->compr_cb;
-		stream->compr_cb_param = cb->param;
-		stream->drain_notify = cb->drain_notify;
-		stream->drain_cb_param = cb->drain_cb_param;
-	} else {
-		dev_err(dev, "stream encountered error during alloc %d\n", str_id);
-		str_id = -EINVAL;
-		sst_pm_runtime_put(ctx);
-	}
-	return str_id;
-}
-
-static int sst_cdev_close(struct device *dev, unsigned int str_id)
-{
-	int retval;
-	struct stream_info *stream;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	stream = get_stream_info(ctx, str_id);
-	if (!stream) {
-		dev_err(dev, "stream info is NULL for str %d!!!\n", str_id);
-		return -EINVAL;
-	}
-
-	if (stream->status == STREAM_RESET) {
-		dev_dbg(dev, "stream in reset state...\n");
-		stream->status = STREAM_UN_INIT;
-
-		retval = 0;
-		goto put;
-	}
-
-	retval = sst_free_stream(ctx, str_id);
-put:
-	stream->compr_cb_param = NULL;
-	stream->compr_cb = NULL;
-
-	if (retval)
-		dev_err(dev, "free stream returned err %d\n", retval);
-
-	dev_dbg(dev, "End\n");
-	return retval;
-
-}
-
-static int sst_cdev_ack(struct device *dev, unsigned int str_id,
-		unsigned long bytes)
-{
-	struct stream_info *stream;
-	struct snd_sst_tstamp fw_tstamp = {0,};
-	int offset;
-	void __iomem *addr;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	stream = get_stream_info(ctx, str_id);
-	if (!stream)
-		return -EINVAL;
-
-	/* update bytes sent */
-	stream->cumm_bytes += bytes;
-	dev_dbg(dev, "bytes copied %d inc by %ld\n", stream->cumm_bytes, bytes);
-
-	memcpy_fromio(&fw_tstamp,
-		((void *)(ctx->mailbox + ctx->tstamp)
-		+(str_id * sizeof(fw_tstamp))),
-		sizeof(fw_tstamp));
-
-	fw_tstamp.bytes_copied = stream->cumm_bytes;
-	dev_dbg(dev, "bytes sent to fw %llu inc by %ld\n",
-			fw_tstamp.bytes_copied, bytes);
-
-	addr =  ((void *)(ctx->mailbox + ctx->tstamp)) +
-			(str_id * sizeof(fw_tstamp));
-	offset =  offsetof(struct snd_sst_tstamp, bytes_copied);
-	sst_shim_write(addr, offset, fw_tstamp.bytes_copied);
-	return 0;
-}
-
-static int sst_cdev_set_metadata(struct device *dev,
-		unsigned int str_id, struct snd_compr_metadata *metadata)
-{
-	int retval = 0;
-	struct stream_info *str_info;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	dev_dbg(dev, "set metadata for stream %d\n", str_id);
-
-	str_info = get_stream_info(ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-
-	dev_dbg(dev, "pipe id = %d\n", str_info->pipe_id);
-	retval = sst_prepare_and_post_msg(ctx, str_info->task_id, IPC_CMD,
-			IPC_IA_SET_STREAM_PARAMS_MRFLD, str_info->pipe_id,
-			sizeof(*metadata), metadata, NULL,
-			true, true, true, false);
-
-	return retval;
-}
-
-static int sst_cdev_stream_pause(struct device *dev, unsigned int str_id)
-{
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	return sst_pause_stream(ctx, str_id);
-}
-
-static int sst_cdev_stream_pause_release(struct device *dev,
-		unsigned int str_id)
-{
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	return sst_resume_stream(ctx, str_id);
-}
-
-static int sst_cdev_stream_start(struct device *dev, unsigned int str_id)
-{
-	struct stream_info *str_info;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	str_info = get_stream_info(ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-	str_info->prev = str_info->status;
-	str_info->status = STREAM_RUNNING;
-	return sst_start_stream(ctx, str_id);
-}
-
-static int sst_cdev_stream_drop(struct device *dev, unsigned int str_id)
-{
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	return sst_drop_stream(ctx, str_id);
-}
-
-static int sst_cdev_stream_drain(struct device *dev, unsigned int str_id)
-{
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	return sst_drain_stream(ctx, str_id, false);
-}
-
-static int sst_cdev_stream_partial_drain(struct device *dev,
-		unsigned int str_id)
-{
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	return sst_drain_stream(ctx, str_id, true);
-}
-
-static int sst_cdev_tstamp(struct device *dev, unsigned int str_id,
-		struct snd_compr_tstamp *tstamp)
-{
-	struct snd_sst_tstamp fw_tstamp = {0,};
-	struct stream_info *stream;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	memcpy_fromio(&fw_tstamp,
-		((void *)(ctx->mailbox + ctx->tstamp)
-		+(str_id * sizeof(fw_tstamp))),
-		sizeof(fw_tstamp));
-
-	stream = get_stream_info(ctx, str_id);
-	if (!stream)
-		return -EINVAL;
-	dev_dbg(dev, "rb_counter %llu in bytes\n", fw_tstamp.ring_buffer_counter);
-
-	tstamp->copied_total = fw_tstamp.ring_buffer_counter;
-	tstamp->pcm_frames = fw_tstamp.frames_decoded;
-	tstamp->pcm_io_frames = div_u64(fw_tstamp.hardware_counter,
-			(u64)((stream->num_ch) * SST_GET_BYTES_PER_SAMPLE(24)));
-	tstamp->sampling_rate = fw_tstamp.sampling_frequency;
-
-	dev_dbg(dev, "PCM  = %u\n", tstamp->pcm_io_frames);
-	dev_dbg(dev, "Ptr Query on strid = %d  copied_total %d, decodec %d\n",
-		str_id, tstamp->copied_total, tstamp->pcm_frames);
-	dev_dbg(dev, "rendered %d\n", tstamp->pcm_io_frames);
-
-	return 0;
-}
-
-static int sst_cdev_caps(struct snd_compr_caps *caps)
-{
-	caps->num_codecs = NUM_CODEC;
-	caps->min_fragment_size = MIN_FRAGMENT_SIZE;  /* 50KB */
-	caps->max_fragment_size = MAX_FRAGMENT_SIZE;  /* 1024KB */
-	caps->min_fragments = MIN_FRAGMENT;
-	caps->max_fragments = MAX_FRAGMENT;
-	caps->codecs[0] = SND_AUDIOCODEC_MP3;
-	caps->codecs[1] = SND_AUDIOCODEC_AAC;
-	return 0;
-}
-
-static struct snd_compr_codec_caps caps_mp3 = {
-	.num_descriptors = 1,
-	.descriptor[0].max_ch = 2,
-	.descriptor[0].sample_rates[0] = 48000,
-	.descriptor[0].sample_rates[1] = 44100,
-	.descriptor[0].sample_rates[2] = 32000,
-	.descriptor[0].sample_rates[3] = 16000,
-	.descriptor[0].sample_rates[4] = 8000,
-	.descriptor[0].num_sample_rates = 5,
-	.descriptor[0].bit_rate[0] = 320,
-	.descriptor[0].bit_rate[1] = 192,
-	.descriptor[0].num_bitrates = 2,
-	.descriptor[0].profiles = 0,
-	.descriptor[0].modes = SND_AUDIOCHANMODE_MP3_STEREO,
-	.descriptor[0].formats = 0,
-};
-
-static struct snd_compr_codec_caps caps_aac = {
-	.num_descriptors = 2,
-	.descriptor[1].max_ch = 2,
-	.descriptor[0].sample_rates[0] = 48000,
-	.descriptor[0].sample_rates[1] = 44100,
-	.descriptor[0].sample_rates[2] = 32000,
-	.descriptor[0].sample_rates[3] = 16000,
-	.descriptor[0].sample_rates[4] = 8000,
-	.descriptor[0].num_sample_rates = 5,
-	.descriptor[1].bit_rate[0] = 320,
-	.descriptor[1].bit_rate[1] = 192,
-	.descriptor[1].num_bitrates = 2,
-	.descriptor[1].profiles = 0,
-	.descriptor[1].modes = 0,
-	.descriptor[1].formats =
-			(SND_AUDIOSTREAMFORMAT_MP4ADTS |
-				SND_AUDIOSTREAMFORMAT_RAW),
-};
-
-static int sst_cdev_codec_caps(struct snd_compr_codec_caps *codec)
-{
-	if (codec->codec == SND_AUDIOCODEC_MP3)
-		*codec = caps_mp3;
-	else if (codec->codec == SND_AUDIOCODEC_AAC)
-		*codec = caps_aac;
-	else
-		return -EINVAL;
-
-	return 0;
-}
-
-void sst_cdev_fragment_elapsed(struct intel_sst_drv *ctx, int str_id)
-{
-	struct stream_info *stream;
-
-	dev_dbg(ctx->dev, "fragment elapsed from firmware for str_id %d\n",
-			str_id);
-	stream = &ctx->streams[str_id];
-	if (stream->compr_cb)
-		stream->compr_cb(stream->compr_cb_param);
-}
-
-/*
- * sst_close_pcm_stream - Close PCM interface
- *
- * @str_id: stream id to be closed
- *
- * This function is called by MID sound card driver to close
- * an existing pcm interface
- */
-static int sst_close_pcm_stream(struct device *dev, unsigned int str_id)
-{
-	struct stream_info *stream;
-	int retval = 0;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	stream = get_stream_info(ctx, str_id);
-	if (!stream) {
-		dev_err(ctx->dev, "stream info is NULL for str %d!!!\n", str_id);
-		return -EINVAL;
-	}
-
-	if (stream->status == STREAM_RESET) {
-		/* silently fail here as we have cleaned the stream earlier */
-		dev_dbg(ctx->dev, "stream in reset state...\n");
-
-		retval = 0;
-		goto put;
-	}
-
-	retval = free_stream_context(ctx, str_id);
-put:
-	stream->pcm_substream = NULL;
-	stream->status = STREAM_UN_INIT;
-	stream->period_elapsed = NULL;
-	ctx->stream_cnt--;
-
-	if (retval)
-		dev_err(ctx->dev, "free stream returned err %d\n", retval);
-
-	dev_dbg(ctx->dev, "Exit\n");
-	return 0;
-}
-
-static inline int sst_calc_tstamp(struct intel_sst_drv *ctx,
-		struct pcm_stream_info *info,
-		struct snd_pcm_substream *substream,
-		struct snd_sst_tstamp *fw_tstamp)
-{
-	size_t delay_bytes, delay_frames;
-	size_t buffer_sz;
-	u32 pointer_bytes, pointer_samples;
-
-	dev_dbg(ctx->dev, "mrfld ring_buffer_counter %llu in bytes\n",
-			fw_tstamp->ring_buffer_counter);
-	dev_dbg(ctx->dev, "mrfld hardware_counter %llu in bytes\n",
-			 fw_tstamp->hardware_counter);
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		delay_bytes = (size_t) (fw_tstamp->ring_buffer_counter -
-					fw_tstamp->hardware_counter);
-	else
-		delay_bytes = (size_t) (fw_tstamp->hardware_counter -
-					fw_tstamp->ring_buffer_counter);
-	delay_frames = bytes_to_frames(substream->runtime, delay_bytes);
-	buffer_sz = snd_pcm_lib_buffer_bytes(substream);
-	div_u64_rem(fw_tstamp->ring_buffer_counter, buffer_sz, &pointer_bytes);
-	pointer_samples = bytes_to_samples(substream->runtime, pointer_bytes);
-
-	dev_dbg(ctx->dev, "pcm delay %zu in bytes\n", delay_bytes);
-
-	info->buffer_ptr = pointer_samples / substream->runtime->channels;
-
-	info->pcm_delay = delay_frames / substream->runtime->channels;
-	dev_dbg(ctx->dev, "buffer ptr %llu pcm_delay rep: %llu\n",
-			info->buffer_ptr, info->pcm_delay);
-	return 0;
-}
-
-static int sst_read_timestamp(struct device *dev, struct pcm_stream_info *info)
-{
-	struct stream_info *stream;
-	struct snd_pcm_substream *substream;
-	struct snd_sst_tstamp fw_tstamp;
-	unsigned int str_id;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	str_id = info->str_id;
-	stream = get_stream_info(ctx, str_id);
-	if (!stream)
-		return -EINVAL;
-
-	if (!stream->pcm_substream)
-		return -EINVAL;
-	substream = stream->pcm_substream;
-
-	memcpy_fromio(&fw_tstamp,
-		((void *)(ctx->mailbox + ctx->tstamp)
-			+ (str_id * sizeof(fw_tstamp))),
-		sizeof(fw_tstamp));
-	return sst_calc_tstamp(ctx, info, substream, &fw_tstamp);
-}
-
-static int sst_stream_start(struct device *dev, int str_id)
-{
-	struct stream_info *str_info;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	if (ctx->sst_state != SST_FW_RUNNING)
-		return 0;
-	str_info = get_stream_info(ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-	str_info->prev = str_info->status;
-	str_info->status = STREAM_RUNNING;
-	sst_start_stream(ctx, str_id);
-
-	return 0;
-}
-
-static int sst_stream_drop(struct device *dev, int str_id)
-{
-	struct stream_info *str_info;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	if (ctx->sst_state != SST_FW_RUNNING)
-		return 0;
-
-	str_info = get_stream_info(ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-	str_info->prev = STREAM_UN_INIT;
-	str_info->status = STREAM_INIT;
-	return sst_drop_stream(ctx, str_id);
-}
-
-static int sst_stream_init(struct device *dev, struct pcm_stream_info *str_info)
-{
-	int str_id = 0;
-	struct stream_info *stream;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	str_id = str_info->str_id;
-
-	if (ctx->sst_state != SST_FW_RUNNING)
-		return 0;
-
-	stream = get_stream_info(ctx, str_id);
-	if (!stream)
-		return -EINVAL;
-
-	dev_dbg(ctx->dev, "setting the period ptrs\n");
-	stream->pcm_substream = str_info->arg;
-	stream->period_elapsed = str_info->period_elapsed;
-	stream->sfreq = str_info->sfreq;
-	stream->prev = stream->status;
-	stream->status = STREAM_INIT;
-	dev_dbg(ctx->dev,
-		"pcm_substream %p, period_elapsed %p, sfreq %d, status %d\n",
-		stream->pcm_substream, stream->period_elapsed,
-		stream->sfreq, stream->status);
-
-	return 0;
-}
-
-/*
- * sst_set_byte_stream - Set generic params
- *
- * @cmd: control cmd to be set
- * @arg: command argument
- *
- * This function is called by MID sound card driver to configure
- * SST runtime params.
- */
-static int sst_send_byte_stream(struct device *dev,
-		struct snd_sst_bytes_v2 *bytes)
-{
-	int ret_val = 0;
-	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
-
-	if (NULL == bytes)
-		return -EINVAL;
-	ret_val = pm_runtime_get_sync(ctx->dev);
-	if (ret_val < 0)
-		return ret_val;
-
-	ret_val = sst_send_byte_stream_mrfld(ctx, bytes);
-	sst_pm_runtime_put(ctx);
-
-	return ret_val;
-}
-
-static struct sst_ops pcm_ops = {
-	.open = sst_open_pcm_stream,
-	.stream_init = sst_stream_init,
-	.stream_start = sst_stream_start,
-	.stream_drop = sst_stream_drop,
-	.stream_read_tstamp = sst_read_timestamp,
-	.send_byte_stream = sst_send_byte_stream,
-	.close = sst_close_pcm_stream,
-	.power = sst_power_control,
-};
-
-static struct compress_sst_ops compr_ops = {
-	.open = sst_cdev_open,
-	.close = sst_cdev_close,
-	.stream_pause = sst_cdev_stream_pause,
-	.stream_pause_release = sst_cdev_stream_pause_release,
-	.stream_start = sst_cdev_stream_start,
-	.stream_drop = sst_cdev_stream_drop,
-	.stream_drain = sst_cdev_stream_drain,
-	.stream_partial_drain = sst_cdev_stream_partial_drain,
-	.tstamp = sst_cdev_tstamp,
-	.ack = sst_cdev_ack,
-	.get_caps = sst_cdev_caps,
-	.get_codec_caps = sst_cdev_codec_caps,
-	.set_metadata = sst_cdev_set_metadata,
-	.power = sst_power_control,
-};
-
-static struct sst_device sst_dsp_device = {
-	.name = "Intel(R) SST LPE",
-	.dev = NULL,
-	.ops = &pcm_ops,
-	.compr_ops = &compr_ops,
-};
-
-/*
- * sst_register - function to register DSP
- *
- * This functions registers DSP with the platform driver
- */
-int sst_register(struct device *dev)
-{
-	int ret_val;
-
-	sst_dsp_device.dev = dev;
-	ret_val = sst_register_dsp(&sst_dsp_device);
-	if (ret_val)
-		dev_err(dev, "Unable to register DSP with platform driver\n");
-
-	return ret_val;
-}
-
-int sst_unregister(struct device *dev)
-{
-	return sst_unregister_dsp(&sst_dsp_device);
-}
diff -Naur linux-3.19.old/sound/soc/intel/sst/sst.h linux-3.19/sound/soc/intel/sst/sst.h
--- linux-3.19.old/sound/soc/intel/sst/sst.h	2015-03-24 20:39:24.433135064 -0800
+++ linux-3.19/sound/soc/intel/sst/sst.h	1969-12-31 14:00:00.000000000 -1000
@@ -1,547 +0,0 @@
-/*
- *  sst.h - Intel SST Driver for audio engine
- *
- *  Copyright (C) 2008-14 Intel Corporation
- *  Authors:	Vinod Koul <vinod.koul@intel.com>
- *		Harsha Priya <priya.harsha@intel.com>
- *		Dharageswari R <dharageswari.r@intel.com>
- *		KP Jeeja <jeeja.kp@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  Common private declarations for SST
- */
-#ifndef __SST_H__
-#define __SST_H__
-
-#include <linux/firmware.h>
-
-/* driver names */
-#define SST_DRV_NAME "intel_sst_driver"
-#define SST_MRFLD_PCI_ID 0x119A
-#define SST_BYT_ACPI_ID	0x80860F28
-#define SST_CHV_ACPI_ID	0x808622A8
-
-#define SST_SUSPEND_DELAY 2000
-#define FW_CONTEXT_MEM (64*1024)
-#define SST_ICCM_BOUNDARY 4
-#define SST_CONFIG_SSP_SIGN 0x7ffe8001
-
-#define MRFLD_FW_VIRTUAL_BASE 0xC0000000
-#define MRFLD_FW_DDR_BASE_OFFSET 0x0
-#define MRFLD_FW_FEATURE_BASE_OFFSET 0x4
-#define MRFLD_FW_BSS_RESET_BIT 0
-
-extern const struct dev_pm_ops intel_sst_pm;
-enum sst_states {
-	SST_FW_LOADING = 1,
-	SST_FW_RUNNING,
-	SST_RESET,
-	SST_SHUTDOWN,
-};
-
-enum sst_algo_ops {
-	SST_SET_ALGO = 0,
-	SST_GET_ALGO = 1,
-};
-
-#define SST_BLOCK_TIMEOUT	1000
-
-#define FW_SIGNATURE_SIZE	4
-#define FW_NAME_SIZE		32
-
-/* stream states */
-enum sst_stream_states {
-	STREAM_UN_INIT	= 0,	/* Freed/Not used stream */
-	STREAM_RUNNING	= 1,	/* Running */
-	STREAM_PAUSED	= 2,	/* Paused stream */
-	STREAM_DECODE	= 3,	/* stream is in decoding only state */
-	STREAM_INIT	= 4,	/* stream init, waiting for data */
-	STREAM_RESET	= 5,	/* force reset on recovery */
-};
-
-enum sst_ram_type {
-	SST_IRAM	= 1,
-	SST_DRAM	= 2,
-	SST_DDR	= 5,
-	SST_CUSTOM_INFO	= 7,	/* consists of FW binary information */
-};
-
-/* SST shim registers to structure mapping */
-union interrupt_reg {
-	struct {
-		u64 done_interrupt:1;
-		u64 busy_interrupt:1;
-		u64 rsvd:62;
-	} part;
-	u64 full;
-};
-
-union sst_pisr_reg {
-	struct {
-		u32 pssp0:1;
-		u32 pssp1:1;
-		u32 rsvd0:3;
-		u32 dmac:1;
-		u32 rsvd1:26;
-	} part;
-	u32 full;
-};
-
-union sst_pimr_reg {
-	struct {
-		u32 ssp0:1;
-		u32 ssp1:1;
-		u32 rsvd0:3;
-		u32 dmac:1;
-		u32 rsvd1:10;
-		u32 ssp0_sc:1;
-		u32 ssp1_sc:1;
-		u32 rsvd2:3;
-		u32 dmac_sc:1;
-		u32 rsvd3:10;
-	} part;
-	u32 full;
-};
-
-union config_status_reg_mrfld {
-	struct {
-		u64 lpe_reset:1;
-		u64 lpe_reset_vector:1;
-		u64 runstall:1;
-		u64 pwaitmode:1;
-		u64 clk_sel:3;
-		u64 rsvd2:1;
-		u64 sst_clk:3;
-		u64 xt_snoop:1;
-		u64 rsvd3:4;
-		u64 clk_sel1:6;
-		u64 clk_enable:3;
-		u64 rsvd4:6;
-		u64 slim0baseclk:1;
-		u64 rsvd:32;
-	} part;
-	u64 full;
-};
-
-union interrupt_reg_mrfld {
-	struct {
-		u64 done_interrupt:1;
-		u64 busy_interrupt:1;
-		u64 rsvd:62;
-	} part;
-	u64 full;
-};
-
-union sst_imr_reg_mrfld {
-	struct {
-		u64 done_interrupt:1;
-		u64 busy_interrupt:1;
-		u64 rsvd:62;
-	} part;
-	u64 full;
-};
-
-/**
- * struct sst_block - This structure is used to block a user/fw data call to another
- * fw/user call
- *
- * @condition: condition for blocking check
- * @ret_code: ret code when block is released
- * @data: data ptr
- * @size: size of data
- * @on: block condition
- * @msg_id: msg_id = msgid in mfld/ctp, mrfld = NULL
- * @drv_id: str_id in mfld/ctp, = drv_id in mrfld
- * @node: list head node
- */
-struct sst_block {
-	bool	condition;
-	int	ret_code;
-	void	*data;
-	u32     size;
-	bool	on;
-	u32     msg_id;
-	u32     drv_id;
-	struct list_head node;
-};
-
-/**
- * struct stream_info - structure that holds the stream information
- *
- * @status : stream current state
- * @prev : stream prev state
- * @ops : stream operation pb/cp/drm...
- * @bufs: stream buffer list
- * @lock : stream mutex for protecting state
- * @pcm_substream : PCM substream
- * @period_elapsed : PCM period elapsed callback
- * @sfreq : stream sampling freq
- * @str_type : stream type
- * @cumm_bytes : cummulative bytes decoded
- * @str_type : stream type
- * @src : stream source
- */
-struct stream_info {
-	unsigned int		status;
-	unsigned int		prev;
-	unsigned int		ops;
-	struct mutex		lock;
-
-	void			*pcm_substream;
-	void (*period_elapsed)(void *pcm_substream);
-
-	unsigned int		sfreq;
-	u32			cumm_bytes;
-
-	void			*compr_cb_param;
-	void (*compr_cb)(void *compr_cb_param);
-
-	void			*drain_cb_param;
-	void (*drain_notify)(void *drain_cb_param);
-
-	unsigned int		num_ch;
-	unsigned int		pipe_id;
-	unsigned int		str_id;
-	unsigned int		task_id;
-};
-
-#define SST_FW_SIGN "$SST"
-#define SST_FW_LIB_SIGN "$LIB"
-
-/**
- * struct sst_fw_header - FW file headers
- *
- * @signature : FW signature
- * @file_size: size of fw image
- * @modules : # of modules
- * @file_format : version of header format
- * @reserved : reserved fields
- */
-struct sst_fw_header {
-	unsigned char signature[FW_SIGNATURE_SIZE];
-	u32 file_size;
-	u32 modules;
-	u32 file_format;
-	u32 reserved[4];
-};
-
-/**
- * struct fw_module_header - module header in FW
- *
- * @signature: module signature
- * @mod_size: size of module
- * @blocks: block count
- * @type: block type
- * @entry_point: module netry point
- */
-struct fw_module_header {
-	unsigned char signature[FW_SIGNATURE_SIZE];
-	u32 mod_size;
-	u32 blocks;
-	u32 type;
-	u32 entry_point;
-};
-
-/**
- * struct fw_block_info - block header for FW
- *
- * @type: block ram type I/D
- * @size: size of block
- * @ram_offset: offset in ram
- */
-struct fw_block_info {
-	enum sst_ram_type	type;
-	u32			size;
-	u32			ram_offset;
-	u32			rsvd;
-};
-
-struct sst_runtime_param {
-	struct snd_sst_runtime_params param;
-};
-
-struct sst_sg_list {
-	struct scatterlist *src;
-	struct scatterlist *dst;
-	int list_len;
-	unsigned int sg_idx;
-};
-
-struct sst_memcpy_list {
-	struct list_head memcpylist;
-	void *dstn;
-	const void *src;
-	u32 size;
-	bool is_io;
-};
-
-/*Firmware Module Information*/
-enum sst_lib_dwnld_status {
-	SST_LIB_NOT_FOUND = 0,
-	SST_LIB_FOUND,
-	SST_LIB_DOWNLOADED,
-};
-
-struct sst_module_info {
-	const char *name; /*Library name*/
-	u32	id; /*Module ID*/
-	u32	entry_pt; /*Module entry point*/
-	u8	status; /*module status*/
-	u8	rsvd1;
-	u16	rsvd2;
-};
-
-/*
- * Structure for managing the Library Region(1.5MB)
- * in DDR in Merrifield
- */
-struct sst_mem_mgr {
-	phys_addr_t current_base;
-	int avail;
-	unsigned int count;
-};
-
-struct sst_ipc_reg {
-	int ipcx;
-	int ipcd;
-};
-
-struct sst_shim_regs64 {
-	u64 csr;
-	u64 pisr;
-	u64 pimr;
-	u64 isrx;
-	u64 isrd;
-	u64 imrx;
-	u64 imrd;
-	u64 ipcx;
-	u64 ipcd;
-	u64 isrsc;
-	u64 isrlpesc;
-	u64 imrsc;
-	u64 imrlpesc;
-	u64 ipcsc;
-	u64 ipclpesc;
-	u64 clkctl;
-	u64 csr2;
-};
-
-/**
- * struct intel_sst_drv - driver ops
- *
- * @sst_state : current sst device state
- * @dev_id : device identifier, pci_id for pci devices and acpi_id for acpi
- * 	     devices
- * @shim : SST shim pointer
- * @mailbox : SST mailbox pointer
- * @iram : SST IRAM pointer
- * @dram : SST DRAM pointer
- * @pdata : SST info passed as a part of pci platform data
- * @shim_phy_add : SST shim phy addr
- * @shim_regs64: Struct to save shim registers
- * @ipc_dispatch_list : ipc messages dispatched
- * @rx_list : to copy the process_reply/process_msg from DSP
- * @ipc_post_msg_wq : wq to post IPC messages context
- * @mad_ops : MAD driver operations registered
- * @mad_wq : MAD driver wq
- * @post_msg_wq : wq to post IPC messages
- * @streams : sst stream contexts
- * @list_lock : sst driver list lock (deprecated)
- * @ipc_spin_lock : spin lock to handle audio shim access and ipc queue
- * @block_lock : spin lock to add block to block_list and assign pvt_id
- * @rx_msg_lock : spin lock to handle the rx messages from the DSP
- * @scard_ops : sst card ops
- * @pci : sst pci device struture
- * @dev : pointer to current device struct
- * @sst_lock : sst device lock
- * @pvt_id : sst private id
- * @stream_cnt : total sst active stream count
- * @pb_streams : total active pb streams
- * @cp_streams : total active cp streams
- * @audio_start : audio status
- * @qos		: PM Qos struct
- * firmware_name : Firmware / Library name
- */
-struct intel_sst_drv {
-	int			sst_state;
-	int			irq_num;
-	unsigned int		dev_id;
-	void __iomem		*ddr;
-	void __iomem		*shim;
-	void __iomem		*mailbox;
-	void __iomem		*iram;
-	void __iomem		*dram;
-	unsigned int		mailbox_add;
-	unsigned int		iram_base;
-	unsigned int		dram_base;
-	unsigned int		shim_phy_add;
-	unsigned int		iram_end;
-	unsigned int		dram_end;
-	unsigned int		ddr_end;
-	unsigned int		ddr_base;
-	unsigned int		mailbox_recv_offset;
-	struct sst_shim_regs64	*shim_regs64;
-	struct list_head        block_list;
-	struct list_head	ipc_dispatch_list;
-	struct sst_platform_info *pdata;
-	struct list_head	rx_list;
-	struct work_struct      ipc_post_msg_wq;
-	wait_queue_head_t	wait_queue;
-	struct workqueue_struct *post_msg_wq;
-	unsigned int		tstamp;
-	/* str_id 0 is not used */
-	struct stream_info	streams[MAX_NUM_STREAMS+1];
-	spinlock_t		ipc_spin_lock;
-	spinlock_t              block_lock;
-	spinlock_t		rx_msg_lock;
-	struct pci_dev		*pci;
-	struct device		*dev;
-	volatile long unsigned 		pvt_id;
-	struct mutex            sst_lock;
-	unsigned int		stream_cnt;
-	unsigned int		csr_value;
-	void			*fw_in_mem;
-	struct sst_sg_list	fw_sg_list, library_list;
-	struct intel_sst_ops	*ops;
-	struct sst_info		info;
-	struct pm_qos_request	*qos;
-	unsigned int		use_dma;
-	unsigned int		use_lli;
-	atomic_t		fw_clear_context;
-	bool			lib_dwnld_reqd;
-	struct list_head	memcpy_list;
-	struct sst_ipc_reg	ipc_reg;
-	struct sst_mem_mgr      lib_mem_mgr;
-	/*
-	 * Holder for firmware name. Due to async call it needs to be
-	 * persistent till worker thread gets called
-	 */
-	char firmware_name[FW_NAME_SIZE];
-};
-
-/* misc definitions */
-#define FW_DWNL_ID 0x01
-
-struct intel_sst_ops {
-	irqreturn_t (*interrupt)(int, void *);
-	irqreturn_t (*irq_thread)(int, void *);
-	void (*clear_interrupt)(struct intel_sst_drv *ctx);
-	int (*start)(struct intel_sst_drv *ctx);
-	int (*reset)(struct intel_sst_drv *ctx);
-	void (*process_reply)(struct intel_sst_drv *ctx, struct ipc_post *msg);
-	int (*post_message)(struct intel_sst_drv *ctx,
-			struct ipc_post *msg, bool sync);
-	void (*process_message)(struct ipc_post *msg);
-	void (*set_bypass)(bool set);
-	int (*save_dsp_context)(struct intel_sst_drv *sst);
-	void (*restore_dsp_context)(void);
-	int (*alloc_stream)(struct intel_sst_drv *ctx, void *params);
-	void (*post_download)(struct intel_sst_drv *sst);
-};
-
-int sst_pause_stream(struct intel_sst_drv *sst_drv_ctx, int id);
-int sst_resume_stream(struct intel_sst_drv *sst_drv_ctx, int id);
-int sst_drop_stream(struct intel_sst_drv *sst_drv_ctx, int id);
-int sst_free_stream(struct intel_sst_drv *sst_drv_ctx, int id);
-int sst_start_stream(struct intel_sst_drv *sst_drv_ctx, int str_id);
-int sst_send_byte_stream_mrfld(struct intel_sst_drv *ctx,
-			struct snd_sst_bytes_v2 *sbytes);
-int sst_set_stream_param(int str_id, struct snd_sst_params *str_param);
-int sst_set_metadata(int str_id, char *params);
-int sst_get_stream(struct intel_sst_drv *sst_drv_ctx,
-		struct snd_sst_params *str_param);
-int sst_get_stream_allocated(struct intel_sst_drv *ctx,
-		struct snd_sst_params *str_param,
-		struct snd_sst_lib_download **lib_dnld);
-int sst_drain_stream(struct intel_sst_drv *sst_drv_ctx,
-		int str_id, bool partial_drain);
-int sst_post_message_mrfld(struct intel_sst_drv *ctx,
-		struct ipc_post *msg, bool sync);
-void sst_process_reply_mrfld(struct intel_sst_drv *ctx, struct ipc_post *msg);
-int sst_start_mrfld(struct intel_sst_drv *ctx);
-int intel_sst_reset_dsp_mrfld(struct intel_sst_drv *ctx);
-void intel_sst_clear_intr_mrfld(struct intel_sst_drv *ctx);
-
-int sst_load_fw(struct intel_sst_drv *ctx);
-int sst_load_library(struct snd_sst_lib_download *lib, u8 ops);
-void sst_post_download_mrfld(struct intel_sst_drv *ctx);
-int sst_get_block_stream(struct intel_sst_drv *sst_drv_ctx);
-void sst_memcpy_free_resources(struct intel_sst_drv *ctx);
-
-int sst_wait_interruptible(struct intel_sst_drv *sst_drv_ctx,
-				struct sst_block *block);
-int sst_wait_timeout(struct intel_sst_drv *sst_drv_ctx,
-			struct sst_block *block);
-int sst_create_ipc_msg(struct ipc_post **arg, bool large);
-int free_stream_context(struct intel_sst_drv *ctx, unsigned int str_id);
-void sst_clean_stream(struct stream_info *stream);
-int intel_sst_register_compress(struct intel_sst_drv *sst);
-int intel_sst_remove_compress(struct intel_sst_drv *sst);
-void sst_cdev_fragment_elapsed(struct intel_sst_drv *ctx, int str_id);
-int sst_send_sync_msg(int ipc, int str_id);
-int sst_get_num_channel(struct snd_sst_params *str_param);
-int sst_get_sfreq(struct snd_sst_params *str_param);
-int sst_alloc_stream_mrfld(struct intel_sst_drv *sst_drv_ctx, void *params);
-void sst_restore_fw_context(void);
-struct sst_block *sst_create_block(struct intel_sst_drv *ctx,
-				u32 msg_id, u32 drv_id);
-int sst_create_block_and_ipc_msg(struct ipc_post **arg, bool large,
-		struct intel_sst_drv *sst_drv_ctx, struct sst_block **block,
-		u32 msg_id, u32 drv_id);
-int sst_free_block(struct intel_sst_drv *ctx, struct sst_block *freed);
-int sst_wake_up_block(struct intel_sst_drv *ctx, int result,
-		u32 drv_id, u32 ipc, void *data, u32 size);
-int sst_request_firmware_async(struct intel_sst_drv *ctx);
-int sst_driver_ops(struct intel_sst_drv *sst);
-struct sst_platform_info *sst_get_acpi_driver_data(const char *hid);
-void sst_firmware_load_cb(const struct firmware *fw, void *context);
-int sst_prepare_and_post_msg(struct intel_sst_drv *sst,
-		int task_id, int ipc_msg, int cmd_id, int pipe_id,
-		size_t mbox_data_len, const void *mbox_data, void **data,
-		bool large, bool fill_dsp, bool sync, bool response);
-
-void sst_process_pending_msg(struct work_struct *work);
-int sst_assign_pvt_id(struct intel_sst_drv *sst_drv_ctx);
-void sst_init_stream(struct stream_info *stream,
-		int codec, int sst_id, int ops, u8 slot);
-int sst_validate_strid(struct intel_sst_drv *sst_drv_ctx, int str_id);
-struct stream_info *get_stream_info(struct intel_sst_drv *sst_drv_ctx,
-		int str_id);
-int get_stream_id_mrfld(struct intel_sst_drv *sst_drv_ctx,
-		u32 pipe_id);
-u32 relocate_imr_addr_mrfld(u32 base_addr);
-void sst_add_to_dispatch_list_and_post(struct intel_sst_drv *sst,
-					struct ipc_post *msg);
-int sst_pm_runtime_put(struct intel_sst_drv *sst_drv);
-int sst_shim_write(void __iomem *addr, int offset, int value);
-u32 sst_shim_read(void __iomem *addr, int offset);
-u64 sst_reg_read64(void __iomem *addr, int offset);
-int sst_shim_write64(void __iomem *addr, int offset, u64 value);
-u64 sst_shim_read64(void __iomem *addr, int offset);
-void sst_set_fw_state_locked(
-		struct intel_sst_drv *sst_drv_ctx, int sst_state);
-void sst_fill_header_mrfld(union ipc_header_mrfld *header,
-				int msg, int task_id, int large, int drv_id);
-void sst_fill_header_dsp(struct ipc_dsp_hdr *dsp, int msg,
-					int pipe_id, int len);
-
-int sst_register(struct device *);
-int sst_unregister(struct device *);
-
-int sst_alloc_drv_context(struct intel_sst_drv **ctx,
-		struct device *dev, unsigned int dev_id);
-int sst_context_init(struct intel_sst_drv *ctx);
-void sst_context_cleanup(struct intel_sst_drv *ctx);
-void sst_configure_runtime_pm(struct intel_sst_drv *ctx);
-#endif
diff -Naur linux-3.19.old/sound/soc/intel/sst/sst_ipc.c linux-3.19/sound/soc/intel/sst/sst_ipc.c
--- linux-3.19.old/sound/soc/intel/sst/sst_ipc.c	2015-03-24 17:38:14.443176946 -0800
+++ linux-3.19/sound/soc/intel/sst/sst_ipc.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,373 +0,0 @@
-/*
- *  sst_ipc.c - Intel SST Driver for audio engine
- *
- *  Copyright (C) 2008-14 Intel Corporation
- *  Authors:	Vinod Koul <vinod.koul@intel.com>
- *		Harsha Priya <priya.harsha@intel.com>
- *		Dharageswari R <dharageswari.r@intel.com>
- *		KP Jeeja <jeeja.kp@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-#include <linux/pci.h>
-#include <linux/firmware.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/pm_runtime.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/soc.h>
-#include <sound/compress_driver.h>
-#include <asm/intel-mid.h>
-#include <asm/platform_sst_audio.h>
-#include "../sst-mfld-platform.h"
-#include "sst.h"
-#include "../sst-dsp.h"
-
-struct sst_block *sst_create_block(struct intel_sst_drv *ctx,
-					u32 msg_id, u32 drv_id)
-{
-	struct sst_block *msg = NULL;
-
-	dev_dbg(ctx->dev, "Enter\n");
-	msg = kzalloc(sizeof(*msg), GFP_KERNEL);
-	if (!msg)
-		return NULL;
-	msg->condition = false;
-	msg->on = true;
-	msg->msg_id = msg_id;
-	msg->drv_id = drv_id;
-	spin_lock_bh(&ctx->block_lock);
-	list_add_tail(&msg->node, &ctx->block_list);
-	spin_unlock_bh(&ctx->block_lock);
-
-	return msg;
-}
-
-/*
- * while handling the interrupts, we need to check for message status and
- * then if we are blocking for a message
- *
- * here we are unblocking the blocked ones, this is based on id we have
- * passed and search that for block threads.
- * We will not find block in two cases
- *  a) when its small message and block in not there, so silently ignore
- *  them
- *  b) when we are actually not able to find the block (bug perhaps)
- *
- *  Since we have bit of small messages we can spam kernel log with err
- *  print on above so need to keep as debug prints which should be enabled
- *  via dynamic debug while debugging IPC issues
- */
-int sst_wake_up_block(struct intel_sst_drv *ctx, int result,
-		u32 drv_id, u32 ipc, void *data, u32 size)
-{
-	struct sst_block *block = NULL;
-
-	dev_dbg(ctx->dev, "Enter\n");
-
-	spin_lock_bh(&ctx->block_lock);
-	list_for_each_entry(block, &ctx->block_list, node) {
-		dev_dbg(ctx->dev, "Block ipc %d, drv_id %d\n", block->msg_id,
-							block->drv_id);
-		if (block->msg_id == ipc && block->drv_id == drv_id) {
-			dev_dbg(ctx->dev, "free up the block\n");
-			block->ret_code = result;
-			block->data = data;
-			block->size = size;
-			block->condition = true;
-			spin_unlock_bh(&ctx->block_lock);
-			wake_up(&ctx->wait_queue);
-			return 0;
-		}
-	}
-	spin_unlock_bh(&ctx->block_lock);
-	dev_dbg(ctx->dev,
-		"Block not found or a response received for a short msg for ipc %d, drv_id %d\n",
-		ipc, drv_id);
-	return -EINVAL;
-}
-
-int sst_free_block(struct intel_sst_drv *ctx, struct sst_block *freed)
-{
-	struct sst_block *block = NULL, *__block;
-
-	dev_dbg(ctx->dev, "Enter\n");
-	spin_lock_bh(&ctx->block_lock);
-	list_for_each_entry_safe(block, __block, &ctx->block_list, node) {
-		if (block == freed) {
-			pr_debug("pvt_id freed --> %d\n", freed->drv_id);
-			/* toggle the index position of pvt_id */
-			list_del(&freed->node);
-			spin_unlock_bh(&ctx->block_lock);
-			kfree(freed->data);
-			freed->data = NULL;
-			kfree(freed);
-			return 0;
-		}
-	}
-	spin_unlock_bh(&ctx->block_lock);
-	dev_err(ctx->dev, "block is already freed!!!\n");
-	return -EINVAL;
-}
-
-int sst_post_message_mrfld(struct intel_sst_drv *sst_drv_ctx,
-		struct ipc_post *ipc_msg, bool sync)
-{
-	struct ipc_post *msg = ipc_msg;
-	union ipc_header_mrfld header;
-	unsigned int loop_count = 0;
-	int retval = 0;
-	unsigned long irq_flags;
-
-	dev_dbg(sst_drv_ctx->dev, "Enter: sync: %d\n", sync);
-	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
-	header.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);
-	if (sync) {
-		while (header.p.header_high.part.busy) {
-			if (loop_count > 25) {
-				dev_err(sst_drv_ctx->dev,
-					"sst: Busy wait failed, cant send this msg\n");
-				retval = -EBUSY;
-				goto out;
-			}
-			cpu_relax();
-			loop_count++;
-			header.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);
-		}
-	} else {
-		if (list_empty(&sst_drv_ctx->ipc_dispatch_list)) {
-			/* queue is empty, nothing to send */
-			spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
-			dev_dbg(sst_drv_ctx->dev,
-					"Empty msg queue... NO Action\n");
-			return 0;
-		}
-
-		if (header.p.header_high.part.busy) {
-			spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
-			dev_dbg(sst_drv_ctx->dev, "Busy not free... post later\n");
-			return 0;
-		}
-
-		/* copy msg from list */
-		msg = list_entry(sst_drv_ctx->ipc_dispatch_list.next,
-				struct ipc_post, node);
-		list_del(&msg->node);
-	}
-	dev_dbg(sst_drv_ctx->dev, "sst: Post message: header = %x\n",
-				msg->mrfld_header.p.header_high.full);
-	dev_dbg(sst_drv_ctx->dev, "sst: size = 0x%x\n",
-			msg->mrfld_header.p.header_low_payload);
-
-	if (msg->mrfld_header.p.header_high.part.large)
-		memcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,
-			msg->mailbox_data,
-			msg->mrfld_header.p.header_low_payload);
-
-	sst_shim_write64(sst_drv_ctx->shim, SST_IPCX, msg->mrfld_header.full);
-
-out:
-	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
-	kfree(msg->mailbox_data);
-	kfree(msg);
-	return retval;
-}
-
-void intel_sst_clear_intr_mrfld(struct intel_sst_drv *sst_drv_ctx)
-{
-	union interrupt_reg_mrfld isr;
-	union interrupt_reg_mrfld imr;
-	union ipc_header_mrfld clear_ipc;
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
-	imr.full = sst_shim_read64(sst_drv_ctx->shim, SST_IMRX);
-	isr.full = sst_shim_read64(sst_drv_ctx->shim, SST_ISRX);
-
-	/* write 1 to clear*/
-	isr.part.busy_interrupt = 1;
-	sst_shim_write64(sst_drv_ctx->shim, SST_ISRX, isr.full);
-
-	/* Set IA done bit */
-	clear_ipc.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCD);
-
-	clear_ipc.p.header_high.part.busy = 0;
-	clear_ipc.p.header_high.part.done = 1;
-	clear_ipc.p.header_low_payload = IPC_ACK_SUCCESS;
-	sst_shim_write64(sst_drv_ctx->shim, SST_IPCD, clear_ipc.full);
-	/* un mask busy interrupt */
-	imr.part.busy_interrupt = 0;
-	sst_shim_write64(sst_drv_ctx->shim, SST_IMRX, imr.full);
-	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
-}
-
-
-/*
- * process_fw_init - process the FW init msg
- *
- * @msg: IPC message mailbox data from FW
- *
- * This function processes the FW init msg from FW
- * marks FW state and prints debug info of loaded FW
- */
-static void process_fw_init(struct intel_sst_drv *sst_drv_ctx,
-			void *msg)
-{
-	struct ipc_header_fw_init *init =
-		(struct ipc_header_fw_init *)msg;
-	int retval = 0;
-
-	dev_dbg(sst_drv_ctx->dev, "*** FW Init msg came***\n");
-	if (init->result) {
-		sst_set_fw_state_locked(sst_drv_ctx, SST_RESET);
-		dev_err(sst_drv_ctx->dev, "FW Init failed, Error %x\n",
-				init->result);
-		retval = init->result;
-		goto ret;
-	}
-
-ret:
-	sst_wake_up_block(sst_drv_ctx, retval, FW_DWNL_ID, 0 , NULL, 0);
-}
-
-static void process_fw_async_msg(struct intel_sst_drv *sst_drv_ctx,
-			struct ipc_post *msg)
-{
-	u32 msg_id;
-	int str_id;
-	u32 data_size, i;
-	void *data_offset;
-	struct stream_info *stream;
-	union ipc_header_high msg_high;
-	u32 msg_low, pipe_id;
-
-	msg_high = msg->mrfld_header.p.header_high;
-	msg_low = msg->mrfld_header.p.header_low_payload;
-	msg_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->cmd_id;
-	data_offset = (msg->mailbox_data + sizeof(struct ipc_dsp_hdr));
-	data_size =  msg_low - (sizeof(struct ipc_dsp_hdr));
-
-	switch (msg_id) {
-	case IPC_SST_PERIOD_ELAPSED_MRFLD:
-		pipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;
-		str_id = get_stream_id_mrfld(sst_drv_ctx, pipe_id);
-		if (str_id > 0) {
-			dev_dbg(sst_drv_ctx->dev,
-				"Period elapsed rcvd for pipe id 0x%x\n",
-				pipe_id);
-			stream = &sst_drv_ctx->streams[str_id];
-			if (stream->period_elapsed)
-				stream->period_elapsed(stream->pcm_substream);
-			if (stream->compr_cb)
-				stream->compr_cb(stream->compr_cb_param);
-		}
-		break;
-
-	case IPC_IA_DRAIN_STREAM_MRFLD:
-		pipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;
-		str_id = get_stream_id_mrfld(sst_drv_ctx, pipe_id);
-		if (str_id > 0) {
-			stream = &sst_drv_ctx->streams[str_id];
-			if (stream->drain_notify)
-				stream->drain_notify(stream->drain_cb_param);
-		}
-		break;
-
-	case IPC_IA_FW_ASYNC_ERR_MRFLD:
-		dev_err(sst_drv_ctx->dev, "FW sent async error msg:\n");
-		for (i = 0; i < (data_size/4); i++)
-			print_hex_dump(KERN_DEBUG, NULL, DUMP_PREFIX_NONE,
-					16, 4, data_offset, data_size, false);
-		break;
-
-	case IPC_IA_FW_INIT_CMPLT_MRFLD:
-		process_fw_init(sst_drv_ctx, data_offset);
-		break;
-
-	case IPC_IA_BUF_UNDER_RUN_MRFLD:
-		pipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;
-		str_id = get_stream_id_mrfld(sst_drv_ctx, pipe_id);
-		if (str_id > 0)
-			dev_err(sst_drv_ctx->dev,
-				"Buffer under-run for pipe:%#x str_id:%d\n",
-				pipe_id, str_id);
-		break;
-
-	default:
-		dev_err(sst_drv_ctx->dev,
-			"Unrecognized async msg from FW msg_id %#x\n", msg_id);
-	}
-}
-
-void sst_process_reply_mrfld(struct intel_sst_drv *sst_drv_ctx,
-		struct ipc_post *msg)
-{
-	unsigned int drv_id;
-	void *data;
-	union ipc_header_high msg_high;
-	u32 msg_low;
-	struct ipc_dsp_hdr *dsp_hdr;
-	unsigned int cmd_id;
-
-	msg_high = msg->mrfld_header.p.header_high;
-	msg_low = msg->mrfld_header.p.header_low_payload;
-
-	dev_dbg(sst_drv_ctx->dev, "IPC process message header %x payload %x\n",
-			msg->mrfld_header.p.header_high.full,
-			msg->mrfld_header.p.header_low_payload);
-
-	drv_id = msg_high.part.drv_id;
-
-	/* Check for async messages first */
-	if (drv_id == SST_ASYNC_DRV_ID) {
-		/*FW sent async large message*/
-		process_fw_async_msg(sst_drv_ctx, msg);
-		return;
-	}
-
-	/* FW sent short error response for an IPC */
-	if (msg_high.part.result && drv_id && !msg_high.part.large) {
-		/* 32-bit FW error code in msg_low */
-		dev_err(sst_drv_ctx->dev, "FW sent error response 0x%x", msg_low);
-		sst_wake_up_block(sst_drv_ctx, msg_high.part.result,
-			msg_high.part.drv_id,
-			msg_high.part.msg_id, NULL, 0);
-		return;
-	}
-
-	/*
-	 * Process all valid responses
-	 * if it is a large message, the payload contains the size to
-	 * copy from mailbox
-	 **/
-	if (msg_high.part.large) {
-		data = kzalloc(msg_low, GFP_KERNEL);
-		if (!data)
-			return;
-		memcpy(data, (void *) msg->mailbox_data, msg_low);
-		/* Copy command id so that we can use to put sst to reset */
-		dsp_hdr = (struct ipc_dsp_hdr *)data;
-		cmd_id = dsp_hdr->cmd_id;
-		dev_dbg(sst_drv_ctx->dev, "cmd_id %d\n", dsp_hdr->cmd_id);
-		if (sst_wake_up_block(sst_drv_ctx, msg_high.part.result,
-				msg_high.part.drv_id,
-				msg_high.part.msg_id, data, msg_low))
-			kfree(data);
-	} else {
-		sst_wake_up_block(sst_drv_ctx, msg_high.part.result,
-				msg_high.part.drv_id,
-				msg_high.part.msg_id, NULL, 0);
-	}
-
-}
diff -Naur linux-3.19.old/sound/soc/intel/sst/sst_loader.c linux-3.19/sound/soc/intel/sst/sst_loader.c
--- linux-3.19.old/sound/soc/intel/sst/sst_loader.c	2015-03-24 17:38:14.443176946 -0800
+++ linux-3.19/sound/soc/intel/sst/sst_loader.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,456 +0,0 @@
-/*
- *  sst_dsp.c - Intel SST Driver for audio engine
- *
- *  Copyright (C) 2008-14	Intel Corp
- *  Authors:	Vinod Koul <vinod.koul@intel.com>
- *		Harsha Priya <priya.harsha@intel.com>
- *		Dharageswari R <dharageswari.r@intel.com>
- *		KP Jeeja <jeeja.kp@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This file contains all dsp controlling functions like firmware download,
- * setting/resetting dsp cores, etc
- */
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/sched.h>
-#include <linux/firmware.h>
-#include <linux/dmaengine.h>
-#include <linux/pm_runtime.h>
-#include <linux/pm_qos.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/soc.h>
-#include <sound/compress_driver.h>
-#include <asm/platform_sst_audio.h>
-#include "../sst-mfld-platform.h"
-#include "sst.h"
-#include "../sst-dsp.h"
-
-static inline void memcpy32_toio(void __iomem *dst, const void *src, int count)
-{
-	/* __iowrite32_copy uses 32-bit count values so divide by 4 for
-	 * right count in words
-	 */
-	__iowrite32_copy(dst, src, count/4);
-}
-
-/**
- * intel_sst_reset_dsp_mrfld - Resetting SST DSP
- *
- * This resets DSP in case of MRFLD platfroms
- */
-int intel_sst_reset_dsp_mrfld(struct intel_sst_drv *sst_drv_ctx)
-{
-	union config_status_reg_mrfld csr;
-
-	dev_dbg(sst_drv_ctx->dev, "sst: Resetting the DSP in mrfld\n");
-	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
-
-	dev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);
-
-	csr.full |= 0x7;
-	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
-	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
-
-	dev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);
-
-	csr.full &= ~(0x1);
-	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
-
-	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
-	dev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);
-	return 0;
-}
-
-/**
- * sst_start_merrifield - Start the SST DSP processor
- *
- * This starts the DSP in MERRIFIELD platfroms
- */
-int sst_start_mrfld(struct intel_sst_drv *sst_drv_ctx)
-{
-	union config_status_reg_mrfld csr;
-
-	dev_dbg(sst_drv_ctx->dev, "sst: Starting the DSP in mrfld LALALALA\n");
-	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
-	dev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);
-
-	csr.full |= 0x7;
-	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
-
-	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
-	dev_dbg(sst_drv_ctx->dev, "value:0x%llx\n", csr.full);
-
-	csr.part.xt_snoop = 1;
-	csr.full &= ~(0x5);
-	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
-
-	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
-	dev_dbg(sst_drv_ctx->dev, "sst: Starting the DSP_merrifield:%llx\n",
-			csr.full);
-	return 0;
-}
-
-static int sst_validate_fw_image(struct intel_sst_drv *ctx, unsigned long size,
-		struct fw_module_header **module, u32 *num_modules)
-{
-	struct sst_fw_header *header;
-	const void *sst_fw_in_mem = ctx->fw_in_mem;
-
-	dev_dbg(ctx->dev, "Enter\n");
-
-	/* Read the header information from the data pointer */
-	header = (struct sst_fw_header *)sst_fw_in_mem;
-	dev_dbg(ctx->dev,
-		"header sign=%s size=%x modules=%x fmt=%x size=%zx\n",
-		header->signature, header->file_size, header->modules,
-		header->file_format, sizeof(*header));
-
-	/* verify FW */
-	if ((strncmp(header->signature, SST_FW_SIGN, 4) != 0) ||
-		(size != header->file_size + sizeof(*header))) {
-		/* Invalid FW signature */
-		dev_err(ctx->dev, "InvalidFW sign/filesize mismatch\n");
-		return -EINVAL;
-	}
-	*num_modules = header->modules;
-	*module = (void *)sst_fw_in_mem + sizeof(*header);
-
-	return 0;
-}
-
-/*
- * sst_fill_memcpy_list - Fill the memcpy list
- *
- * @memcpy_list: List to be filled
- * @destn: Destination addr to be filled in the list
- * @src: Source addr to be filled in the list
- * @size: Size to be filled in the list
- *
- * Adds the node to the list after required fields
- * are populated in the node
- */
-static int sst_fill_memcpy_list(struct list_head *memcpy_list,
-			void *destn, const void *src, u32 size, bool is_io)
-{
-	struct sst_memcpy_list *listnode;
-
-	listnode = kzalloc(sizeof(*listnode), GFP_KERNEL);
-	if (listnode == NULL)
-		return -ENOMEM;
-	listnode->dstn = destn;
-	listnode->src = src;
-	listnode->size = size;
-	listnode->is_io = is_io;
-	list_add_tail(&listnode->memcpylist, memcpy_list);
-
-	return 0;
-}
-
-/**
- * sst_parse_module_memcpy - Parse audio FW modules and populate the memcpy list
- *
- * @sst_drv_ctx		: driver context
- * @module		: FW module header
- * @memcpy_list	: Pointer to the list to be populated
- * Create the memcpy list as the number of block to be copied
- * returns error or 0 if module sizes are proper
- */
-static int sst_parse_module_memcpy(struct intel_sst_drv *sst_drv_ctx,
-		struct fw_module_header *module, struct list_head *memcpy_list)
-{
-	struct fw_block_info *block;
-	u32 count;
-	int ret_val = 0;
-	void __iomem *ram_iomem;
-
-	dev_dbg(sst_drv_ctx->dev, "module sign %s size %x blocks %x type %x\n",
-			module->signature, module->mod_size,
-			module->blocks, module->type);
-	dev_dbg(sst_drv_ctx->dev, "module entrypoint 0x%x\n", module->entry_point);
-
-	block = (void *)module + sizeof(*module);
-
-	for (count = 0; count < module->blocks; count++) {
-		if (block->size <= 0) {
-			dev_err(sst_drv_ctx->dev, "block size invalid\n");
-			return -EINVAL;
-		}
-		switch (block->type) {
-		case SST_IRAM:
-			ram_iomem = sst_drv_ctx->iram;
-			break;
-		case SST_DRAM:
-			ram_iomem = sst_drv_ctx->dram;
-			break;
-		case SST_DDR:
-			ram_iomem = sst_drv_ctx->ddr;
-			break;
-		case SST_CUSTOM_INFO:
-			block = (void *)block + sizeof(*block) + block->size;
-			continue;
-		default:
-			dev_err(sst_drv_ctx->dev, "wrong ram type0x%x in block0x%x\n",
-					block->type, count);
-			return -EINVAL;
-		}
-
-		ret_val = sst_fill_memcpy_list(memcpy_list,
-				ram_iomem + block->ram_offset,
-				(void *)block + sizeof(*block), block->size, 1);
-		if (ret_val)
-			return ret_val;
-
-		block = (void *)block + sizeof(*block) + block->size;
-	}
-	return 0;
-}
-
-/**
- * sst_parse_fw_memcpy - parse the firmware image & populate the list for memcpy
- *
- * @ctx			: pointer to drv context
- * @size		: size of the firmware
- * @fw_list		: pointer to list_head to be populated
- * This function parses the FW image and saves the parsed image in the list
- * for memcpy
- */
-static int sst_parse_fw_memcpy(struct intel_sst_drv *ctx, unsigned long size,
-				struct list_head *fw_list)
-{
-	struct fw_module_header *module;
-	u32 count, num_modules;
-	int ret_val;
-
-	ret_val = sst_validate_fw_image(ctx, size, &module, &num_modules);
-	if (ret_val)
-		return ret_val;
-
-	for (count = 0; count < num_modules; count++) {
-		ret_val = sst_parse_module_memcpy(ctx, module, fw_list);
-		if (ret_val)
-			return ret_val;
-		module = (void *)module + sizeof(*module) + module->mod_size;
-	}
-
-	return 0;
-}
-
-/**
- * sst_do_memcpy - function initiates the memcpy
- *
- * @memcpy_list: Pter to memcpy list on which the memcpy needs to be initiated
- *
- * Triggers the memcpy
- */
-static void sst_do_memcpy(struct list_head *memcpy_list)
-{
-	struct sst_memcpy_list *listnode;
-
-	list_for_each_entry(listnode, memcpy_list, memcpylist) {
-		if (listnode->is_io == true)
-			memcpy32_toio((void __iomem *)listnode->dstn,
-					listnode->src, listnode->size);
-		else
-			memcpy(listnode->dstn, listnode->src, listnode->size);
-	}
-}
-
-void sst_memcpy_free_resources(struct intel_sst_drv *sst_drv_ctx)
-{
-	struct sst_memcpy_list *listnode, *tmplistnode;
-
-	/* Free the list */
-	if (!list_empty(&sst_drv_ctx->memcpy_list)) {
-		list_for_each_entry_safe(listnode, tmplistnode,
-				&sst_drv_ctx->memcpy_list, memcpylist) {
-			list_del(&listnode->memcpylist);
-			kfree(listnode);
-		}
-	}
-}
-
-static int sst_cache_and_parse_fw(struct intel_sst_drv *sst,
-		const struct firmware *fw)
-{
-	int retval = 0;
-
-	sst->fw_in_mem = kzalloc(fw->size, GFP_KERNEL);
-	if (!sst->fw_in_mem) {
-		retval = -ENOMEM;
-		goto end_release;
-	}
-	dev_dbg(sst->dev, "copied fw to %p", sst->fw_in_mem);
-	dev_dbg(sst->dev, "phys: %lx", (unsigned long)virt_to_phys(sst->fw_in_mem));
-	memcpy(sst->fw_in_mem, fw->data, fw->size);
-	retval = sst_parse_fw_memcpy(sst, fw->size, &sst->memcpy_list);
-	if (retval) {
-		dev_err(sst->dev, "Failed to parse fw\n");
-		kfree(sst->fw_in_mem);
-		sst->fw_in_mem = NULL;
-	}
-
-end_release:
-	release_firmware(fw);
-	return retval;
-
-}
-
-void sst_firmware_load_cb(const struct firmware *fw, void *context)
-{
-	struct intel_sst_drv *ctx = context;
-
-	dev_dbg(ctx->dev, "Enter\n");
-
-	if (fw == NULL) {
-		dev_err(ctx->dev, "request fw failed\n");
-		return;
-	}
-
-	mutex_lock(&ctx->sst_lock);
-
-	if (ctx->sst_state != SST_RESET ||
-			ctx->fw_in_mem != NULL) {
-		if (fw != NULL)
-			release_firmware(fw);
-		mutex_unlock(&ctx->sst_lock);
-		return;
-	}
-
-	dev_dbg(ctx->dev, "Request Fw completed\n");
-	sst_cache_and_parse_fw(ctx, fw);
-	mutex_unlock(&ctx->sst_lock);
-}
-
-/*
- * sst_request_fw - requests audio fw from kernel and saves a copy
- *
- * This function requests the SST FW from the kernel, parses it and
- * saves a copy in the driver context
- */
-static int sst_request_fw(struct intel_sst_drv *sst)
-{
-	int retval = 0;
-	const struct firmware *fw;
-
-	retval = request_firmware(&fw, sst->firmware_name, sst->dev);
-	if (fw == NULL) {
-		dev_err(sst->dev, "fw is returning as null\n");
-		return -EINVAL;
-	}
-	if (retval) {
-		dev_err(sst->dev, "request fw failed %d\n", retval);
-		return retval;
-	}
-	mutex_lock(&sst->sst_lock);
-	retval = sst_cache_and_parse_fw(sst, fw);
-	mutex_unlock(&sst->sst_lock);
-
-	return retval;
-}
-
-/*
- * Writing the DDR physical base to DCCM offset
- * so that FW can use it to setup TLB
- */
-static void sst_dccm_config_write(void __iomem *dram_base,
-		unsigned int ddr_base)
-{
-	void __iomem *addr;
-	u32 bss_reset = 0;
-
-	addr = (void __iomem *)(dram_base + MRFLD_FW_DDR_BASE_OFFSET);
-	memcpy32_toio(addr, (void *)&ddr_base, sizeof(u32));
-	bss_reset |= (1 << MRFLD_FW_BSS_RESET_BIT);
-	addr = (void __iomem *)(dram_base + MRFLD_FW_FEATURE_BASE_OFFSET);
-	memcpy32_toio(addr, &bss_reset, sizeof(u32));
-
-}
-
-void sst_post_download_mrfld(struct intel_sst_drv *ctx)
-{
-	sst_dccm_config_write(ctx->dram, ctx->ddr_base);
-	dev_dbg(ctx->dev, "config written to DCCM\n");
-}
-
-/**
- * sst_load_fw - function to load FW into DSP
- * Transfers the FW to DSP using dma/memcpy
- */
-int sst_load_fw(struct intel_sst_drv *sst_drv_ctx)
-{
-	int ret_val = 0;
-	struct sst_block *block;
-
-	dev_dbg(sst_drv_ctx->dev, "sst_load_fw\n");
-
-	if (sst_drv_ctx->sst_state !=  SST_RESET ||
-			sst_drv_ctx->sst_state == SST_SHUTDOWN)
-		return -EAGAIN;
-
-	if (!sst_drv_ctx->fw_in_mem) {
-		dev_dbg(sst_drv_ctx->dev, "sst: FW not in memory retry to download\n");
-		ret_val = sst_request_fw(sst_drv_ctx);
-		if (ret_val)
-			return ret_val;
-	}
-
-	BUG_ON(!sst_drv_ctx->fw_in_mem);
-	block = sst_create_block(sst_drv_ctx, 0, FW_DWNL_ID);
-	if (block == NULL)
-		return -ENOMEM;
-
-	/* Prevent C-states beyond C6 */
-	pm_qos_update_request(sst_drv_ctx->qos, 0);
-
-	sst_drv_ctx->sst_state = SST_FW_LOADING;
-
-	ret_val = sst_drv_ctx->ops->reset(sst_drv_ctx);
-	if (ret_val)
-		goto restore;
-
-	sst_do_memcpy(&sst_drv_ctx->memcpy_list);
-
-	/* Write the DRAM/DCCM config before enabling FW */
-	if (sst_drv_ctx->ops->post_download)
-		sst_drv_ctx->ops->post_download(sst_drv_ctx);
-
-	/* bring sst out of reset */
-	ret_val = sst_drv_ctx->ops->start(sst_drv_ctx);
-	if (ret_val)
-		goto restore;
-
-	ret_val = sst_wait_timeout(sst_drv_ctx, block);
-	if (ret_val) {
-		dev_err(sst_drv_ctx->dev, "fw download failed %d\n" , ret_val);
-		/* FW download failed due to timeout */
-		ret_val = -EBUSY;
-
-	}
-
-
-restore:
-	/* Re-enable Deeper C-states beyond C6 */
-	pm_qos_update_request(sst_drv_ctx->qos, PM_QOS_DEFAULT_VALUE);
-	sst_free_block(sst_drv_ctx, block);
-	dev_dbg(sst_drv_ctx->dev, "fw load successful!!!\n");
-
-	if (sst_drv_ctx->ops->restore_dsp_context)
-		sst_drv_ctx->ops->restore_dsp_context();
-	sst_drv_ctx->sst_state = SST_FW_RUNNING;
-	return ret_val;
-}
-
diff -Naur linux-3.19.old/sound/soc/intel/sst/sst_pci.c linux-3.19/sound/soc/intel/sst/sst_pci.c
--- linux-3.19.old/sound/soc/intel/sst/sst_pci.c	2015-03-24 17:38:14.443176946 -0800
+++ linux-3.19/sound/soc/intel/sst/sst_pci.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,209 +0,0 @@
-/*
- *  sst_pci.c - SST (LPE) driver init file for pci enumeration.
- *
- *  Copyright (C) 2008-14	Intel Corp
- *  Authors:	Vinod Koul <vinod.koul@intel.com>
- *		Harsha Priya <priya.harsha@intel.com>
- *		Dharageswari R <dharageswari.r@intel.com>
- *		KP Jeeja <jeeja.kp@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/fs.h>
-#include <linux/firmware.h>
-#include <linux/pm_runtime.h>
-#include <sound/core.h>
-#include <sound/soc.h>
-#include <asm/platform_sst_audio.h>
-#include "../sst-mfld-platform.h"
-#include "sst.h"
-
-static int sst_platform_get_resources(struct intel_sst_drv *ctx)
-{
-	int ddr_base, ret = 0;
-	struct pci_dev *pci = ctx->pci;
-
-	ret = pci_request_regions(pci, SST_DRV_NAME);
-	if (ret)
-		return ret;
-
-	/* map registers */
-	/* DDR base */
-	if (ctx->dev_id == SST_MRFLD_PCI_ID) {
-		ctx->ddr_base = pci_resource_start(pci, 0);
-		/* check that the relocated IMR base matches with FW Binary */
-		ddr_base = relocate_imr_addr_mrfld(ctx->ddr_base);
-		if (!ctx->pdata->lib_info) {
-			dev_err(ctx->dev, "lib_info pointer NULL\n");
-			ret = -EINVAL;
-			goto do_release_regions;
-		}
-		if (ddr_base != ctx->pdata->lib_info->mod_base) {
-			dev_err(ctx->dev,
-					"FW LSP DDR BASE does not match with IFWI\n");
-			ret = -EINVAL;
-			goto do_release_regions;
-		}
-		ctx->ddr_end = pci_resource_end(pci, 0);
-
-		ctx->ddr = pcim_iomap(pci, 0,
-					pci_resource_len(pci, 0));
-		if (!ctx->ddr) {
-			ret = -EINVAL;
-			goto do_release_regions;
-		}
-		dev_dbg(ctx->dev, "sst: DDR Ptr %p\n", ctx->ddr);
-	} else {
-		ctx->ddr = NULL;
-	}
-	/* SHIM */
-	ctx->shim_phy_add = pci_resource_start(pci, 1);
-	ctx->shim = pcim_iomap(pci, 1, pci_resource_len(pci, 1));
-	if (!ctx->shim) {
-		ret = -EINVAL;
-		goto do_release_regions;
-	}
-	dev_dbg(ctx->dev, "SST Shim Ptr %p\n", ctx->shim);
-
-	/* Shared SRAM */
-	ctx->mailbox_add = pci_resource_start(pci, 2);
-	ctx->mailbox = pcim_iomap(pci, 2, pci_resource_len(pci, 2));
-	if (!ctx->mailbox) {
-		ret = -EINVAL;
-		goto do_release_regions;
-	}
-	dev_dbg(ctx->dev, "SRAM Ptr %p\n", ctx->mailbox);
-
-	/* IRAM */
-	ctx->iram_end = pci_resource_end(pci, 3);
-	ctx->iram_base = pci_resource_start(pci, 3);
-	ctx->iram = pcim_iomap(pci, 3, pci_resource_len(pci, 3));
-	if (!ctx->iram) {
-		ret = -EINVAL;
-		goto do_release_regions;
-	}
-	dev_dbg(ctx->dev, "IRAM Ptr %p\n", ctx->iram);
-
-	/* DRAM */
-	ctx->dram_end = pci_resource_end(pci, 4);
-	ctx->dram_base = pci_resource_start(pci, 4);
-	ctx->dram = pcim_iomap(pci, 4, pci_resource_len(pci, 4));
-	if (!ctx->dram) {
-		ret = -EINVAL;
-		goto do_release_regions;
-	}
-	dev_dbg(ctx->dev, "DRAM Ptr %p\n", ctx->dram);
-do_release_regions:
-	pci_release_regions(pci);
-	return 0;
-}
-
-/*
- * intel_sst_probe - PCI probe function
- *
- * @pci:	PCI device structure
- * @pci_id: PCI device ID structure
- *
- */
-static int intel_sst_probe(struct pci_dev *pci,
-			const struct pci_device_id *pci_id)
-{
-	int ret = 0;
-	struct intel_sst_drv *sst_drv_ctx;
-	struct sst_platform_info *sst_pdata = pci->dev.platform_data;
-
-	dev_dbg(&pci->dev, "Probe for DID %x\n", pci->device);
-	ret = sst_alloc_drv_context(&sst_drv_ctx, &pci->dev, pci->device);
-	if (ret < 0)
-		return ret;
-
-	sst_drv_ctx->pdata = sst_pdata;
-	sst_drv_ctx->irq_num = pci->irq;
-	snprintf(sst_drv_ctx->firmware_name, sizeof(sst_drv_ctx->firmware_name),
-			"%s%04x%s", "fw_sst_",
-			sst_drv_ctx->dev_id, ".bin");
-
-	ret = sst_context_init(sst_drv_ctx);
-	if (ret < 0)
-		return ret;
-
-	/* Init the device */
-	ret = pcim_enable_device(pci);
-	if (ret) {
-		dev_err(sst_drv_ctx->dev,
-			"device can't be enabled. Returned err: %d\n", ret);
-		goto do_free_drv_ctx;
-	}
-	sst_drv_ctx->pci = pci_dev_get(pci);
-	ret = sst_platform_get_resources(sst_drv_ctx);
-	if (ret < 0)
-		goto do_free_drv_ctx;
-
-	pci_set_drvdata(pci, sst_drv_ctx);
-	sst_configure_runtime_pm(sst_drv_ctx);
-
-	return ret;
-
-do_free_drv_ctx:
-	sst_context_cleanup(sst_drv_ctx);
-	dev_err(sst_drv_ctx->dev, "Probe failed with %d\n", ret);
-	return ret;
-}
-
-/**
- * intel_sst_remove - PCI remove function
- *
- * @pci:	PCI device structure
- *
- * This function is called by OS when a device is unloaded
- * This frees the interrupt etc
- */
-static void intel_sst_remove(struct pci_dev *pci)
-{
-	struct intel_sst_drv *sst_drv_ctx = pci_get_drvdata(pci);
-
-	sst_context_cleanup(sst_drv_ctx);
-	pci_dev_put(sst_drv_ctx->pci);
-	pci_release_regions(pci);
-	pci_set_drvdata(pci, NULL);
-}
-
-/* PCI Routines */
-static struct pci_device_id intel_sst_ids[] = {
-	{ PCI_VDEVICE(INTEL, SST_MRFLD_PCI_ID), 0},
-	{ 0, }
-};
-
-static struct pci_driver sst_driver = {
-	.name = SST_DRV_NAME,
-	.id_table = intel_sst_ids,
-	.probe = intel_sst_probe,
-	.remove = intel_sst_remove,
-#ifdef CONFIG_PM
-	.driver = {
-		.pm = &intel_sst_pm,
-	},
-#endif
-};
-
-module_pci_driver(sst_driver);
-
-MODULE_DESCRIPTION("Intel (R) SST(R) Audio Engine PCI Driver");
-MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
-MODULE_AUTHOR("Harsha Priya <priya.harsha@intel.com>");
-MODULE_AUTHOR("Dharageswari R <dharageswari.r@intel.com>");
-MODULE_AUTHOR("KP Jeeja <jeeja.kp@intel.com>");
-MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("sst");
diff -Naur linux-3.19.old/sound/soc/intel/sst/sst_pvt.c linux-3.19/sound/soc/intel/sst/sst_pvt.c
--- linux-3.19.old/sound/soc/intel/sst/sst_pvt.c	2015-03-24 17:38:14.443176946 -0800
+++ linux-3.19/sound/soc/intel/sst/sst_pvt.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,449 +0,0 @@
-/*
- *  sst_pvt.c - Intel SST Driver for audio engine
- *
- *  Copyright (C) 2008-14	Intel Corp
- *  Authors:	Vinod Koul <vinod.koul@intel.com>
- *		Harsha Priya <priya.harsha@intel.com>
- *		Dharageswari R <dharageswari.r@intel.com>
- *		KP Jeeja <jeeja.kp@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-#include <linux/kobject.h>
-#include <linux/pci.h>
-#include <linux/fs.h>
-#include <linux/firmware.h>
-#include <linux/pm_runtime.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <sound/asound.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/soc.h>
-#include <sound/compress_driver.h>
-#include <asm/platform_sst_audio.h>
-#include "../sst-mfld-platform.h"
-#include "sst.h"
-#include "../sst-dsp.h"
-
-int sst_shim_write(void __iomem *addr, int offset, int value)
-{
-	writel(value, addr + offset);
-	return 0;
-}
-
-u32 sst_shim_read(void __iomem *addr, int offset)
-{
-	return readl(addr + offset);
-}
-
-u64 sst_reg_read64(void __iomem *addr, int offset)
-{
-	u64 val = 0;
-
-	memcpy_fromio(&val, addr + offset, sizeof(val));
-
-	return val;
-}
-
-int sst_shim_write64(void __iomem *addr, int offset, u64 value)
-{
-	memcpy_toio(addr + offset, &value, sizeof(value));
-	return 0;
-}
-
-u64 sst_shim_read64(void __iomem *addr, int offset)
-{
-	u64 val = 0;
-
-	memcpy_fromio(&val, addr + offset, sizeof(val));
-	return val;
-}
-
-void sst_set_fw_state_locked(
-		struct intel_sst_drv *sst_drv_ctx, int sst_state)
-{
-	mutex_lock(&sst_drv_ctx->sst_lock);
-	sst_drv_ctx->sst_state = sst_state;
-	mutex_unlock(&sst_drv_ctx->sst_lock);
-}
-
-/*
- * sst_wait_interruptible - wait on event
- *
- * @sst_drv_ctx: Driver context
- * @block: Driver block to wait on
- *
- * This function waits without a timeout (and is interruptable) for a
- * given block event
- */
-int sst_wait_interruptible(struct intel_sst_drv *sst_drv_ctx,
-				struct sst_block *block)
-{
-	int retval = 0;
-
-	if (!wait_event_interruptible(sst_drv_ctx->wait_queue,
-				block->condition)) {
-		/* event wake */
-		if (block->ret_code < 0) {
-			dev_err(sst_drv_ctx->dev,
-				"stream failed %d\n", block->ret_code);
-			retval = -EBUSY;
-		} else {
-			dev_dbg(sst_drv_ctx->dev, "event up\n");
-			retval = 0;
-		}
-	} else {
-		dev_err(sst_drv_ctx->dev, "signal interrupted\n");
-		retval = -EINTR;
-	}
-	return retval;
-
-}
-
-unsigned long long read_shim_data(struct intel_sst_drv *sst, int addr)
-{
-	unsigned long long val = 0;
-
-	switch (sst->dev_id) {
-	case SST_MRFLD_PCI_ID:
-	case SST_BYT_ACPI_ID:
-		val = sst_shim_read64(sst->shim, addr);
-		break;
-	}
-	return val;
-}
-
-void write_shim_data(struct intel_sst_drv *sst, int addr,
-				unsigned long long data)
-{
-	switch (sst->dev_id) {
-	case SST_MRFLD_PCI_ID:
-	case SST_BYT_ACPI_ID:
-		sst_shim_write64(sst->shim, addr, (u64) data);
-		break;
-	}
-}
-
-/*
- * sst_wait_timeout - wait on event for timeout
- *
- * @sst_drv_ctx: Driver context
- * @block: Driver block to wait on
- *
- * This function waits with a timeout value (and is not interruptible) on a
- * given block event
- */
-int sst_wait_timeout(struct intel_sst_drv *sst_drv_ctx, struct sst_block *block)
-{
-	int retval = 0;
-
-	/*
-	 * NOTE:
-	 * Observed that FW processes the alloc msg and replies even
-	 * before the alloc thread has finished execution
-	 */
-	dev_dbg(sst_drv_ctx->dev,
-		"waiting for condition %x ipc %d drv_id %d\n",
-		block->condition, block->msg_id, block->drv_id);
-	if (wait_event_timeout(sst_drv_ctx->wait_queue,
-				block->condition,
-				msecs_to_jiffies(SST_BLOCK_TIMEOUT))) {
-		/* event wake */
-		dev_dbg(sst_drv_ctx->dev, "Event wake %x\n",
-				block->condition);
-		dev_dbg(sst_drv_ctx->dev, "message ret: %d\n",
-				block->ret_code);
-		retval = -block->ret_code;
-	} else {
-		block->on = false;
-		dev_err(sst_drv_ctx->dev,
-			"Wait timed-out condition:%#x, msg_id:%#x fw_state %#x\n",
-			block->condition, block->msg_id, sst_drv_ctx->sst_state);
-		sst_drv_ctx->sst_state = SST_RESET;
-
-		retval = -EBUSY;
-	}
-	return retval;
-}
-
-/*
- * sst_create_ipc_msg - create a IPC message
- *
- * @arg: ipc message
- * @large: large or short message
- *
- * this function allocates structures to send a large or short
- * message to the firmware
- */
-int sst_create_ipc_msg(struct ipc_post **arg, bool large)
-{
-	struct ipc_post *msg;
-
-	msg = kzalloc(sizeof(struct ipc_post), GFP_ATOMIC);
-	if (!msg)
-		return -ENOMEM;
-	if (large) {
-		msg->mailbox_data = kzalloc(SST_MAILBOX_SIZE, GFP_ATOMIC);
-		if (!msg->mailbox_data) {
-			kfree(msg);
-			return -ENOMEM;
-		}
-	} else {
-		msg->mailbox_data = NULL;
-	}
-	msg->is_large = large;
-	*arg = msg;
-	return 0;
-}
-
-/*
- * sst_create_block_and_ipc_msg - Creates IPC message and sst block
- * @arg: passed to sst_create_ipc_message API
- * @large: large or short message
- * @sst_drv_ctx: sst driver context
- * @block: return block allocated
- * @msg_id: IPC
- * @drv_id: stream id or private id
- */
-int sst_create_block_and_ipc_msg(struct ipc_post **arg, bool large,
-		struct intel_sst_drv *sst_drv_ctx, struct sst_block **block,
-		u32 msg_id, u32 drv_id)
-{
-	int retval = 0;
-
-	retval = sst_create_ipc_msg(arg, large);
-	if (retval)
-		return retval;
-	*block = sst_create_block(sst_drv_ctx, msg_id, drv_id);
-	if (*block == NULL) {
-		kfree(*arg);
-		return -ENOMEM;
-	}
-	return retval;
-}
-
-/*
- * sst_clean_stream - clean the stream context
- *
- * @stream: stream structure
- *
- * this function resets the stream contexts
- * should be called in free
- */
-void sst_clean_stream(struct stream_info *stream)
-{
-	stream->status = STREAM_UN_INIT;
-	stream->prev = STREAM_UN_INIT;
-	mutex_lock(&stream->lock);
-	stream->cumm_bytes = 0;
-	mutex_unlock(&stream->lock);
-}
-
-int sst_prepare_and_post_msg(struct intel_sst_drv *sst,
-		int task_id, int ipc_msg, int cmd_id, int pipe_id,
-		size_t mbox_data_len, const void *mbox_data, void **data,
-		bool large, bool fill_dsp, bool sync, bool response)
-{
-	struct ipc_post *msg = NULL;
-	struct ipc_dsp_hdr dsp_hdr;
-	struct sst_block *block;
-	int ret = 0, pvt_id;
-
-	pvt_id = sst_assign_pvt_id(sst);
-	if (pvt_id < 0)
-		return pvt_id;
-
-	if (response)
-		ret = sst_create_block_and_ipc_msg(
-				&msg, large, sst, &block, ipc_msg, pvt_id);
-	else
-		ret = sst_create_ipc_msg(&msg, large);
-
-	if (ret < 0) {
-		test_and_clear_bit(pvt_id, &sst->pvt_id);
-		return -ENOMEM;
-	}
-
-	dev_dbg(sst->dev, "pvt_id = %d, pipe id = %d, task = %d ipc_msg: %d\n",
-		 pvt_id, pipe_id, task_id, ipc_msg);
-	sst_fill_header_mrfld(&msg->mrfld_header, ipc_msg,
-					task_id, large, pvt_id);
-	msg->mrfld_header.p.header_low_payload = sizeof(dsp_hdr) + mbox_data_len;
-	msg->mrfld_header.p.header_high.part.res_rqd = !sync;
-	dev_dbg(sst->dev, "header:%x\n",
-			msg->mrfld_header.p.header_high.full);
-	dev_dbg(sst->dev, "response rqd: %x",
-			msg->mrfld_header.p.header_high.part.res_rqd);
-	dev_dbg(sst->dev, "msg->mrfld_header.p.header_low_payload:%d",
-			msg->mrfld_header.p.header_low_payload);
-	if (fill_dsp) {
-		sst_fill_header_dsp(&dsp_hdr, cmd_id, pipe_id, mbox_data_len);
-		memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
-		if (mbox_data_len) {
-			memcpy(msg->mailbox_data + sizeof(dsp_hdr),
-					mbox_data, mbox_data_len);
-		}
-	}
-
-	if (sync)
-		sst->ops->post_message(sst, msg, true);
-	else
-		sst_add_to_dispatch_list_and_post(sst, msg);
-
-	if (response) {
-		ret = sst_wait_timeout(sst, block);
-		if (ret < 0) {
-			goto out;
-		} else if(block->data) {
-			if (!data)
-				goto out;
-			*data = kzalloc(block->size, GFP_KERNEL);
-			if (!(*data)) {
-				ret = -ENOMEM;
-				goto out;
-			} else
-				memcpy(data, (void *) block->data, block->size);
-		}
-	}
-out:
-	if (response)
-		sst_free_block(sst, block);
-	test_and_clear_bit(pvt_id, &sst->pvt_id);
-	return ret;
-}
-
-int sst_pm_runtime_put(struct intel_sst_drv *sst_drv)
-{
-	int ret;
-
-	pm_runtime_mark_last_busy(sst_drv->dev);
-	ret = pm_runtime_put_autosuspend(sst_drv->dev);
-	if (ret < 0)
-		return ret;
-	return 0;
-}
-
-void sst_fill_header_mrfld(union ipc_header_mrfld *header,
-				int msg, int task_id, int large, int drv_id)
-{
-	header->full = 0;
-	header->p.header_high.part.msg_id = msg;
-	header->p.header_high.part.task_id = task_id;
-	header->p.header_high.part.large = large;
-	header->p.header_high.part.drv_id = drv_id;
-	header->p.header_high.part.done = 0;
-	header->p.header_high.part.busy = 1;
-	header->p.header_high.part.res_rqd = 1;
-}
-
-void sst_fill_header_dsp(struct ipc_dsp_hdr *dsp, int msg,
-					int pipe_id, int len)
-{
-	dsp->cmd_id = msg;
-	dsp->mod_index_id = 0xff;
-	dsp->pipe_id = pipe_id;
-	dsp->length = len;
-	dsp->mod_id = 0;
-}
-
-#define SST_MAX_BLOCKS 15
-/*
- * sst_assign_pvt_id - assign a pvt id for stream
- *
- * @sst_drv_ctx : driver context
- *
- * this function assigns a private id for calls that dont have stream
- * context yet, should be called with lock held
- * uses bits for the id, and finds first free bits and assigns that
- */
-int sst_assign_pvt_id(struct intel_sst_drv *drv)
-{
-	int local;
-
-	spin_lock(&drv->block_lock);
-	/* find first zero index from lsb */
-	local = ffz(drv->pvt_id);
-	dev_dbg(drv->dev, "pvt_id assigned --> %d\n", local);
-	if (local >= SST_MAX_BLOCKS){
-		spin_unlock(&drv->block_lock);
-		dev_err(drv->dev, "PVT _ID error: no free id blocks ");
-		return -EINVAL;
-	}
-	/* toggle the index */
-	change_bit(local, &drv->pvt_id);
-	spin_unlock(&drv->block_lock);
-	return local;
-}
-
-void sst_init_stream(struct stream_info *stream,
-		int codec, int sst_id, int ops, u8 slot)
-{
-	stream->status = STREAM_INIT;
-	stream->prev = STREAM_UN_INIT;
-	stream->ops = ops;
-}
-
-int sst_validate_strid(
-		struct intel_sst_drv *sst_drv_ctx, int str_id)
-{
-	if (str_id <= 0 || str_id > sst_drv_ctx->info.max_streams) {
-		dev_err(sst_drv_ctx->dev,
-			"SST ERR: invalid stream id : %d, max %d\n",
-			str_id, sst_drv_ctx->info.max_streams);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-struct stream_info *get_stream_info(
-		struct intel_sst_drv *sst_drv_ctx, int str_id)
-{
-	if (sst_validate_strid(sst_drv_ctx, str_id))
-		return NULL;
-	return &sst_drv_ctx->streams[str_id];
-}
-
-int get_stream_id_mrfld(struct intel_sst_drv *sst_drv_ctx,
-		u32 pipe_id)
-{
-	int i;
-
-	for (i = 1; i <= sst_drv_ctx->info.max_streams; i++)
-		if (pipe_id == sst_drv_ctx->streams[i].pipe_id)
-			return i;
-
-	dev_dbg(sst_drv_ctx->dev, "no such pipe_id(%u)", pipe_id);
-	return -1;
-}
-
-u32 relocate_imr_addr_mrfld(u32 base_addr)
-{
-	/* Get the difference from 512MB aligned base addr */
-	/* relocate the base */
-	base_addr = MRFLD_FW_VIRTUAL_BASE + (base_addr % (512 * 1024 * 1024));
-	return base_addr;
-}
-EXPORT_SYMBOL_GPL(relocate_imr_addr_mrfld);
-
-void sst_add_to_dispatch_list_and_post(struct intel_sst_drv *sst,
-						struct ipc_post *msg)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&sst->ipc_spin_lock, irq_flags);
-	list_add_tail(&msg->node, &sst->ipc_dispatch_list);
-	spin_unlock_irqrestore(&sst->ipc_spin_lock, irq_flags);
-	sst->ops->post_message(sst, NULL, false);
-}
diff -Naur linux-3.19.old/sound/soc/intel/sst/sst_stream.c linux-3.19/sound/soc/intel/sst/sst_stream.c
--- linux-3.19.old/sound/soc/intel/sst/sst_stream.c	2015-03-24 17:38:14.443176946 -0800
+++ linux-3.19/sound/soc/intel/sst/sst_stream.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,437 +0,0 @@
-/*
- *  sst_stream.c - Intel SST Driver for audio engine
- *
- *  Copyright (C) 2008-14 Intel Corp
- *  Authors:	Vinod Koul <vinod.koul@intel.com>
- *		Harsha Priya <priya.harsha@intel.com>
- *		Dharageswari R <dharageswari.r@intel.com>
- *		KP Jeeja <jeeja.kp@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-#include <linux/pci.h>
-#include <linux/firmware.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/pm_runtime.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/soc.h>
-#include <sound/compress_driver.h>
-#include <asm/platform_sst_audio.h>
-#include "../sst-mfld-platform.h"
-#include "sst.h"
-#include "../sst-dsp.h"
-
-int sst_alloc_stream_mrfld(struct intel_sst_drv *sst_drv_ctx, void *params)
-{
-	struct snd_sst_alloc_mrfld alloc_param;
-	struct snd_sst_params *str_params;
-	struct snd_sst_tstamp fw_tstamp;
-	struct stream_info *str_info;
-	struct snd_sst_alloc_response *response;
-	unsigned int str_id, pipe_id, task_id;
-	int i, num_ch, ret = 0;
-	void *data = NULL;
-
-	dev_dbg(sst_drv_ctx->dev, "Enter\n");
-	BUG_ON(!params);
-
-	str_params = (struct snd_sst_params *)params;
-	memset(&alloc_param, 0, sizeof(alloc_param));
-	alloc_param.operation = str_params->ops;
-	alloc_param.codec_type = str_params->codec;
-	alloc_param.sg_count = str_params->aparams.sg_count;
-	alloc_param.ring_buf_info[0].addr =
-		str_params->aparams.ring_buf_info[0].addr;
-	alloc_param.ring_buf_info[0].size =
-		str_params->aparams.ring_buf_info[0].size;
-	alloc_param.frag_size = str_params->aparams.frag_size;
-
-	memcpy(&alloc_param.codec_params, &str_params->sparams,
-			sizeof(struct snd_sst_stream_params));
-
-	/*
-	 * fill channel map params for multichannel support.
-	 * Ideally channel map should be received from upper layers
-	 * for multichannel support.
-	 * Currently hardcoding as per FW reqm.
-	 */
-	num_ch = sst_get_num_channel(str_params);
-	for (i = 0; i < 8; i++) {
-		if (i < num_ch)
-			alloc_param.codec_params.uc.pcm_params.channel_map[i] = i;
-		else
-			alloc_param.codec_params.uc.pcm_params.channel_map[i] = 0xFF;
-	}
-
-	str_id = str_params->stream_id;
-	str_info = get_stream_info(sst_drv_ctx, str_id);
-	if (str_info == NULL) {
-		dev_err(sst_drv_ctx->dev, "get stream info returned null\n");
-		return -EINVAL;
-	}
-
-	pipe_id = str_params->device_type;
-	task_id = str_params->task;
-	sst_drv_ctx->streams[str_id].pipe_id = pipe_id;
-	sst_drv_ctx->streams[str_id].task_id = task_id;
-	sst_drv_ctx->streams[str_id].num_ch = num_ch;
-
-	if (sst_drv_ctx->info.lpe_viewpt_rqd)
-		alloc_param.ts = sst_drv_ctx->info.mailbox_start +
-			sst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));
-	else
-		alloc_param.ts = sst_drv_ctx->mailbox_add +
-			sst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));
-
-	dev_dbg(sst_drv_ctx->dev, "alloc tstamp location = 0x%x\n",
-			alloc_param.ts);
-	dev_dbg(sst_drv_ctx->dev, "assigned pipe id 0x%x to task %d\n",
-			pipe_id, task_id);
-
-	/* allocate device type context */
-	sst_init_stream(&sst_drv_ctx->streams[str_id], alloc_param.codec_type,
-			str_id, alloc_param.operation, 0);
-
-	dev_info(sst_drv_ctx->dev, "Alloc for str %d pipe %#x\n",
-			str_id, pipe_id);
-	ret = sst_prepare_and_post_msg(sst_drv_ctx, task_id, IPC_CMD,
-			IPC_IA_ALLOC_STREAM_MRFLD, pipe_id, sizeof(alloc_param),
-			&alloc_param, data, true, true, false, true);
-
-	if (ret < 0) {
-		dev_err(sst_drv_ctx->dev, "FW alloc failed ret %d\n", ret);
-		/* alloc failed, so reset the state to uninit */
-		str_info->status = STREAM_UN_INIT;
-		str_id = ret;
-	} else if (data) {
-		response = (struct snd_sst_alloc_response *)data;
-		ret = response->str_type.result;
-		if (!ret)
-			goto out;
-		dev_err(sst_drv_ctx->dev, "FW alloc failed ret %d\n", ret);
-		if (ret == SST_ERR_STREAM_IN_USE) {
-			dev_err(sst_drv_ctx->dev,
-				"FW not in clean state, send free for:%d\n", str_id);
-			sst_free_stream(sst_drv_ctx, str_id);
-		}
-		str_id = -ret;
-	}
-out:
-	kfree(data);
-	return str_id;
-}
-
-/**
-* sst_start_stream - Send msg for a starting stream
-* @str_id:	 stream ID
-*
-* This function is called by any function which wants to start
-* a stream.
-*/
-int sst_start_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)
-{
-	int retval = 0;
-	struct stream_info *str_info;
-	u16 data = 0;
-
-	dev_dbg(sst_drv_ctx->dev, "sst_start_stream for %d\n", str_id);
-	str_info = get_stream_info(sst_drv_ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-	if (str_info->status != STREAM_RUNNING)
-		return -EBADRQC;
-
-	retval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id,
-			IPC_CMD, IPC_IA_START_STREAM_MRFLD, str_info->pipe_id,
-			sizeof(u16), &data, NULL, true, true, true, false);
-
-	return retval;
-}
-
-int sst_send_byte_stream_mrfld(struct intel_sst_drv *sst_drv_ctx,
-		struct snd_sst_bytes_v2 *bytes)
-{	struct ipc_post *msg = NULL;
-	u32 length;
-	int pvt_id, ret = 0;
-	struct sst_block *block = NULL;
-
-	dev_dbg(sst_drv_ctx->dev,
-		"type:%u ipc_msg:%u block:%u task_id:%u pipe: %#x length:%#x\n",
-		bytes->type, bytes->ipc_msg, bytes->block, bytes->task_id,
-		bytes->pipe_id, bytes->len);
-
-	if (sst_create_ipc_msg(&msg, true))
-		return -ENOMEM;
-
-	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
-	sst_fill_header_mrfld(&msg->mrfld_header, bytes->ipc_msg,
-			bytes->task_id, 1, pvt_id);
-	msg->mrfld_header.p.header_high.part.res_rqd = bytes->block;
-	length = bytes->len;
-	msg->mrfld_header.p.header_low_payload = length;
-	dev_dbg(sst_drv_ctx->dev, "length is %d\n", length);
-	memcpy(msg->mailbox_data, &bytes->bytes, bytes->len);
-	if (bytes->block) {
-		block = sst_create_block(sst_drv_ctx, bytes->ipc_msg, pvt_id);
-		if (block == NULL) {
-			kfree(msg);
-			ret = -ENOMEM;
-			goto out;
-		}
-	}
-
-	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
-	dev_dbg(sst_drv_ctx->dev, "msg->mrfld_header.p.header_low_payload:%d",
-			msg->mrfld_header.p.header_low_payload);
-
-	if (bytes->block) {
-		ret = sst_wait_timeout(sst_drv_ctx, block);
-		if (ret) {
-			dev_err(sst_drv_ctx->dev, "fw returned err %d\n", ret);
-			sst_free_block(sst_drv_ctx, block);
-			goto out;
-		}
-	}
-	if (bytes->type == SND_SST_BYTES_GET) {
-		/*
-		 * copy the reply and send back
-		 * we need to update only sz and payload
-		 */
-		if (bytes->block) {
-			unsigned char *r = block->data;
-
-			dev_dbg(sst_drv_ctx->dev, "read back %d bytes",
-					bytes->len);
-			memcpy(bytes->bytes, r, bytes->len);
-		}
-	}
-	if (bytes->block)
-		sst_free_block(sst_drv_ctx, block);
-out:
-	test_and_clear_bit(pvt_id, &sst_drv_ctx->pvt_id);
-	return 0;
-}
-
-/*
- * sst_pause_stream - Send msg for a pausing stream
- * @str_id:	 stream ID
- *
- * This function is called by any function which wants to pause
- * an already running stream.
- */
-int sst_pause_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)
-{
-	int retval = 0;
-	struct stream_info *str_info;
-
-	dev_dbg(sst_drv_ctx->dev, "SST DBG:sst_pause_stream for %d\n", str_id);
-	str_info = get_stream_info(sst_drv_ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-	if (str_info->status == STREAM_PAUSED)
-		return 0;
-	if (str_info->status == STREAM_RUNNING ||
-		str_info->status == STREAM_INIT) {
-		if (str_info->prev == STREAM_UN_INIT)
-			return -EBADRQC;
-
-		retval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,
-				IPC_IA_PAUSE_STREAM_MRFLD, str_info->pipe_id,
-				0, NULL, NULL, true, true, false, true);
-
-		if (retval == 0) {
-			str_info->prev = str_info->status;
-			str_info->status = STREAM_PAUSED;
-		} else if (retval == SST_ERR_INVALID_STREAM_ID) {
-			retval = -EINVAL;
-			mutex_lock(&sst_drv_ctx->sst_lock);
-			sst_clean_stream(str_info);
-			mutex_unlock(&sst_drv_ctx->sst_lock);
-		}
-	} else {
-		retval = -EBADRQC;
-		dev_dbg(sst_drv_ctx->dev, "SST DBG:BADRQC for stream\n ");
-	}
-
-	return retval;
-}
-
-/**
- * sst_resume_stream - Send msg for resuming stream
- * @str_id:		stream ID
- *
- * This function is called by any function which wants to resume
- * an already paused stream.
- */
-int sst_resume_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)
-{
-	int retval = 0;
-	struct stream_info *str_info;
-
-	dev_dbg(sst_drv_ctx->dev, "SST DBG:sst_resume_stream for %d\n", str_id);
-	str_info = get_stream_info(sst_drv_ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-	if (str_info->status == STREAM_RUNNING)
-			return 0;
-	if (str_info->status == STREAM_PAUSED) {
-		retval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id,
-				IPC_CMD, IPC_IA_RESUME_STREAM_MRFLD,
-				str_info->pipe_id, 0, NULL, NULL,
-				true, true, false, true);
-
-		if (!retval) {
-			if (str_info->prev == STREAM_RUNNING)
-				str_info->status = STREAM_RUNNING;
-			else
-				str_info->status = STREAM_INIT;
-			str_info->prev = STREAM_PAUSED;
-		} else if (retval == -SST_ERR_INVALID_STREAM_ID) {
-			retval = -EINVAL;
-			mutex_lock(&sst_drv_ctx->sst_lock);
-			sst_clean_stream(str_info);
-			mutex_unlock(&sst_drv_ctx->sst_lock);
-		}
-	} else {
-		retval = -EBADRQC;
-		dev_err(sst_drv_ctx->dev, "SST ERR: BADQRC for stream\n");
-	}
-
-	return retval;
-}
-
-
-/**
- * sst_drop_stream - Send msg for stopping stream
- * @str_id:		stream ID
- *
- * This function is called by any function which wants to stop
- * a stream.
- */
-int sst_drop_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)
-{
-	int retval = 0;
-	struct stream_info *str_info;
-
-	dev_dbg(sst_drv_ctx->dev, "SST DBG:sst_drop_stream for %d\n", str_id);
-	str_info = get_stream_info(sst_drv_ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-
-	if (str_info->status != STREAM_UN_INIT) {
-		str_info->prev = STREAM_UN_INIT;
-		str_info->status = STREAM_INIT;
-		str_info->cumm_bytes = 0;
-		retval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id,
-				IPC_CMD, IPC_IA_DROP_STREAM_MRFLD,
-				str_info->pipe_id, 0, NULL, NULL,
-				true, true, true, false);
-	} else {
-		retval = -EBADRQC;
-		dev_dbg(sst_drv_ctx->dev, "BADQRC for stream, state %x\n",
-				str_info->status);
-	}
-	return retval;
-}
-
-/**
-* sst_drain_stream - Send msg for draining stream
-* @str_id:		stream ID
-*
-* This function is called by any function which wants to drain
-* a stream.
-*/
-int sst_drain_stream(struct intel_sst_drv *sst_drv_ctx,
-			int str_id, bool partial_drain)
-{
-	int retval = 0;
-	struct stream_info *str_info;
-
-	dev_dbg(sst_drv_ctx->dev, "SST DBG:sst_drain_stream for %d\n", str_id);
-	str_info = get_stream_info(sst_drv_ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-	if (str_info->status != STREAM_RUNNING &&
-		str_info->status != STREAM_INIT &&
-		str_info->status != STREAM_PAUSED) {
-			dev_err(sst_drv_ctx->dev, "SST ERR: BADQRC for stream = %d\n",
-				       str_info->status);
-			return -EBADRQC;
-	}
-
-	retval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,
-			IPC_IA_DRAIN_STREAM_MRFLD, str_info->pipe_id,
-			sizeof(u8), &partial_drain, NULL, true, true, false, false);
-	/*
-	 * with new non blocked drain implementation in core we dont need to
-	 * wait for respsonse, and need to only invoke callback for drain
-	 * complete
-	 */
-
-	return retval;
-}
-
-/**
- * sst_free_stream - Frees a stream
- * @str_id:		stream ID
- *
- * This function is called by any function which wants to free
- * a stream.
- */
-int sst_free_stream(struct intel_sst_drv *sst_drv_ctx, int str_id)
-{
-	int retval = 0;
-	struct stream_info *str_info;
-	struct intel_sst_ops *ops;
-
-	dev_dbg(sst_drv_ctx->dev, "SST DBG:sst_free_stream for %d\n", str_id);
-
-	mutex_lock(&sst_drv_ctx->sst_lock);
-	if (sst_drv_ctx->sst_state == SST_RESET) {
-		mutex_unlock(&sst_drv_ctx->sst_lock);
-		return -ENODEV;
-	}
-	mutex_unlock(&sst_drv_ctx->sst_lock);
-	str_info = get_stream_info(sst_drv_ctx, str_id);
-	if (!str_info)
-		return -EINVAL;
-	ops = sst_drv_ctx->ops;
-
-	mutex_lock(&str_info->lock);
-	if (str_info->status != STREAM_UN_INIT) {
-		str_info->prev =  str_info->status;
-		str_info->status = STREAM_UN_INIT;
-		mutex_unlock(&str_info->lock);
-
-		dev_info(sst_drv_ctx->dev, "Free for str %d pipe %#x\n",
-				str_id, str_info->pipe_id);
-		retval = sst_prepare_and_post_msg(sst_drv_ctx, str_info->task_id, IPC_CMD,
-				IPC_IA_FREE_STREAM_MRFLD, str_info->pipe_id, 0,
-				NULL, NULL, true, true, false, true);
-
-		dev_dbg(sst_drv_ctx->dev, "sst: wait for free returned %d\n",
-				retval);
-		mutex_lock(&sst_drv_ctx->sst_lock);
-		sst_clean_stream(str_info);
-		mutex_unlock(&sst_drv_ctx->sst_lock);
-		dev_dbg(sst_drv_ctx->dev, "SST DBG:Stream freed\n");
-	} else {
-		mutex_unlock(&str_info->lock);
-		retval = -EBADRQC;
-		dev_dbg(sst_drv_ctx->dev, "SST DBG:BADQRC for stream\n");
-	}
-
-	return retval;
-}
diff -Naur linux-3.19.old/sound/soc/intel/sst-acpi.c linux-3.19/sound/soc/intel/sst-acpi.c
--- linux-3.19.old/sound/soc/intel/sst-acpi.c	2015-03-24 17:38:14.396510281 -0800
+++ linux-3.19/sound/soc/intel/sst-acpi.c	2015-03-24 18:19:04.684663440 -0800
@@ -229,6 +229,7 @@
 
 static struct sst_acpi_mach broadwell_machines[] = {
 	{ "INT343A", "broadwell-audio", "intel/IntcSST2.bin" },
+	{ "RT5677CE", "bdw-rt5677", "intel/IntcSST2.bin" },
 	{}
 };
 
@@ -246,8 +247,8 @@
 };
 
 static struct sst_acpi_mach baytrail_machines[] = {
-	{ "10EC5640", "byt-rt5640", "intel/fw_sst_0f28.bin-48kHz_i2s_master" },
-	{ "193C9890", "byt-max98090", "intel/fw_sst_0f28.bin-48kHz_i2s_master" },
+	{ "10EC5640", "byt-rt5640", "intel/fw_sst_0f28.bin-i2s_master" },
+	{ "193C9890", "byt-max98090", "intel/fw_sst_0f28.bin-i2s_master" },
 	{}
 };
 
@@ -275,6 +276,7 @@
 	.remove = sst_acpi_remove,
 	.driver = {
 		.name = "sst-acpi",
+		.owner = THIS_MODULE,
 		.acpi_match_table = ACPI_PTR(sst_acpi_match),
 	},
 };
diff -Naur linux-3.19.old/sound/soc/intel/sst-atom-controls.c linux-3.19/sound/soc/intel/sst-atom-controls.c
--- linux-3.19.old/sound/soc/intel/sst-atom-controls.c	2015-03-24 17:38:14.403176947 -0800
+++ linux-3.19/sound/soc/intel/sst-atom-controls.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,1422 +0,0 @@
-/*
- *  sst-atom-controls.c - Intel MID Platform driver DPCM ALSA controls for Mrfld
- *
- *  Copyright (C) 2013-14 Intel Corp
- *  Author: Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
- *	Vinod Koul <vinod.koul@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  In the dpcm driver modelling when a particular FE/BE/Mixer/Pipe is active
- *  we forward the settings and parameters, rest we keep the values  in
- *  driver and forward when DAPM enables them
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/slab.h>
-#include <sound/soc.h>
-#include <sound/tlv.h>
-#include "sst-mfld-platform.h"
-#include "sst-atom-controls.h"
-
-static int sst_fill_byte_control(struct sst_data *drv,
-					 u8 ipc_msg, u8 block,
-					 u8 task_id, u8 pipe_id,
-					 u16 len, void *cmd_data)
-{
-	struct snd_sst_bytes_v2 *byte_data = drv->byte_stream;
-
-	byte_data->type = SST_CMD_BYTES_SET;
-	byte_data->ipc_msg = ipc_msg;
-	byte_data->block = block;
-	byte_data->task_id = task_id;
-	byte_data->pipe_id = pipe_id;
-
-	if (len > SST_MAX_BIN_BYTES - sizeof(*byte_data)) {
-		dev_err(&drv->pdev->dev, "command length too big (%u)", len);
-		return -EINVAL;
-	}
-	byte_data->len = len;
-	memcpy(byte_data->bytes, cmd_data, len);
-	print_hex_dump_bytes("writing to lpe: ", DUMP_PREFIX_OFFSET,
-			     byte_data, len + sizeof(*byte_data));
-	return 0;
-}
-
-static int sst_fill_and_send_cmd_unlocked(struct sst_data *drv,
-				 u8 ipc_msg, u8 block, u8 task_id, u8 pipe_id,
-				 void *cmd_data, u16 len)
-{
-	int ret = 0;
-
-	ret = sst_fill_byte_control(drv, ipc_msg,
-				block, task_id, pipe_id, len, cmd_data);
-	if (ret < 0)
-		return ret;
-	return sst->ops->send_byte_stream(sst->dev, drv->byte_stream);
-}
-
-/**
- * sst_fill_and_send_cmd - generate the IPC message and send it to the FW
- * @ipc_msg:	type of IPC (CMD, SET_PARAMS, GET_PARAMS)
- * @cmd_data:	the IPC payload
- */
-static int sst_fill_and_send_cmd(struct sst_data *drv,
-				 u8 ipc_msg, u8 block, u8 task_id, u8 pipe_id,
-				 void *cmd_data, u16 len)
-{
-	int ret;
-
-	mutex_lock(&drv->lock);
-	ret = sst_fill_and_send_cmd_unlocked(drv, ipc_msg, block,
-					task_id, pipe_id, cmd_data, len);
-	mutex_unlock(&drv->lock);
-
-	return ret;
-}
-
-/**
- * tx map value is a bitfield where each bit represents a FW channel
- *
- *			3 2 1 0		# 0 = codec0, 1 = codec1
- *			RLRLRLRL	# 3, 4 = reserved
- *
- * e.g. slot 0 rx map =	00001100b -> data from slot 0 goes into codec_in1 L,R
- */
-static u8 sst_ssp_tx_map[SST_MAX_TDM_SLOTS] = {
-	0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, /* default rx map */
-};
-
-/**
- * rx map value is a bitfield where each bit represents a slot
- *
- *			  76543210	# 0 = slot 0, 1 = slot 1
- *
- * e.g. codec1_0 tx map = 00000101b -> data from codec_out1_0 goes into slot 0, 2
- */
-static u8 sst_ssp_rx_map[SST_MAX_TDM_SLOTS] = {
-	0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, /* default tx map */
-};
-
-/**
- * NOTE: this is invoked with lock held
- */
-static int sst_send_slot_map(struct sst_data *drv)
-{
-	struct sst_param_sba_ssp_slot_map cmd;
-
-	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
-	cmd.header.command_id = SBA_SET_SSP_SLOT_MAP;
-	cmd.header.length = sizeof(struct sst_param_sba_ssp_slot_map)
-				- sizeof(struct sst_dsp_header);
-
-	cmd.param_id = SBA_SET_SSP_SLOT_MAP;
-	cmd.param_len = sizeof(cmd.rx_slot_map) + sizeof(cmd.tx_slot_map)
-					+ sizeof(cmd.ssp_index);
-	cmd.ssp_index = SSP_CODEC;
-
-	memcpy(cmd.rx_slot_map, &sst_ssp_tx_map[0], sizeof(cmd.rx_slot_map));
-	memcpy(cmd.tx_slot_map, &sst_ssp_rx_map[0], sizeof(cmd.tx_slot_map));
-
-	return sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_SET_PARAMS,
-			SST_FLAG_BLOCKED, SST_TASK_SBA, 0, &cmd,
-			      sizeof(cmd.header) + cmd.header.length);
-}
-
-int sst_slot_enum_info(struct snd_kcontrol *kcontrol,
-		       struct snd_ctl_elem_info *uinfo)
-{
-	struct sst_enum *e = (struct sst_enum *)kcontrol->private_value;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = e->max;
-
-	if (uinfo->value.enumerated.item > e->max - 1)
-		uinfo->value.enumerated.item = e->max - 1;
-	strcpy(uinfo->value.enumerated.name,
-		e->texts[uinfo->value.enumerated.item]);
-
-	return 0;
-}
-
-/**
- * sst_slot_get - get the status of the interleaver/deinterleaver control
- *
- * Searches the map where the control status is stored, and gets the
- * channel/slot which is currently set for this enumerated control. Since it is
- * an enumerated control, there is only one possible value.
- */
-static int sst_slot_get(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_value *ucontrol)
-{
-	struct sst_enum *e = (void *)kcontrol->private_value;
-	struct snd_soc_component *c = snd_kcontrol_chip(kcontrol);
-	struct sst_data *drv = snd_soc_component_get_drvdata(c);
-	unsigned int ctl_no = e->reg;
-	unsigned int is_tx = e->tx;
-	unsigned int val, mux;
-	u8 *map = is_tx ? sst_ssp_rx_map : sst_ssp_tx_map;
-
-	mutex_lock(&drv->lock);
-	val = 1 << ctl_no;
-	/* search which slot/channel has this bit set - there should be only one */
-	for (mux = e->max; mux > 0;  mux--)
-		if (map[mux - 1] & val)
-			break;
-
-	ucontrol->value.enumerated.item[0] = mux;
-	mutex_unlock(&drv->lock);
-
-	dev_dbg(c->dev, "%s - %s map = %#x\n",
-			is_tx ? "tx channel" : "rx slot",
-			 e->texts[mux], mux ? map[mux - 1] : -1);
-	return 0;
-}
-
-/* sst_check_and_send_slot_map - helper for checking power state and sending
- * slot map cmd
- *
- * called with lock held
- */
-static int sst_check_and_send_slot_map(struct sst_data *drv, struct snd_kcontrol *kcontrol)
-{
-	struct sst_enum *e = (void *)kcontrol->private_value;
-	int ret = 0;
-
-	if (e->w && e->w->power)
-		ret = sst_send_slot_map(drv);
-	else
-		dev_err(&drv->pdev->dev, "Slot control: %s doesn't have DAPM widget!!!\n",
-				kcontrol->id.name);
-	return ret;
-}
-
-/**
- * sst_slot_put - set the status of interleaver/deinterleaver control
- *
- * (de)interleaver controls are defined in opposite sense to be user-friendly
- *
- * Instead of the enum value being the value written to the register, it is the
- * register address; and the kcontrol number (register num) is the value written
- * to the register. This is so that there can be only one value for each
- * slot/channel since there is only one control for each slot/channel.
- *
- * This means that whenever an enum is set, we need to clear the bit
- * for that kcontrol_no for all the interleaver OR deinterleaver registers
- */
-static int sst_slot_put(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *c = snd_soc_kcontrol_component(kcontrol);
-	struct sst_data *drv = snd_soc_component_get_drvdata(c);
-	struct sst_enum *e = (void *)kcontrol->private_value;
-	int i, ret = 0;
-	unsigned int ctl_no = e->reg;
-	unsigned int is_tx = e->tx;
-	unsigned int slot_channel_no;
-	unsigned int val, mux;
-	u8 *map;
-
-	map = is_tx ? sst_ssp_rx_map : sst_ssp_tx_map;
-
-	val = 1 << ctl_no;
-	mux = ucontrol->value.enumerated.item[0];
-	if (mux > e->max - 1)
-		return -EINVAL;
-
-	mutex_lock(&drv->lock);
-	/* first clear all registers of this bit */
-	for (i = 0; i < e->max; i++)
-		map[i] &= ~val;
-
-	if (mux == 0) {
-		/* kctl set to 'none' and we reset the bits so send IPC */
-		ret = sst_check_and_send_slot_map(drv, kcontrol);
-
-		mutex_unlock(&drv->lock);
-		return ret;
-	}
-
-	/* offset by one to take "None" into account */
-	slot_channel_no = mux - 1;
-	map[slot_channel_no] |= val;
-
-	dev_dbg(c->dev, "%s %s map = %#x\n",
-			is_tx ? "tx channel" : "rx slot",
-			e->texts[mux], map[slot_channel_no]);
-
-	ret = sst_check_and_send_slot_map(drv, kcontrol);
-
-	mutex_unlock(&drv->lock);
-	return ret;
-}
-
-static int sst_send_algo_cmd(struct sst_data *drv,
-			      struct sst_algo_control *bc)
-{
-	int len, ret = 0;
-	struct sst_cmd_set_params *cmd;
-
-	/*bc->max includes sizeof algos + length field*/
-	len = sizeof(cmd->dst) + sizeof(cmd->command_id) + bc->max;
-
-	cmd = kzalloc(len, GFP_KERNEL);
-	if (cmd == NULL)
-		return -ENOMEM;
-
-	SST_FILL_DESTINATION(2, cmd->dst, bc->pipe_id, bc->module_id);
-	cmd->command_id = bc->cmd_id;
-	memcpy(cmd->params, bc->params, bc->max);
-
-	ret = sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_SET_PARAMS,
-				SST_FLAG_BLOCKED, bc->task_id, 0, cmd, len);
-	kfree(cmd);
-	return ret;
-}
-
-/**
- * sst_find_and_send_pipe_algo - send all the algo parameters for a pipe
- *
- * The algos which are in each pipeline are sent to the firmware one by one
- *
- * Called with lock held
- */
-static int sst_find_and_send_pipe_algo(struct sst_data *drv,
-					const char *pipe, struct sst_ids *ids)
-{
-	int ret = 0;
-	struct sst_algo_control *bc;
-	struct sst_module *algo = NULL;
-
-	dev_dbg(&drv->pdev->dev, "Enter: widget=%s\n", pipe);
-
-	list_for_each_entry(algo, &ids->algo_list, node) {
-		bc = (void *)algo->kctl->private_value;
-
-		dev_dbg(&drv->pdev->dev, "Found algo control name=%s pipe=%s\n",
-				algo->kctl->id.name, pipe);
-		ret = sst_send_algo_cmd(drv, bc);
-		if (ret)
-			return ret;
-	}
-	return ret;
-}
-
-static int sst_algo_bytes_ctl_info(struct snd_kcontrol *kcontrol,
-			    struct snd_ctl_elem_info *uinfo)
-{
-	struct sst_algo_control *bc = (void *)kcontrol->private_value;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	uinfo->count = bc->max;
-
-	return 0;
-}
-
-static int sst_algo_control_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	struct sst_algo_control *bc = (void *)kcontrol->private_value;
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-
-	switch (bc->type) {
-	case SST_ALGO_PARAMS:
-		memcpy(ucontrol->value.bytes.data, bc->params, bc->max);
-		break;
-	default:
-		dev_err(component->dev, "Invalid Input- algo type:%d\n",
-				bc->type);
-		return -EINVAL;
-
-	}
-	return 0;
-}
-
-static int sst_algo_control_set(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol)
-{
-	int ret = 0;
-	struct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);
-	struct sst_data *drv = snd_soc_component_get_drvdata(cmpnt);
-	struct sst_algo_control *bc = (void *)kcontrol->private_value;
-
-	dev_dbg(cmpnt->dev, "control_name=%s\n", kcontrol->id.name);
-	mutex_lock(&drv->lock);
-	switch (bc->type) {
-	case SST_ALGO_PARAMS:
-		memcpy(bc->params, ucontrol->value.bytes.data, bc->max);
-		break;
-	default:
-		mutex_unlock(&drv->lock);
-		dev_err(cmpnt->dev, "Invalid Input- algo type:%d\n",
-				bc->type);
-		return -EINVAL;
-	}
-	/*if pipe is enabled, need to send the algo params from here*/
-	if (bc->w && bc->w->power)
-		ret = sst_send_algo_cmd(drv, bc);
-	mutex_unlock(&drv->lock);
-
-	return ret;
-}
-
-static int sst_gain_ctl_info(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = mc->stereo ? 2 : 1;
-	uinfo->value.integer.min = mc->min;
-	uinfo->value.integer.max = mc->max;
-
-	return 0;
-}
-
-/**
- * sst_send_gain_cmd - send the gain algorithm IPC to the FW
- * @gv:		the stored value of gain (also contains rampduration)
- * @mute:	flag that indicates whether this was called from the
- *		digital_mute callback or directly. If called from the
- *		digital_mute callback, module will be muted/unmuted based on this
- *		flag. The flag is always 0 if called directly.
- *
- * Called with sst_data.lock held
- *
- * The user-set gain value is sent only if the user-controllable 'mute' control
- * is OFF (indicated by gv->mute). Otherwise, the mute value (MIN value) is
- * sent.
- */
-static int sst_send_gain_cmd(struct sst_data *drv, struct sst_gain_value *gv,
-			      u16 task_id, u16 loc_id, u16 module_id, int mute)
-{
-	struct sst_cmd_set_gain_dual cmd;
-
-	dev_dbg(&drv->pdev->dev, "Enter\n");
-
-	cmd.header.command_id = MMX_SET_GAIN;
-	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
-	cmd.gain_cell_num = 1;
-
-	if (mute || gv->mute) {
-		cmd.cell_gains[0].cell_gain_left = SST_GAIN_MIN_VALUE;
-		cmd.cell_gains[0].cell_gain_right = SST_GAIN_MIN_VALUE;
-	} else {
-		cmd.cell_gains[0].cell_gain_left = gv->l_gain;
-		cmd.cell_gains[0].cell_gain_right = gv->r_gain;
-	}
-
-	SST_FILL_DESTINATION(2, cmd.cell_gains[0].dest,
-			     loc_id, module_id);
-	cmd.cell_gains[0].gain_time_constant = gv->ramp_duration;
-
-	cmd.header.length = sizeof(struct sst_cmd_set_gain_dual)
-				- sizeof(struct sst_dsp_header);
-
-	/* we are with lock held, so call the unlocked api  to send */
-	return sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_SET_PARAMS,
-				SST_FLAG_BLOCKED, task_id, 0, &cmd,
-			      sizeof(cmd.header) + cmd.header.length);
-}
-
-static int sst_gain_get(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;
-	struct sst_gain_value *gv = mc->gain_val;
-
-	switch (mc->type) {
-	case SST_GAIN_TLV:
-		ucontrol->value.integer.value[0] = gv->l_gain;
-		ucontrol->value.integer.value[1] = gv->r_gain;
-		break;
-
-	case SST_GAIN_MUTE:
-		ucontrol->value.integer.value[0] = gv->mute ? 1 : 0;
-		break;
-
-	case SST_GAIN_RAMP_DURATION:
-		ucontrol->value.integer.value[0] = gv->ramp_duration;
-		break;
-
-	default:
-		dev_err(component->dev, "Invalid Input- gain type:%d\n",
-				mc->type);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int sst_gain_put(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_value *ucontrol)
-{
-	int ret = 0;
-	struct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);
-	struct sst_data *drv = snd_soc_component_get_drvdata(cmpnt);
-	struct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;
-	struct sst_gain_value *gv = mc->gain_val;
-
-	mutex_lock(&drv->lock);
-
-	switch (mc->type) {
-	case SST_GAIN_TLV:
-		gv->l_gain = ucontrol->value.integer.value[0];
-		gv->r_gain = ucontrol->value.integer.value[1];
-		dev_dbg(cmpnt->dev, "%s: Volume %d, %d\n",
-				mc->pname, gv->l_gain, gv->r_gain);
-		break;
-
-	case SST_GAIN_MUTE:
-		gv->mute = !!ucontrol->value.integer.value[0];
-		dev_dbg(cmpnt->dev, "%s: Mute %d\n", mc->pname, gv->mute);
-		break;
-
-	case SST_GAIN_RAMP_DURATION:
-		gv->ramp_duration = ucontrol->value.integer.value[0];
-		dev_dbg(cmpnt->dev, "%s: Ramp Delay%d\n",
-					mc->pname, gv->ramp_duration);
-		break;
-
-	default:
-		mutex_unlock(&drv->lock);
-		dev_err(cmpnt->dev, "Invalid Input- gain type:%d\n",
-				mc->type);
-		return -EINVAL;
-	}
-
-	if (mc->w && mc->w->power)
-		ret = sst_send_gain_cmd(drv, gv, mc->task_id,
-			mc->pipe_id | mc->instance_id, mc->module_id, 0);
-	mutex_unlock(&drv->lock);
-
-	return ret;
-}
-
-static int sst_set_pipe_gain(struct sst_ids *ids,
-				struct sst_data *drv, int mute);
-
-static int sst_send_pipe_module_params(struct snd_soc_dapm_widget *w,
-		struct snd_kcontrol *kcontrol)
-{
-	struct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);
-	struct sst_data *drv = snd_soc_component_get_drvdata(c);
-	struct sst_ids *ids = w->priv;
-
-	mutex_lock(&drv->lock);
-	sst_find_and_send_pipe_algo(drv, w->name, ids);
-	sst_set_pipe_gain(ids, drv, 0);
-	mutex_unlock(&drv->lock);
-
-	return 0;
-}
-
-static int sst_generic_modules_event(struct snd_soc_dapm_widget *w,
-				     struct snd_kcontrol *k, int event)
-{
-	if (SND_SOC_DAPM_EVENT_ON(event))
-		return sst_send_pipe_module_params(w, k);
-	return 0;
-}
-
-static const DECLARE_TLV_DB_SCALE(sst_gain_tlv_common, SST_GAIN_MIN_VALUE * 10, 10, 0);
-
-/* Look up table to convert MIXER SW bit regs to SWM inputs */
-static const uint swm_mixer_input_ids[SST_SWM_INPUT_COUNT] = {
-	[SST_IP_CODEC0]		= SST_SWM_IN_CODEC0,
-	[SST_IP_CODEC1]		= SST_SWM_IN_CODEC1,
-	[SST_IP_LOOP0]		= SST_SWM_IN_SPROT_LOOP,
-	[SST_IP_LOOP1]		= SST_SWM_IN_MEDIA_LOOP1,
-	[SST_IP_LOOP2]		= SST_SWM_IN_MEDIA_LOOP2,
-	[SST_IP_PCM0]		= SST_SWM_IN_PCM0,
-	[SST_IP_PCM1]		= SST_SWM_IN_PCM1,
-	[SST_IP_MEDIA0]		= SST_SWM_IN_MEDIA0,
-	[SST_IP_MEDIA1]		= SST_SWM_IN_MEDIA1,
-	[SST_IP_MEDIA2]		= SST_SWM_IN_MEDIA2,
-	[SST_IP_MEDIA3]		= SST_SWM_IN_MEDIA3,
-};
-
-/**
- * fill_swm_input - fill in the SWM input ids given the register
- *
- * The register value is a bit-field inicated which mixer inputs are ON. Use the
- * lookup table to get the input-id and fill it in the structure.
- */
-static int fill_swm_input(struct snd_soc_component *cmpnt,
-		struct swm_input_ids *swm_input, unsigned int reg)
-{
-	uint i, is_set, nb_inputs = 0;
-	u16 input_loc_id;
-
-	dev_dbg(cmpnt->dev, "reg: %#x\n", reg);
-	for (i = 0; i < SST_SWM_INPUT_COUNT; i++) {
-		is_set = reg & BIT(i);
-		if (!is_set)
-			continue;
-
-		input_loc_id = swm_mixer_input_ids[i];
-		SST_FILL_DESTINATION(2, swm_input->input_id,
-				     input_loc_id, SST_DEFAULT_MODULE_ID);
-		nb_inputs++;
-		swm_input++;
-		dev_dbg(cmpnt->dev, "input id: %#x, nb_inputs: %d\n",
-				input_loc_id, nb_inputs);
-
-		if (nb_inputs == SST_CMD_SWM_MAX_INPUTS) {
-			dev_warn(cmpnt->dev, "SET_SWM cmd max inputs reached");
-			break;
-		}
-	}
-	return nb_inputs;
-}
-
-
-/**
- * called with lock held
- */
-static int sst_set_pipe_gain(struct sst_ids *ids,
-			struct sst_data *drv, int mute)
-{
-	int ret = 0;
-	struct sst_gain_mixer_control *mc;
-	struct sst_gain_value *gv;
-	struct sst_module *gain = NULL;
-
-	list_for_each_entry(gain, &ids->gain_list, node) {
-		struct snd_kcontrol *kctl = gain->kctl;
-
-		dev_dbg(&drv->pdev->dev, "control name=%s\n", kctl->id.name);
-		mc = (void *)kctl->private_value;
-		gv = mc->gain_val;
-
-		ret = sst_send_gain_cmd(drv, gv, mc->task_id,
-			mc->pipe_id | mc->instance_id, mc->module_id, mute);
-		if (ret)
-			return ret;
-	}
-	return ret;
-}
-
-static int sst_swm_mixer_event(struct snd_soc_dapm_widget *w,
-			struct snd_kcontrol *k, int event)
-{
-	struct sst_cmd_set_swm cmd;
-	struct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);
-	struct sst_data *drv = snd_soc_component_get_drvdata(cmpnt);
-	struct sst_ids *ids = w->priv;
-	bool set_mixer = false;
-	struct soc_mixer_control *mc;
-	int val = 0;
-	int i = 0;
-
-	dev_dbg(cmpnt->dev, "widget = %s\n", w->name);
-	/*
-	 * Identify which mixer input is on and send the bitmap of the
-	 * inputs as an IPC to the DSP.
-	 */
-	for (i = 0; i < w->num_kcontrols; i++) {
-		if (dapm_kcontrol_get_value(w->kcontrols[i])) {
-			mc = (struct soc_mixer_control *)(w->kcontrols[i])->private_value;
-			val |= 1 << mc->shift;
-		}
-	}
-	dev_dbg(cmpnt->dev, "val = %#x\n", val);
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-	case SND_SOC_DAPM_POST_PMD:
-		set_mixer = true;
-		break;
-	case SND_SOC_DAPM_POST_REG:
-		if (w->power)
-			set_mixer = true;
-		break;
-	default:
-		set_mixer = false;
-	}
-
-	if (set_mixer == false)
-		return 0;
-
-	if (SND_SOC_DAPM_EVENT_ON(event) ||
-	    event == SND_SOC_DAPM_POST_REG)
-		cmd.switch_state = SST_SWM_ON;
-	else
-		cmd.switch_state = SST_SWM_OFF;
-
-	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
-	/* MMX_SET_SWM == SBA_SET_SWM */
-	cmd.header.command_id = SBA_SET_SWM;
-
-	SST_FILL_DESTINATION(2, cmd.output_id,
-			     ids->location_id, SST_DEFAULT_MODULE_ID);
-	cmd.nb_inputs =	fill_swm_input(cmpnt, &cmd.input[0], val);
-	cmd.header.length = offsetof(struct sst_cmd_set_swm, input)
-				- sizeof(struct sst_dsp_header)
-				+ (cmd.nb_inputs * sizeof(cmd.input[0]));
-
-	return sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
-			      ids->task_id, 0, &cmd,
-			      sizeof(cmd.header) + cmd.header.length);
-}
-
-/* SBA mixers - 16 inputs */
-#define SST_SBA_DECLARE_MIX_CONTROLS(kctl_name)							\
-	static const struct snd_kcontrol_new kctl_name[] = {					\
-		SOC_DAPM_SINGLE("codec_in0 Switch", SND_SOC_NOPM, SST_IP_CODEC0, 1, 0),		\
-		SOC_DAPM_SINGLE("codec_in1 Switch", SND_SOC_NOPM, SST_IP_CODEC1, 1, 0),		\
-		SOC_DAPM_SINGLE("sprot_loop_in Switch", SND_SOC_NOPM, SST_IP_LOOP0, 1, 0),	\
-		SOC_DAPM_SINGLE("media_loop1_in Switch", SND_SOC_NOPM, SST_IP_LOOP1, 1, 0),	\
-		SOC_DAPM_SINGLE("media_loop2_in Switch", SND_SOC_NOPM, SST_IP_LOOP2, 1, 0),	\
-		SOC_DAPM_SINGLE("pcm0_in Switch", SND_SOC_NOPM, SST_IP_PCM0, 1, 0),		\
-		SOC_DAPM_SINGLE("pcm1_in Switch", SND_SOC_NOPM, SST_IP_PCM1, 1, 0),		\
-	}
-
-#define SST_SBA_MIXER_GRAPH_MAP(mix_name)			\
-	{ mix_name, "codec_in0 Switch",	"codec_in0" },		\
-	{ mix_name, "codec_in1 Switch",	"codec_in1" },		\
-	{ mix_name, "sprot_loop_in Switch",	"sprot_loop_in" },	\
-	{ mix_name, "media_loop1_in Switch",	"media_loop1_in" },	\
-	{ mix_name, "media_loop2_in Switch",	"media_loop2_in" },	\
-	{ mix_name, "pcm0_in Switch",		"pcm0_in" },		\
-	{ mix_name, "pcm1_in Switch",		"pcm1_in" }
-
-#define SST_MMX_DECLARE_MIX_CONTROLS(kctl_name)						\
-	static const struct snd_kcontrol_new kctl_name[] = {				\
-		SOC_DAPM_SINGLE("media0_in Switch", SND_SOC_NOPM, SST_IP_MEDIA0, 1, 0),	\
-		SOC_DAPM_SINGLE("media1_in Switch", SND_SOC_NOPM, SST_IP_MEDIA1, 1, 0),	\
-		SOC_DAPM_SINGLE("media2_in Switch", SND_SOC_NOPM, SST_IP_MEDIA2, 1, 0),	\
-		SOC_DAPM_SINGLE("media3_in Switch", SND_SOC_NOPM, SST_IP_MEDIA3, 1, 0),	\
-	}
-
-SST_MMX_DECLARE_MIX_CONTROLS(sst_mix_media0_controls);
-SST_MMX_DECLARE_MIX_CONTROLS(sst_mix_media1_controls);
-
-/* 18 SBA mixers */
-SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm0_controls);
-SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm1_controls);
-SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm2_controls);
-SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_sprot_l0_controls);
-SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_media_l1_controls);
-SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_media_l2_controls);
-SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_voip_controls);
-SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec0_controls);
-SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec1_controls);
-
-/*
- * sst_handle_vb_timer - Start/Stop the DSP scheduler
- *
- * The DSP expects first cmd to be SBA_VB_START, so at first startup send
- * that.
- * DSP expects last cmd to be SBA_VB_IDLE, so at last shutdown send that.
- *
- * Do refcount internally so that we send command only at first start
- * and last end. Since SST driver does its own ref count, invoke sst's
- * power ops always!
- */
-int sst_handle_vb_timer(struct snd_soc_dai *dai, bool enable)
-{
-	int ret = 0;
-	struct sst_cmd_generic cmd;
-	struct sst_data *drv = snd_soc_dai_get_drvdata(dai);
-	static int timer_usage;
-
-	if (enable)
-		cmd.header.command_id = SBA_VB_START;
-	else
-		cmd.header.command_id = SBA_IDLE;
-	dev_dbg(dai->dev, "enable=%u, usage=%d\n", enable, timer_usage);
-
-	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
-	cmd.header.length = 0;
-
-	if (enable) {
-		ret = sst->ops->power(sst->dev, true);
-		if (ret < 0)
-			return ret;
-	}
-
-	mutex_lock(&drv->lock);
-	if (enable)
-		timer_usage++;
-	else
-		timer_usage--;
-
-	/*
-	 * Send the command only if this call is the first enable or last
-	 * disable
-	 */
-	if ((enable && (timer_usage == 1)) ||
-	    (!enable && (timer_usage == 0))) {
-		ret = sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_CMD,
-				SST_FLAG_BLOCKED, SST_TASK_SBA, 0, &cmd,
-				sizeof(cmd.header) + cmd.header.length);
-		if (ret && enable) {
-			timer_usage--;
-			enable  = false;
-		}
-	}
-	mutex_unlock(&drv->lock);
-
-	if (!enable)
-		sst->ops->power(sst->dev, false);
-	return ret;
-}
-
-/**
- * sst_ssp_config - contains SSP configuration for media UC
- */
-static const struct sst_ssp_config sst_ssp_configs = {
-	.ssp_id = SSP_CODEC,
-	.bits_per_slot = 24,
-	.slots = 4,
-	.ssp_mode = SSP_MODE_MASTER,
-	.pcm_mode = SSP_PCM_MODE_NETWORK,
-	.duplex = SSP_DUPLEX,
-	.ssp_protocol = SSP_MODE_PCM,
-	.fs_width = 1,
-	.fs_frequency = SSP_FS_48_KHZ,
-	.active_slot_map = 0xF,
-	.start_delay = 0,
-};
-
-int send_ssp_cmd(struct snd_soc_dai *dai, const char *id, bool enable)
-{
-	struct sst_cmd_sba_hw_set_ssp cmd;
-	struct sst_data *drv = snd_soc_dai_get_drvdata(dai);
-	const struct sst_ssp_config *config;
-
-	dev_info(dai->dev, "Enter: enable=%d port_name=%s\n", enable, id);
-
-	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
-	cmd.header.command_id = SBA_HW_SET_SSP;
-	cmd.header.length = sizeof(struct sst_cmd_sba_hw_set_ssp)
-				- sizeof(struct sst_dsp_header);
-
-	config = &sst_ssp_configs;
-	dev_dbg(dai->dev, "ssp_id: %u\n", config->ssp_id);
-
-	if (enable)
-		cmd.switch_state = SST_SWITCH_ON;
-	else
-		cmd.switch_state = SST_SWITCH_OFF;
-
-	cmd.selection = config->ssp_id;
-	cmd.nb_bits_per_slots = config->bits_per_slot;
-	cmd.nb_slots = config->slots;
-	cmd.mode = config->ssp_mode | (config->pcm_mode << 1);
-	cmd.duplex = config->duplex;
-	cmd.active_tx_slot_map = config->active_slot_map;
-	cmd.active_rx_slot_map = config->active_slot_map;
-	cmd.frame_sync_frequency = config->fs_frequency;
-	cmd.frame_sync_polarity = SSP_FS_ACTIVE_HIGH;
-	cmd.data_polarity = 1;
-	cmd.frame_sync_width = config->fs_width;
-	cmd.ssp_protocol = config->ssp_protocol;
-	cmd.start_delay = config->start_delay;
-	cmd.reserved1 = cmd.reserved2 = 0xFF;
-
-	return sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
-				SST_TASK_SBA, 0, &cmd,
-				sizeof(cmd.header) + cmd.header.length);
-}
-
-static int sst_set_be_modules(struct snd_soc_dapm_widget *w,
-			 struct snd_kcontrol *k, int event)
-{
-	int ret = 0;
-	struct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);
-	struct sst_data *drv = snd_soc_component_get_drvdata(c);
-
-	dev_dbg(c->dev, "Enter: widget=%s\n", w->name);
-
-	if (SND_SOC_DAPM_EVENT_ON(event)) {
-		ret = sst_send_slot_map(drv);
-		if (ret)
-			return ret;
-		ret = sst_send_pipe_module_params(w, k);
-	}
-	return ret;
-}
-
-static int sst_set_media_path(struct snd_soc_dapm_widget *w,
-			      struct snd_kcontrol *k, int event)
-{
-	int ret = 0;
-	struct sst_cmd_set_media_path cmd;
-	struct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);
-	struct sst_data *drv = snd_soc_component_get_drvdata(c);
-	struct sst_ids *ids = w->priv;
-
-	dev_dbg(c->dev, "widget=%s\n", w->name);
-	dev_dbg(c->dev, "task=%u, location=%#x\n",
-				ids->task_id, ids->location_id);
-
-	if (SND_SOC_DAPM_EVENT_ON(event))
-		cmd.switch_state = SST_PATH_ON;
-	else
-		cmd.switch_state = SST_PATH_OFF;
-
-	SST_FILL_DESTINATION(2, cmd.header.dst,
-			     ids->location_id, SST_DEFAULT_MODULE_ID);
-
-	/* MMX_SET_MEDIA_PATH == SBA_SET_MEDIA_PATH */
-	cmd.header.command_id = MMX_SET_MEDIA_PATH;
-	cmd.header.length = sizeof(struct sst_cmd_set_media_path)
-				- sizeof(struct sst_dsp_header);
-
-	ret = sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
-			      ids->task_id, 0, &cmd,
-			      sizeof(cmd.header) + cmd.header.length);
-	if (ret)
-		return ret;
-
-	if (SND_SOC_DAPM_EVENT_ON(event))
-		ret = sst_send_pipe_module_params(w, k);
-	return ret;
-}
-
-static int sst_set_media_loop(struct snd_soc_dapm_widget *w,
-			struct snd_kcontrol *k, int event)
-{
-	int ret = 0;
-	struct sst_cmd_sba_set_media_loop_map cmd;
-	struct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);
-	struct sst_data *drv = snd_soc_component_get_drvdata(c);
-	struct sst_ids *ids = w->priv;
-
-	dev_dbg(c->dev, "Enter:widget=%s\n", w->name);
-	if (SND_SOC_DAPM_EVENT_ON(event))
-		cmd.switch_state = SST_SWITCH_ON;
-	else
-		cmd.switch_state = SST_SWITCH_OFF;
-
-	SST_FILL_DESTINATION(2, cmd.header.dst,
-			     ids->location_id, SST_DEFAULT_MODULE_ID);
-
-	cmd.header.command_id = SBA_SET_MEDIA_LOOP_MAP;
-	cmd.header.length = sizeof(struct sst_cmd_sba_set_media_loop_map)
-				 - sizeof(struct sst_dsp_header);
-	cmd.param.part.cfg.rate = 2; /* 48khz */
-
-	cmd.param.part.cfg.format = ids->format; /* stereo/Mono */
-	cmd.param.part.cfg.s_length = 1; /* 24bit left justified */
-	cmd.map = 0; /* Algo sequence: Gain - DRP - FIR - IIR */
-
-	ret = sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
-			      SST_TASK_SBA, 0, &cmd,
-			      sizeof(cmd.header) + cmd.header.length);
-	if (ret)
-		return ret;
-
-	if (SND_SOC_DAPM_EVENT_ON(event))
-		ret = sst_send_pipe_module_params(w, k);
-	return ret;
-}
-
-static const struct snd_soc_dapm_widget sst_dapm_widgets[] = {
-	SST_AIF_IN("codec_in0", sst_set_be_modules),
-	SST_AIF_IN("codec_in1", sst_set_be_modules),
-	SST_AIF_OUT("codec_out0", sst_set_be_modules),
-	SST_AIF_OUT("codec_out1", sst_set_be_modules),
-
-	/* Media Paths */
-	/* MediaX IN paths are set via ALLOC, so no SET_MEDIA_PATH command */
-	SST_PATH_INPUT("media0_in", SST_TASK_MMX, SST_SWM_IN_MEDIA0, sst_generic_modules_event),
-	SST_PATH_INPUT("media1_in", SST_TASK_MMX, SST_SWM_IN_MEDIA1, NULL),
-	SST_PATH_INPUT("media2_in", SST_TASK_MMX, SST_SWM_IN_MEDIA2, sst_set_media_path),
-	SST_PATH_INPUT("media3_in", SST_TASK_MMX, SST_SWM_IN_MEDIA3, NULL),
-	SST_PATH_OUTPUT("media0_out", SST_TASK_MMX, SST_SWM_OUT_MEDIA0, sst_set_media_path),
-	SST_PATH_OUTPUT("media1_out", SST_TASK_MMX, SST_SWM_OUT_MEDIA1, sst_set_media_path),
-
-	/* SBA PCM Paths */
-	SST_PATH_INPUT("pcm0_in", SST_TASK_SBA, SST_SWM_IN_PCM0, sst_set_media_path),
-	SST_PATH_INPUT("pcm1_in", SST_TASK_SBA, SST_SWM_IN_PCM1, sst_set_media_path),
-	SST_PATH_OUTPUT("pcm0_out", SST_TASK_SBA, SST_SWM_OUT_PCM0, sst_set_media_path),
-	SST_PATH_OUTPUT("pcm1_out", SST_TASK_SBA, SST_SWM_OUT_PCM1, sst_set_media_path),
-	SST_PATH_OUTPUT("pcm2_out", SST_TASK_SBA, SST_SWM_OUT_PCM2, sst_set_media_path),
-
-	/* SBA Loops */
-	SST_PATH_INPUT("sprot_loop_in", SST_TASK_SBA, SST_SWM_IN_SPROT_LOOP, NULL),
-	SST_PATH_INPUT("media_loop1_in", SST_TASK_SBA, SST_SWM_IN_MEDIA_LOOP1, NULL),
-	SST_PATH_INPUT("media_loop2_in", SST_TASK_SBA, SST_SWM_IN_MEDIA_LOOP2, NULL),
-	SST_PATH_MEDIA_LOOP_OUTPUT("sprot_loop_out", SST_TASK_SBA, SST_SWM_OUT_SPROT_LOOP, SST_FMT_MONO, sst_set_media_loop),
-	SST_PATH_MEDIA_LOOP_OUTPUT("media_loop1_out", SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP1, SST_FMT_MONO, sst_set_media_loop),
-	SST_PATH_MEDIA_LOOP_OUTPUT("media_loop2_out", SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP2, SST_FMT_STEREO, sst_set_media_loop),
-
-	/* Media Mixers */
-	SST_SWM_MIXER("media0_out mix 0", SND_SOC_NOPM, SST_TASK_MMX, SST_SWM_OUT_MEDIA0,
-		      sst_mix_media0_controls, sst_swm_mixer_event),
-	SST_SWM_MIXER("media1_out mix 0", SND_SOC_NOPM, SST_TASK_MMX, SST_SWM_OUT_MEDIA1,
-		      sst_mix_media1_controls, sst_swm_mixer_event),
-
-	/* SBA PCM mixers */
-	SST_SWM_MIXER("pcm0_out mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_PCM0,
-		      sst_mix_pcm0_controls, sst_swm_mixer_event),
-	SST_SWM_MIXER("pcm1_out mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_PCM1,
-		      sst_mix_pcm1_controls, sst_swm_mixer_event),
-	SST_SWM_MIXER("pcm2_out mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_PCM2,
-		      sst_mix_pcm2_controls, sst_swm_mixer_event),
-
-	/* SBA Loop mixers */
-	SST_SWM_MIXER("sprot_loop_out mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_SPROT_LOOP,
-		      sst_mix_sprot_l0_controls, sst_swm_mixer_event),
-	SST_SWM_MIXER("media_loop1_out mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP1,
-		      sst_mix_media_l1_controls, sst_swm_mixer_event),
-	SST_SWM_MIXER("media_loop2_out mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP2,
-		      sst_mix_media_l2_controls, sst_swm_mixer_event),
-
-	/* SBA Backend mixers */
-	SST_SWM_MIXER("codec_out0 mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_CODEC0,
-		      sst_mix_codec0_controls, sst_swm_mixer_event),
-	SST_SWM_MIXER("codec_out1 mix 0", SND_SOC_NOPM, SST_TASK_SBA, SST_SWM_OUT_CODEC1,
-		      sst_mix_codec1_controls, sst_swm_mixer_event),
-};
-
-static const struct snd_soc_dapm_route intercon[] = {
-	{"media0_in", NULL, "Compress Playback"},
-	{"media1_in", NULL, "Headset Playback"},
-	{"media2_in", NULL, "pcm0_out"},
-
-	{"media0_out mix 0", "media0_in Switch", "media0_in"},
-	{"media0_out mix 0", "media1_in Switch", "media1_in"},
-	{"media0_out mix 0", "media2_in Switch", "media2_in"},
-	{"media0_out mix 0", "media3_in Switch", "media3_in"},
-	{"media1_out mix 0", "media0_in Switch", "media0_in"},
-	{"media1_out mix 0", "media1_in Switch", "media1_in"},
-	{"media1_out mix 0", "media2_in Switch", "media2_in"},
-	{"media1_out mix 0", "media3_in Switch", "media3_in"},
-
-	{"media0_out", NULL, "media0_out mix 0"},
-	{"media1_out", NULL, "media1_out mix 0"},
-	{"pcm0_in", NULL, "media0_out"},
-	{"pcm1_in", NULL, "media1_out"},
-
-	{"Headset Capture", NULL, "pcm1_out"},
-	{"Headset Capture", NULL, "pcm2_out"},
-	{"pcm0_out", NULL, "pcm0_out mix 0"},
-	SST_SBA_MIXER_GRAPH_MAP("pcm0_out mix 0"),
-	{"pcm1_out", NULL, "pcm1_out mix 0"},
-	SST_SBA_MIXER_GRAPH_MAP("pcm1_out mix 0"),
-	{"pcm2_out", NULL, "pcm2_out mix 0"},
-	SST_SBA_MIXER_GRAPH_MAP("pcm2_out mix 0"),
-
-	{"media_loop1_in", NULL, "media_loop1_out"},
-	{"media_loop1_out", NULL, "media_loop1_out mix 0"},
-	SST_SBA_MIXER_GRAPH_MAP("media_loop1_out mix 0"),
-	{"media_loop2_in", NULL, "media_loop2_out"},
-	{"media_loop2_out", NULL, "media_loop2_out mix 0"},
-	SST_SBA_MIXER_GRAPH_MAP("media_loop2_out mix 0"),
-	{"sprot_loop_in", NULL, "sprot_loop_out"},
-	{"sprot_loop_out", NULL, "sprot_loop_out mix 0"},
-	SST_SBA_MIXER_GRAPH_MAP("sprot_loop_out mix 0"),
-
-	{"codec_out0", NULL, "codec_out0 mix 0"},
-	SST_SBA_MIXER_GRAPH_MAP("codec_out0 mix 0"),
-	{"codec_out1", NULL, "codec_out1 mix 0"},
-	SST_SBA_MIXER_GRAPH_MAP("codec_out1 mix 0"),
-
-};
-static const char * const slot_names[] = {
-	"none",
-	"slot 0", "slot 1", "slot 2", "slot 3",
-	"slot 4", "slot 5", "slot 6", "slot 7", /* not supported by FW */
-};
-
-static const char * const channel_names[] = {
-	"none",
-	"codec_out0_0", "codec_out0_1", "codec_out1_0", "codec_out1_1",
-	"codec_out2_0", "codec_out2_1", "codec_out3_0", "codec_out3_1", /* not supported by FW */
-};
-
-#define SST_INTERLEAVER(xpname, slot_name, slotno) \
-	SST_SSP_SLOT_CTL(xpname, "tx interleaver", slot_name, slotno, true, \
-			 channel_names, sst_slot_get, sst_slot_put)
-
-#define SST_DEINTERLEAVER(xpname, channel_name, channel_no) \
-	SST_SSP_SLOT_CTL(xpname, "rx deinterleaver", channel_name, channel_no, false, \
-			 slot_names, sst_slot_get, sst_slot_put)
-
-static const struct snd_kcontrol_new sst_slot_controls[] = {
-	SST_INTERLEAVER("codec_out", "slot 0", 0),
-	SST_INTERLEAVER("codec_out", "slot 1", 1),
-	SST_INTERLEAVER("codec_out", "slot 2", 2),
-	SST_INTERLEAVER("codec_out", "slot 3", 3),
-	SST_DEINTERLEAVER("codec_in", "codec_in0_0", 0),
-	SST_DEINTERLEAVER("codec_in", "codec_in0_1", 1),
-	SST_DEINTERLEAVER("codec_in", "codec_in1_0", 2),
-	SST_DEINTERLEAVER("codec_in", "codec_in1_1", 3),
-};
-
-/* Gain helper with min/max set */
-#define SST_GAIN(name, path_id, task_id, instance, gain_var)				\
-	SST_GAIN_KCONTROLS(name, "Gain", SST_GAIN_MIN_VALUE, SST_GAIN_MAX_VALUE,	\
-		SST_GAIN_TC_MIN, SST_GAIN_TC_MAX,					\
-		sst_gain_get, sst_gain_put,						\
-		SST_MODULE_ID_GAIN_CELL, path_id, instance, task_id,			\
-		sst_gain_tlv_common, gain_var)
-
-#define SST_VOLUME(name, path_id, task_id, instance, gain_var)				\
-	SST_GAIN_KCONTROLS(name, "Volume", SST_GAIN_MIN_VALUE, SST_GAIN_MAX_VALUE,	\
-		SST_GAIN_TC_MIN, SST_GAIN_TC_MAX,					\
-		sst_gain_get, sst_gain_put,						\
-		SST_MODULE_ID_VOLUME, path_id, instance, task_id,			\
-		sst_gain_tlv_common, gain_var)
-
-static struct sst_gain_value sst_gains[];
-
-static const struct snd_kcontrol_new sst_gain_controls[] = {
-	SST_GAIN("media0_in", SST_PATH_INDEX_MEDIA0_IN, SST_TASK_MMX, 0, &sst_gains[0]),
-	SST_GAIN("media1_in", SST_PATH_INDEX_MEDIA1_IN, SST_TASK_MMX, 0, &sst_gains[1]),
-	SST_GAIN("media2_in", SST_PATH_INDEX_MEDIA2_IN, SST_TASK_MMX, 0, &sst_gains[2]),
-	SST_GAIN("media3_in", SST_PATH_INDEX_MEDIA3_IN, SST_TASK_MMX, 0, &sst_gains[3]),
-
-	SST_GAIN("pcm0_in", SST_PATH_INDEX_PCM0_IN, SST_TASK_SBA, 0, &sst_gains[4]),
-	SST_GAIN("pcm1_in", SST_PATH_INDEX_PCM1_IN, SST_TASK_SBA, 0, &sst_gains[5]),
-	SST_GAIN("pcm1_out", SST_PATH_INDEX_PCM1_OUT, SST_TASK_SBA, 0, &sst_gains[6]),
-	SST_GAIN("pcm2_out", SST_PATH_INDEX_PCM2_OUT, SST_TASK_SBA, 0, &sst_gains[7]),
-
-	SST_GAIN("codec_in0", SST_PATH_INDEX_CODEC_IN0, SST_TASK_SBA, 0, &sst_gains[8]),
-	SST_GAIN("codec_in1", SST_PATH_INDEX_CODEC_IN1, SST_TASK_SBA, 0, &sst_gains[9]),
-	SST_GAIN("codec_out0", SST_PATH_INDEX_CODEC_OUT0, SST_TASK_SBA, 0, &sst_gains[10]),
-	SST_GAIN("codec_out1", SST_PATH_INDEX_CODEC_OUT1, SST_TASK_SBA, 0, &sst_gains[11]),
-	SST_GAIN("media_loop1_out", SST_PATH_INDEX_MEDIA_LOOP1_OUT, SST_TASK_SBA, 0, &sst_gains[12]),
-	SST_GAIN("media_loop2_out", SST_PATH_INDEX_MEDIA_LOOP2_OUT, SST_TASK_SBA, 0, &sst_gains[13]),
-	SST_GAIN("sprot_loop_out", SST_PATH_INDEX_SPROT_LOOP_OUT, SST_TASK_SBA, 0, &sst_gains[14]),
-	SST_VOLUME("media0_in", SST_PATH_INDEX_MEDIA0_IN, SST_TASK_MMX, 0, &sst_gains[15]),
-};
-
-#define SST_GAIN_NUM_CONTROLS 3
-/* the SST_GAIN macro above will create three alsa controls for each
- * instance invoked, gain, mute and ramp duration, which use the same gain
- * cell sst_gain to keep track of data
- * To calculate number of gain cell instances we need to device by 3 in
- * below caulcation for gain cell memory.
- * This gets rid of static number and issues while adding new controls
- */
-static struct sst_gain_value sst_gains[ARRAY_SIZE(sst_gain_controls)/SST_GAIN_NUM_CONTROLS];
-
-static const struct snd_kcontrol_new sst_algo_controls[] = {
-	SST_ALGO_KCONTROL_BYTES("media_loop1_out", "fir", 272, SST_MODULE_ID_FIR_24,
-		 SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
-	SST_ALGO_KCONTROL_BYTES("media_loop1_out", "iir", 300, SST_MODULE_ID_IIR_24,
-		SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
-	SST_ALGO_KCONTROL_BYTES("media_loop1_out", "mdrp", 286, SST_MODULE_ID_MDRP,
-		SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_SET_MDRP),
-	SST_ALGO_KCONTROL_BYTES("media_loop2_out", "fir", 272, SST_MODULE_ID_FIR_24,
-		SST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
-	SST_ALGO_KCONTROL_BYTES("media_loop2_out", "iir", 300, SST_MODULE_ID_IIR_24,
-		SST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
-	SST_ALGO_KCONTROL_BYTES("media_loop2_out", "mdrp", 286, SST_MODULE_ID_MDRP,
-		SST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_SET_MDRP),
-	SST_ALGO_KCONTROL_BYTES("sprot_loop_out", "lpro", 192, SST_MODULE_ID_SPROT,
-		SST_PATH_INDEX_SPROT_LOOP_OUT, 0, SST_TASK_SBA, SBA_VB_LPRO),
-	SST_ALGO_KCONTROL_BYTES("codec_in0", "dcr", 52, SST_MODULE_ID_FILT_DCR,
-		SST_PATH_INDEX_CODEC_IN0, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
-	SST_ALGO_KCONTROL_BYTES("codec_in1", "dcr", 52, SST_MODULE_ID_FILT_DCR,
-		SST_PATH_INDEX_CODEC_IN1, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
-
-};
-
-static int sst_algo_control_init(struct device *dev)
-{
-	int i = 0;
-	struct sst_algo_control *bc;
-	/*allocate space to cache the algo parameters in the driver*/
-	for (i = 0; i < ARRAY_SIZE(sst_algo_controls); i++) {
-		bc = (struct sst_algo_control *)sst_algo_controls[i].private_value;
-		bc->params = devm_kzalloc(dev, bc->max, GFP_KERNEL);
-		if (bc->params == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static bool is_sst_dapm_widget(struct snd_soc_dapm_widget *w)
-{
-	switch (w->id) {
-	case snd_soc_dapm_pga:
-	case snd_soc_dapm_aif_in:
-	case snd_soc_dapm_aif_out:
-	case snd_soc_dapm_input:
-	case snd_soc_dapm_output:
-	case snd_soc_dapm_mixer:
-		return true;
-	default:
-		return false;
-	}
-}
-
-/**
- * sst_send_pipe_gains - send gains for the front-end DAIs
- *
- * The gains in the pipes connected to the front-ends are muted/unmuted
- * automatically via the digital_mute() DAPM callback. This function sends the
- * gains for the front-end pipes.
- */
-int sst_send_pipe_gains(struct snd_soc_dai *dai, int stream, int mute)
-{
-	struct sst_data *drv = snd_soc_dai_get_drvdata(dai);
-	struct snd_soc_dapm_widget *w;
-	struct snd_soc_dapm_path *p = NULL;
-
-	dev_dbg(dai->dev, "enter, dai-name=%s dir=%d\n", dai->name, stream);
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		dev_dbg(dai->dev, "Stream name=%s\n",
-				dai->playback_widget->name);
-		w = dai->playback_widget;
-		list_for_each_entry(p, &w->sinks, list_source) {
-			if (p->connected && !p->connected(w, p->sink))
-				continue;
-
-			if (p->connect && p->sink->power &&
-					is_sst_dapm_widget(p->sink)) {
-				struct sst_ids *ids = p->sink->priv;
-
-				dev_dbg(dai->dev, "send gains for widget=%s\n",
-						p->sink->name);
-				mutex_lock(&drv->lock);
-				sst_set_pipe_gain(ids, drv, mute);
-				mutex_unlock(&drv->lock);
-			}
-		}
-	} else {
-		dev_dbg(dai->dev, "Stream name=%s\n",
-				dai->capture_widget->name);
-		w = dai->capture_widget;
-		list_for_each_entry(p, &w->sources, list_sink) {
-			if (p->connected && !p->connected(w, p->sink))
-				continue;
-
-			if (p->connect &&  p->source->power &&
-					is_sst_dapm_widget(p->source)) {
-				struct sst_ids *ids = p->source->priv;
-
-				dev_dbg(dai->dev, "send gain for widget=%s\n",
-						p->source->name);
-				mutex_lock(&drv->lock);
-				sst_set_pipe_gain(ids, drv, mute);
-				mutex_unlock(&drv->lock);
-			}
-		}
-	}
-	return 0;
-}
-
-/**
- * sst_fill_module_list - populate the list of modules/gains for a pipe
- *
- *
- * Fills the widget pointer in the kcontrol private data, and also fills the
- * kcontrol pointer in the widget private data.
- *
- * Widget pointer is used to send the algo/gain in the .put() handler if the
- * widget is powerd on.
- *
- * Kcontrol pointer is used to send the algo/gain in the widget power ON/OFF
- * event handler. Each widget (pipe) has multiple algos stored in the algo_list.
- */
-static int sst_fill_module_list(struct snd_kcontrol *kctl,
-	 struct snd_soc_dapm_widget *w, int type)
-{
-	struct sst_module *module = NULL;
-	struct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);
-	struct sst_ids *ids = w->priv;
-	int ret = 0;
-
-	module = devm_kzalloc(c->dev, sizeof(*module), GFP_KERNEL);
-	if (!module)
-		return -ENOMEM;
-
-	if (type == SST_MODULE_GAIN) {
-		struct sst_gain_mixer_control *mc = (void *)kctl->private_value;
-
-		mc->w = w;
-		module->kctl = kctl;
-		list_add_tail(&module->node, &ids->gain_list);
-	} else if (type == SST_MODULE_ALGO) {
-		struct sst_algo_control *bc = (void *)kctl->private_value;
-
-		bc->w = w;
-		module->kctl = kctl;
-		list_add_tail(&module->node, &ids->algo_list);
-	} else {
-		dev_err(c->dev, "invoked for unknown type %d module %s",
-				type, kctl->id.name);
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-/**
- * sst_fill_widget_module_info - fill list of gains/algos for the pipe
- * @widget:	pipe modelled as a DAPM widget
- *
- * Fill the list of gains/algos for the widget by looking at all the card
- * controls and comparing the name of the widget with the first part of control
- * name. First part of control name contains the pipe name (widget name).
- */
-static int sst_fill_widget_module_info(struct snd_soc_dapm_widget *w,
-	struct snd_soc_platform *platform)
-{
-	struct snd_kcontrol *kctl;
-	int index, ret = 0;
-	struct snd_card *card = platform->component.card->snd_card;
-	char *idx;
-
-	down_read(&card->controls_rwsem);
-
-	list_for_each_entry(kctl, &card->controls, list) {
-		idx = strstr(kctl->id.name, " ");
-		if (idx == NULL)
-			continue;
-		index  = strlen(kctl->id.name) - strlen(idx);
-
-		if (strstr(kctl->id.name, "Volume") &&
-		    !strncmp(kctl->id.name, w->name, index))
-			ret = sst_fill_module_list(kctl, w, SST_MODULE_GAIN);
-
-		else if (strstr(kctl->id.name, "params") &&
-			 !strncmp(kctl->id.name, w->name, index))
-			ret = sst_fill_module_list(kctl, w, SST_MODULE_ALGO);
-
-		else if (strstr(kctl->id.name, "Switch") &&
-			 !strncmp(kctl->id.name, w->name, index) &&
-			 strstr(kctl->id.name, "Gain")) {
-			struct sst_gain_mixer_control *mc =
-						(void *)kctl->private_value;
-
-			mc->w = w;
-
-		} else if (strstr(kctl->id.name, "interleaver") &&
-			 !strncmp(kctl->id.name, w->name, index)) {
-			struct sst_enum *e = (void *)kctl->private_value;
-
-			e->w = w;
-
-		} else if (strstr(kctl->id.name, "deinterleaver") &&
-			 !strncmp(kctl->id.name, w->name, index)) {
-
-			struct sst_enum *e = (void *)kctl->private_value;
-
-			e->w = w;
-		}
-
-		if (ret < 0) {
-			up_read(&card->controls_rwsem);
-			return ret;
-		}
-	}
-
-	up_read(&card->controls_rwsem);
-	return 0;
-}
-
-/**
- * sst_fill_linked_widgets - fill the parent pointer for the linked widget
- */
-static void sst_fill_linked_widgets(struct snd_soc_platform *platform,
-						struct sst_ids *ids)
-{
-	struct snd_soc_dapm_widget *w;
-	unsigned int len = strlen(ids->parent_wname);
-
-	list_for_each_entry(w, &platform->component.card->widgets, list) {
-		if (!strncmp(ids->parent_wname, w->name, len)) {
-			ids->parent_w = w;
-			break;
-		}
-	}
-}
-
-/**
- * sst_map_modules_to_pipe - fill algo/gains list for all pipes
- */
-static int sst_map_modules_to_pipe(struct snd_soc_platform *platform)
-{
-	struct snd_soc_dapm_widget *w;
-	int ret = 0;
-
-	list_for_each_entry(w, &platform->component.card->widgets, list) {
-		if (is_sst_dapm_widget(w) && (w->priv)) {
-			struct sst_ids *ids = w->priv;
-
-			dev_dbg(platform->dev, "widget type=%d name=%s\n",
-					w->id, w->name);
-			INIT_LIST_HEAD(&ids->algo_list);
-			INIT_LIST_HEAD(&ids->gain_list);
-			ret = sst_fill_widget_module_info(w, platform);
-
-			if (ret < 0)
-				return ret;
-
-			/* fill linked widgets */
-			if (ids->parent_wname !=  NULL)
-				sst_fill_linked_widgets(platform, ids);
-		}
-	}
-	return 0;
-}
-
-int sst_dsp_init_v2_dpcm(struct snd_soc_platform *platform)
-{
-	int i, ret = 0;
-	struct snd_soc_dapm_context *dapm =
-			snd_soc_component_get_dapm(&platform->component);
-	struct sst_data *drv = snd_soc_platform_get_drvdata(platform);
-	unsigned int gains = ARRAY_SIZE(sst_gain_controls)/3;
-
-	drv->byte_stream = devm_kzalloc(platform->dev,
-					SST_MAX_BIN_BYTES, GFP_KERNEL);
-	if (!drv->byte_stream)
-		return -ENOMEM;
-
-	snd_soc_dapm_new_controls(dapm, sst_dapm_widgets,
-			ARRAY_SIZE(sst_dapm_widgets));
-	snd_soc_dapm_add_routes(dapm, intercon,
-			ARRAY_SIZE(intercon));
-	snd_soc_dapm_new_widgets(dapm->card);
-
-	for (i = 0; i < gains; i++) {
-		sst_gains[i].mute = SST_GAIN_MUTE_DEFAULT;
-		sst_gains[i].l_gain = SST_GAIN_VOLUME_DEFAULT;
-		sst_gains[i].r_gain = SST_GAIN_VOLUME_DEFAULT;
-		sst_gains[i].ramp_duration = SST_GAIN_RAMP_DURATION_DEFAULT;
-	}
-
-	ret = snd_soc_add_platform_controls(platform, sst_gain_controls,
-			ARRAY_SIZE(sst_gain_controls));
-	if (ret)
-		return ret;
-
-	/* Initialize algo control params */
-	ret = sst_algo_control_init(platform->dev);
-	if (ret)
-		return ret;
-	ret = snd_soc_add_platform_controls(platform, sst_algo_controls,
-			ARRAY_SIZE(sst_algo_controls));
-	if (ret)
-		return ret;
-
-	ret = snd_soc_add_platform_controls(platform, sst_slot_controls,
-			ARRAY_SIZE(sst_slot_controls));
-	if (ret)
-		return ret;
-
-	ret = sst_map_modules_to_pipe(platform);
-
-	return ret;
-}
diff -Naur linux-3.19.old/sound/soc/intel/sst-atom-controls.h linux-3.19/sound/soc/intel/sst-atom-controls.h
--- linux-3.19.old/sound/soc/intel/sst-atom-controls.h	2015-03-24 17:38:14.403176947 -0800
+++ linux-3.19/sound/soc/intel/sst-atom-controls.h	1969-12-31 14:00:00.000000000 -1000
@@ -1,870 +0,0 @@
-/*
- *  sst-atom-controls.h - Intel MID Platform driver header file
- *
- *  Copyright (C) 2013-14 Intel Corp
- *  Author: Ramesh Babu <ramesh.babu.koul@intel.com>
- *  	Omair M Abdullah <omair.m.abdullah@intel.com>
- *  	Samreen Nilofer <samreen.nilofer@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- */
-
-#ifndef __SST_ATOM_CONTROLS_H__
-#define __SST_ATOM_CONTROLS_H__
-
-#include <sound/soc.h>
-#include <sound/tlv.h>
-
-enum {
-	MERR_DPCM_AUDIO = 0,
-	MERR_DPCM_COMPR,
-};
-
-/* define a bit for each mixer input */
-#define SST_MIX_IP(x)		(x)
-
-#define SST_IP_CODEC0		SST_MIX_IP(2)
-#define SST_IP_CODEC1		SST_MIX_IP(3)
-#define SST_IP_LOOP0		SST_MIX_IP(4)
-#define SST_IP_LOOP1		SST_MIX_IP(5)
-#define SST_IP_LOOP2		SST_MIX_IP(6)
-#define SST_IP_PROBE		SST_MIX_IP(7)
-#define SST_IP_VOIP		SST_MIX_IP(12)
-#define SST_IP_PCM0		SST_MIX_IP(13)
-#define SST_IP_PCM1		SST_MIX_IP(14)
-#define SST_IP_MEDIA0		SST_MIX_IP(17)
-#define SST_IP_MEDIA1		SST_MIX_IP(18)
-#define SST_IP_MEDIA2		SST_MIX_IP(19)
-#define SST_IP_MEDIA3		SST_MIX_IP(20)
-
-#define SST_IP_LAST		SST_IP_MEDIA3
-
-#define SST_SWM_INPUT_COUNT	(SST_IP_LAST + 1)
-#define SST_CMD_SWM_MAX_INPUTS	6
-
-#define SST_PATH_ID_SHIFT	8
-#define SST_DEFAULT_LOCATION_ID	0xFFFF
-#define SST_DEFAULT_CELL_NBR	0xFF
-#define SST_DEFAULT_MODULE_ID	0xFFFF
-
-/*
- * Audio DSP Path Ids. Specified by the audio DSP FW
- */
-enum sst_path_index {
-	SST_PATH_INDEX_CODEC_OUT0               = (0x02 << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_CODEC_OUT1               = (0x03 << SST_PATH_ID_SHIFT),
-
-	SST_PATH_INDEX_SPROT_LOOP_OUT           = (0x04 << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_MEDIA_LOOP1_OUT          = (0x05 << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_MEDIA_LOOP2_OUT          = (0x06 << SST_PATH_ID_SHIFT),
-
-	SST_PATH_INDEX_VOIP_OUT                 = (0x0C << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_PCM0_OUT                 = (0x0D << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_PCM1_OUT                 = (0x0E << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_PCM2_OUT                 = (0x0F << SST_PATH_ID_SHIFT),
-
-	SST_PATH_INDEX_MEDIA0_OUT               = (0x12 << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_MEDIA1_OUT               = (0x13 << SST_PATH_ID_SHIFT),
-
-
-	/* Start of input paths */
-	SST_PATH_INDEX_CODEC_IN0                = (0x82 << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_CODEC_IN1                = (0x83 << SST_PATH_ID_SHIFT),
-
-	SST_PATH_INDEX_SPROT_LOOP_IN            = (0x84 << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_MEDIA_LOOP1_IN           = (0x85 << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_MEDIA_LOOP2_IN           = (0x86 << SST_PATH_ID_SHIFT),
-
-	SST_PATH_INDEX_VOIP_IN                  = (0x8C << SST_PATH_ID_SHIFT),
-
-	SST_PATH_INDEX_PCM0_IN                  = (0x8D << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_PCM1_IN                  = (0x8E << SST_PATH_ID_SHIFT),
-
-	SST_PATH_INDEX_MEDIA0_IN                = (0x8F << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_MEDIA1_IN                = (0x90 << SST_PATH_ID_SHIFT),
-	SST_PATH_INDEX_MEDIA2_IN                = (0x91 << SST_PATH_ID_SHIFT),
-
-	SST_PATH_INDEX_MEDIA3_IN		= (0x9C << SST_PATH_ID_SHIFT),
-
-	SST_PATH_INDEX_RESERVED                 = (0xFF << SST_PATH_ID_SHIFT),
-};
-
-/*
- * path IDs
- */
-enum sst_swm_inputs {
-	SST_SWM_IN_CODEC0	= (SST_PATH_INDEX_CODEC_IN0	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_IN_CODEC1	= (SST_PATH_INDEX_CODEC_IN1	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_IN_SPROT_LOOP	= (SST_PATH_INDEX_SPROT_LOOP_IN	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_IN_MEDIA_LOOP1	= (SST_PATH_INDEX_MEDIA_LOOP1_IN  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_IN_MEDIA_LOOP2	= (SST_PATH_INDEX_MEDIA_LOOP2_IN  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_IN_VOIP		= (SST_PATH_INDEX_VOIP_IN	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_IN_PCM0		= (SST_PATH_INDEX_PCM0_IN	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_IN_PCM1		= (SST_PATH_INDEX_PCM1_IN	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_IN_MEDIA0	= (SST_PATH_INDEX_MEDIA0_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
-	SST_SWM_IN_MEDIA1	= (SST_PATH_INDEX_MEDIA1_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
-	SST_SWM_IN_MEDIA2	= (SST_PATH_INDEX_MEDIA2_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
-	SST_SWM_IN_MEDIA3	= (SST_PATH_INDEX_MEDIA3_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
-	SST_SWM_IN_END		= (SST_PATH_INDEX_RESERVED	  | SST_DEFAULT_CELL_NBR)
-};
-
-/*
- * path IDs
- */
-enum sst_swm_outputs {
-	SST_SWM_OUT_CODEC0	= (SST_PATH_INDEX_CODEC_OUT0	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_OUT_CODEC1	= (SST_PATH_INDEX_CODEC_OUT1	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_OUT_SPROT_LOOP	= (SST_PATH_INDEX_SPROT_LOOP_OUT  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_OUT_MEDIA_LOOP1	= (SST_PATH_INDEX_MEDIA_LOOP1_OUT | SST_DEFAULT_CELL_NBR),
-	SST_SWM_OUT_MEDIA_LOOP2	= (SST_PATH_INDEX_MEDIA_LOOP2_OUT | SST_DEFAULT_CELL_NBR),
-	SST_SWM_OUT_VOIP	= (SST_PATH_INDEX_VOIP_OUT	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_OUT_PCM0	= (SST_PATH_INDEX_PCM0_OUT	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_OUT_PCM1	= (SST_PATH_INDEX_PCM1_OUT	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_OUT_PCM2	= (SST_PATH_INDEX_PCM2_OUT	  | SST_DEFAULT_CELL_NBR),
-	SST_SWM_OUT_MEDIA0	= (SST_PATH_INDEX_MEDIA0_OUT	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
-	SST_SWM_OUT_MEDIA1	= (SST_PATH_INDEX_MEDIA1_OUT	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
-	SST_SWM_OUT_END		= (SST_PATH_INDEX_RESERVED	  | SST_DEFAULT_CELL_NBR),
-};
-
-enum sst_ipc_msg {
-	SST_IPC_IA_CMD = 1,
-	SST_IPC_IA_SET_PARAMS,
-	SST_IPC_IA_GET_PARAMS,
-};
-
-enum sst_cmd_type {
-	SST_CMD_BYTES_SET = 1,
-	SST_CMD_BYTES_GET = 2,
-};
-
-enum sst_task {
-	SST_TASK_SBA = 1,
-	SST_TASK_MMX,
-};
-
-enum sst_type {
-	SST_TYPE_CMD = 1,
-	SST_TYPE_PARAMS,
-};
-
-enum sst_flag {
-	SST_FLAG_BLOCKED = 1,
-	SST_FLAG_NONBLOCK,
-};
-
-/*
- * Enumeration for indexing the gain cells in VB_SET_GAIN DSP command
- */
-enum sst_gain_index {
-	/* GAIN IDs for SB task start here */
-	SST_GAIN_INDEX_CODEC_OUT0,
-	SST_GAIN_INDEX_CODEC_OUT1,
-	SST_GAIN_INDEX_CODEC_IN0,
-	SST_GAIN_INDEX_CODEC_IN1,
-
-	SST_GAIN_INDEX_SPROT_LOOP_OUT,
-	SST_GAIN_INDEX_MEDIA_LOOP1_OUT,
-	SST_GAIN_INDEX_MEDIA_LOOP2_OUT,
-
-	SST_GAIN_INDEX_PCM0_IN_LEFT,
-	SST_GAIN_INDEX_PCM0_IN_RIGHT,
-
-	SST_GAIN_INDEX_PCM1_OUT_LEFT,
-	SST_GAIN_INDEX_PCM1_OUT_RIGHT,
-	SST_GAIN_INDEX_PCM1_IN_LEFT,
-	SST_GAIN_INDEX_PCM1_IN_RIGHT,
-	SST_GAIN_INDEX_PCM2_OUT_LEFT,
-
-	SST_GAIN_INDEX_PCM2_OUT_RIGHT,
-	SST_GAIN_INDEX_VOIP_OUT,
-	SST_GAIN_INDEX_VOIP_IN,
-
-	/* Gain IDs for MMX task start here */
-	SST_GAIN_INDEX_MEDIA0_IN_LEFT,
-	SST_GAIN_INDEX_MEDIA0_IN_RIGHT,
-	SST_GAIN_INDEX_MEDIA1_IN_LEFT,
-	SST_GAIN_INDEX_MEDIA1_IN_RIGHT,
-
-	SST_GAIN_INDEX_MEDIA2_IN_LEFT,
-	SST_GAIN_INDEX_MEDIA2_IN_RIGHT,
-
-	SST_GAIN_INDEX_GAIN_END
-};
-
-/*
- * Audio DSP module IDs specified by FW spec
- * TODO: Update with all modules
- */
-enum sst_module_id {
-	SST_MODULE_ID_PCM		  = 0x0001,
-	SST_MODULE_ID_MP3		  = 0x0002,
-	SST_MODULE_ID_MP24		  = 0x0003,
-	SST_MODULE_ID_AAC		  = 0x0004,
-	SST_MODULE_ID_AACP		  = 0x0005,
-	SST_MODULE_ID_EAACP		  = 0x0006,
-	SST_MODULE_ID_WMA9		  = 0x0007,
-	SST_MODULE_ID_WMA10		  = 0x0008,
-	SST_MODULE_ID_WMA10P		  = 0x0009,
-	SST_MODULE_ID_RA		  = 0x000A,
-	SST_MODULE_ID_DDAC3		  = 0x000B,
-	SST_MODULE_ID_TRUE_HD		  = 0x000C,
-	SST_MODULE_ID_HD_PLUS		  = 0x000D,
-
-	SST_MODULE_ID_SRC		  = 0x0064,
-	SST_MODULE_ID_DOWNMIX		  = 0x0066,
-	SST_MODULE_ID_GAIN_CELL		  = 0x0067,
-	SST_MODULE_ID_SPROT		  = 0x006D,
-	SST_MODULE_ID_BASS_BOOST	  = 0x006E,
-	SST_MODULE_ID_STEREO_WDNG	  = 0x006F,
-	SST_MODULE_ID_AV_REMOVAL	  = 0x0070,
-	SST_MODULE_ID_MIC_EQ		  = 0x0071,
-	SST_MODULE_ID_SPL		  = 0x0072,
-	SST_MODULE_ID_ALGO_VTSV           = 0x0073,
-	SST_MODULE_ID_NR		  = 0x0076,
-	SST_MODULE_ID_BWX		  = 0x0077,
-	SST_MODULE_ID_DRP		  = 0x0078,
-	SST_MODULE_ID_MDRP		  = 0x0079,
-
-	SST_MODULE_ID_ANA		  = 0x007A,
-	SST_MODULE_ID_AEC		  = 0x007B,
-	SST_MODULE_ID_NR_SNS		  = 0x007C,
-	SST_MODULE_ID_SER		  = 0x007D,
-	SST_MODULE_ID_AGC		  = 0x007E,
-
-	SST_MODULE_ID_CNI		  = 0x007F,
-	SST_MODULE_ID_CONTEXT_ALGO_AWARE  = 0x0080,
-	SST_MODULE_ID_FIR_24		  = 0x0081,
-	SST_MODULE_ID_IIR_24		  = 0x0082,
-
-	SST_MODULE_ID_ASRC		  = 0x0083,
-	SST_MODULE_ID_TONE_GEN		  = 0x0084,
-	SST_MODULE_ID_BMF		  = 0x0086,
-	SST_MODULE_ID_EDL		  = 0x0087,
-	SST_MODULE_ID_GLC		  = 0x0088,
-
-	SST_MODULE_ID_FIR_16		  = 0x0089,
-	SST_MODULE_ID_IIR_16		  = 0x008A,
-	SST_MODULE_ID_DNR		  = 0x008B,
-
-	SST_MODULE_ID_VIRTUALIZER	  = 0x008C,
-	SST_MODULE_ID_VISUALIZATION	  = 0x008D,
-	SST_MODULE_ID_LOUDNESS_OPTIMIZER  = 0x008E,
-	SST_MODULE_ID_REVERBERATION	  = 0x008F,
-
-	SST_MODULE_ID_CNI_TX		  = 0x0090,
-	SST_MODULE_ID_REF_LINE		  = 0x0091,
-	SST_MODULE_ID_VOLUME		  = 0x0092,
-	SST_MODULE_ID_FILT_DCR		  = 0x0094,
-	SST_MODULE_ID_SLV		  = 0x009A,
-	SST_MODULE_ID_NLF		  = 0x009B,
-	SST_MODULE_ID_TNR		  = 0x009C,
-	SST_MODULE_ID_WNR		  = 0x009D,
-
-	SST_MODULE_ID_LOG		  = 0xFF00,
-
-	SST_MODULE_ID_TASK		  = 0xFFFF,
-};
-
-enum sst_cmd {
-	SBA_IDLE		= 14,
-	SBA_VB_SET_SPEECH_PATH	= 26,
-	MMX_SET_GAIN		= 33,
-	SBA_VB_SET_GAIN		= 33,
-	FBA_VB_RX_CNI		= 35,
-	MMX_SET_GAIN_TIMECONST	= 36,
-	SBA_VB_SET_TIMECONST	= 36,
-	SBA_VB_START		= 85,
-	SBA_SET_SWM		= 114,
-	SBA_SET_MDRP            = 116,
-	SBA_HW_SET_SSP		= 117,
-	SBA_SET_MEDIA_LOOP_MAP	= 118,
-	SBA_SET_MEDIA_PATH	= 119,
-	MMX_SET_MEDIA_PATH	= 119,
-	SBA_VB_LPRO             = 126,
-	SBA_VB_SET_FIR          = 128,
-	SBA_VB_SET_IIR          = 129,
-	SBA_SET_SSP_SLOT_MAP	= 130,
-};
-
-enum sst_dsp_switch {
-	SST_SWITCH_OFF = 0,
-	SST_SWITCH_ON = 3,
-};
-
-enum sst_path_switch {
-	SST_PATH_OFF = 0,
-	SST_PATH_ON = 1,
-};
-
-enum sst_swm_state {
-	SST_SWM_OFF = 0,
-	SST_SWM_ON = 3,
-};
-
-#define SST_FILL_LOCATION_IDS(dst, cell_idx, pipe_id)		do {	\
-		dst.location_id.p.cell_nbr_idx = (cell_idx);		\
-		dst.location_id.p.path_id = (pipe_id);			\
-	} while (0)
-#define SST_FILL_LOCATION_ID(dst, loc_id)				(\
-	dst.location_id.f = (loc_id))
-#define SST_FILL_MODULE_ID(dst, mod_id)					(\
-	dst.module_id = (mod_id))
-
-#define SST_FILL_DESTINATION1(dst, id)				do {	\
-		SST_FILL_LOCATION_ID(dst, (id) & 0xFFFF);		\
-		SST_FILL_MODULE_ID(dst, ((id) & 0xFFFF0000) >> 16);	\
-	} while (0)
-#define SST_FILL_DESTINATION2(dst, loc_id, mod_id)		do {	\
-		SST_FILL_LOCATION_ID(dst, loc_id);			\
-		SST_FILL_MODULE_ID(dst, mod_id);			\
-	} while (0)
-#define SST_FILL_DESTINATION3(dst, cell_idx, path_id, mod_id)	do {	\
-		SST_FILL_LOCATION_IDS(dst, cell_idx, path_id);		\
-		SST_FILL_MODULE_ID(dst, mod_id);			\
-	} while (0)
-
-#define SST_FILL_DESTINATION(level, dst, ...)				\
-	SST_FILL_DESTINATION##level(dst, __VA_ARGS__)
-#define SST_FILL_DEFAULT_DESTINATION(dst)				\
-	SST_FILL_DESTINATION(2, dst, SST_DEFAULT_LOCATION_ID, SST_DEFAULT_MODULE_ID)
-
-struct sst_destination_id {
-	union sst_location_id {
-		struct {
-			u8 cell_nbr_idx;	/* module index */
-			u8 path_id;		/* pipe_id */
-		} __packed	p;		/* part */
-		u16		f;		/* full */
-	} __packed location_id;
-	u16	   module_id;
-} __packed;
-struct sst_dsp_header {
-	struct sst_destination_id dst;
-	u16 command_id;
-	u16 length;
-} __packed;
-
-/*
- *
- * Common Commands
- *
- */
-struct sst_cmd_generic {
-	struct sst_dsp_header header;
-} __packed;
-
-struct swm_input_ids {
-	struct sst_destination_id input_id;
-} __packed;
-
-struct sst_cmd_set_swm {
-	struct sst_dsp_header header;
-	struct sst_destination_id output_id;
-	u16    switch_state;
-	u16    nb_inputs;
-	struct swm_input_ids input[SST_CMD_SWM_MAX_INPUTS];
-} __packed;
-
-struct sst_cmd_set_media_path {
-	struct sst_dsp_header header;
-	u16    switch_state;
-} __packed;
-
-struct pcm_cfg {
-		u8 s_length:2;
-		u8 rate:3;
-		u8 format:3;
-} __packed;
-
-struct sst_cmd_set_speech_path {
-	struct sst_dsp_header header;
-	u16    switch_state;
-	struct {
-		u16 rsvd:8;
-		struct pcm_cfg cfg;
-	} config;
-} __packed;
-
-struct gain_cell {
-	struct sst_destination_id dest;
-	s16 cell_gain_left;
-	s16 cell_gain_right;
-	u16 gain_time_constant;
-} __packed;
-
-#define NUM_GAIN_CELLS 1
-struct sst_cmd_set_gain_dual {
-	struct sst_dsp_header header;
-	u16    gain_cell_num;
-	struct gain_cell cell_gains[NUM_GAIN_CELLS];
-} __packed;
-struct sst_cmd_set_params {
-	struct sst_destination_id dst;
-	u16 command_id;
-	char params[0];
-} __packed;
-
-
-struct sst_cmd_sba_vb_start {
-	struct sst_dsp_header header;
-} __packed;
-
-union sba_media_loop_params {
-	struct {
-		u16 rsvd:8;
-		struct pcm_cfg cfg;
-	} part;
-	u16 full;
-} __packed;
-
-struct sst_cmd_sba_set_media_loop_map {
-	struct	sst_dsp_header header;
-	u16	switch_state;
-	union	sba_media_loop_params param;
-	u16	map;
-} __packed;
-
-struct sst_cmd_tone_stop {
-	struct	sst_dsp_header header;
-	u16	switch_state;
-} __packed;
-
-enum sst_ssp_mode {
-	SSP_MODE_MASTER = 0,
-	SSP_MODE_SLAVE = 1,
-};
-
-enum sst_ssp_pcm_mode {
-	SSP_PCM_MODE_NORMAL = 0,
-	SSP_PCM_MODE_NETWORK = 1,
-};
-
-enum sst_ssp_duplex {
-	SSP_DUPLEX = 0,
-	SSP_RX = 1,
-	SSP_TX = 2,
-};
-
-enum sst_ssp_fs_frequency {
-	SSP_FS_8_KHZ = 0,
-	SSP_FS_16_KHZ = 1,
-	SSP_FS_44_1_KHZ = 2,
-	SSP_FS_48_KHZ = 3,
-};
-
-enum sst_ssp_fs_polarity {
-	SSP_FS_ACTIVE_LOW = 0,
-	SSP_FS_ACTIVE_HIGH = 1,
-};
-
-enum sst_ssp_protocol {
-	SSP_MODE_PCM = 0,
-	SSP_MODE_I2S = 1,
-};
-
-enum sst_ssp_port_id {
-	SSP_MODEM = 0,
-	SSP_BT = 1,
-	SSP_FM = 2,
-	SSP_CODEC = 3,
-};
-
-struct sst_cmd_sba_hw_set_ssp {
-	struct sst_dsp_header header;
-	u16 selection;			/* 0:SSP0(def), 1:SSP1, 2:SSP2 */
-
-	u16 switch_state;
-
-	u16 nb_bits_per_slots:6;        /* 0-32 bits, 24 (def) */
-	u16 nb_slots:4;			/* 0-8: slots per frame  */
-	u16 mode:3;			/* 0:Master, 1: Slave  */
-	u16 duplex:3;
-
-	u16 active_tx_slot_map:8;       /* Bit map, 0:off, 1:on */
-	u16 reserved1:8;
-
-	u16 active_rx_slot_map:8;       /* Bit map 0: Off, 1:On */
-	u16 reserved2:8;
-
-	u16 frame_sync_frequency;
-
-	u16 frame_sync_polarity:8;
-	u16 data_polarity:8;
-
-	u16 frame_sync_width;           /* 1 to N clocks */
-	u16 ssp_protocol:8;
-	u16 start_delay:8;		/* Start delay in terms of clock ticks */
-} __packed;
-
-#define SST_MAX_TDM_SLOTS 8
-
-struct sst_param_sba_ssp_slot_map {
-	struct sst_dsp_header header;
-
-	u16 param_id;
-	u16 param_len;
-	u16 ssp_index;
-
-	u8 rx_slot_map[SST_MAX_TDM_SLOTS];
-	u8 tx_slot_map[SST_MAX_TDM_SLOTS];
-} __packed;
-
-enum {
-	SST_PROBE_EXTRACTOR = 0,
-	SST_PROBE_INJECTOR = 1,
-};
-
-/**** widget defines *****/
-
-#define SST_MODULE_GAIN 1
-#define SST_MODULE_ALGO 2
-
-#define SST_FMT_MONO 0
-#define SST_FMT_STEREO 3
-
-/* physical SSP numbers */
-enum {
-	SST_SSP0 = 0,
-	SST_SSP1,
-	SST_SSP2,
-	SST_SSP_LAST = SST_SSP2,
-};
-
-#define SST_NUM_SSPS		(SST_SSP_LAST + 1)	/* physical SSPs */
-#define SST_MAX_SSP_MUX		2			/* single SSP muxed between pipes */
-#define SST_MAX_SSP_DOMAINS	2			/* domains present in each pipe */
-
-struct sst_module {
-	struct snd_kcontrol *kctl;
-	struct list_head node;
-};
-
-struct sst_ssp_config {
-	u8 ssp_id;
-	u8 bits_per_slot;
-	u8 slots;
-	u8 ssp_mode;
-	u8 pcm_mode;
-	u8 duplex;
-	u8 ssp_protocol;
-	u8 fs_frequency;
-	u8 active_slot_map;
-	u8 start_delay;
-	u16 fs_width;
-};
-
-struct sst_ssp_cfg {
-	const u8 ssp_number;
-	const int *mux_shift;
-	const int (*domain_shift)[SST_MAX_SSP_MUX];
-	const struct sst_ssp_config (*ssp_config)[SST_MAX_SSP_MUX][SST_MAX_SSP_DOMAINS];
-};
-
-struct sst_ids {
-	u16 location_id;
-	u16 module_id;
-	u8  task_id;
-	u8  format;
-	u8  reg;
-	const char *parent_wname;
-	struct snd_soc_dapm_widget *parent_w;
-	struct list_head algo_list;
-	struct list_head gain_list;
-	const struct sst_pcm_format *pcm_fmt;
-};
-
-
-#define SST_AIF_IN(wname, wevent)							\
-{	.id = snd_soc_dapm_aif_in, .name = wname, .sname = NULL,			\
-	.reg = SND_SOC_NOPM, .shift = 0,					\
-	.on_val = 1, .off_val = 0,							\
-	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
-	.priv = (void *)&(struct sst_ids) { .task_id = 0, .location_id = 0 }		\
-}
-
-#define SST_AIF_OUT(wname, wevent)							\
-{	.id = snd_soc_dapm_aif_out, .name = wname, .sname = NULL,			\
-	.reg = SND_SOC_NOPM, .shift = 0,						\
-	.on_val = 1, .off_val = 0,							\
-	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
-	.priv = (void *)&(struct sst_ids) { .task_id = 0, .location_id = 0 }		\
-}
-
-#define SST_INPUT(wname, wevent)							\
-{	.id = snd_soc_dapm_input, .name = wname, .sname = NULL,				\
-	.reg = SND_SOC_NOPM, .shift = 0,						\
-	.on_val = 1, .off_val = 0,							\
-	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
-	.priv = (void *)&(struct sst_ids) { .task_id = 0, .location_id = 0 }		\
-}
-
-#define SST_OUTPUT(wname, wevent)							\
-{	.id = snd_soc_dapm_output, .name = wname, .sname = NULL,			\
-	.reg = SND_SOC_NOPM, .shift = 0,						\
-	.on_val = 1, .off_val = 0,							\
-	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
-	.priv = (void *)&(struct sst_ids) { .task_id = 0, .location_id = 0 }		\
-}
-
-#define SST_DAPM_OUTPUT(wname, wloc_id, wtask_id, wformat, wevent)                      \
-{	.id = snd_soc_dapm_output, .name = wname, .sname = NULL,                        \
-	.reg = SND_SOC_NOPM, .shift = 0,						\
-	.on_val = 1, .off_val = 0,							\
-	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,   \
-	.priv = (void *)&(struct sst_ids) { .location_id = wloc_id, .task_id = wtask_id,\
-						.pcm_fmt = wformat, }			\
-}
-
-#define SST_PATH(wname, wtask, wloc_id, wevent, wflags)					\
-{	.id = snd_soc_dapm_pga, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,		\
-	.kcontrol_news = NULL, .num_kcontrols = 0,				\
-	.on_val = 1, .off_val = 0,							\
-	.event = wevent, .event_flags = wflags,						\
-	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id, }	\
-}
-
-#define SST_LINKED_PATH(wname, wtask, wloc_id, linked_wname, wevent, wflags)		\
-{	.id = snd_soc_dapm_pga, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,		\
-	.kcontrol_news = NULL, .num_kcontrols = 0,				\
-	.on_val = 1, .off_val = 0,							\
-	.event = wevent, .event_flags = wflags,						\
-	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id,	\
-					.parent_wname = linked_wname}			\
-}
-
-#define SST_PATH_MEDIA_LOOP(wname, wtask, wloc_id, wformat, wevent, wflags)             \
-{	.id = snd_soc_dapm_pga, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,         \
-	.kcontrol_news = NULL, .num_kcontrols = 0,                         \
-	.event = wevent, .event_flags = wflags,                                         \
-	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id,	\
-					    .format = wformat,}				\
-}
-
-/* output is triggered before input */
-#define SST_PATH_INPUT(name, task_id, loc_id, event)					\
-	SST_PATH(name, task_id, loc_id, event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD)
-
-#define SST_PATH_LINKED_INPUT(name, task_id, loc_id, linked_wname, event)		\
-	SST_LINKED_PATH(name, task_id, loc_id, linked_wname, event,			\
-					SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD)
-
-#define SST_PATH_OUTPUT(name, task_id, loc_id, event)					\
-	SST_PATH(name, task_id, loc_id, event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD)
-
-#define SST_PATH_LINKED_OUTPUT(name, task_id, loc_id, linked_wname, event)		\
-	SST_LINKED_PATH(name, task_id, loc_id, linked_wname, event,			\
-					SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD)
-
-#define SST_PATH_MEDIA_LOOP_OUTPUT(name, task_id, loc_id, format, event)		\
-	SST_PATH_MEDIA_LOOP(name, task_id, loc_id, format, event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD)
-
-
-#define SST_SWM_MIXER(wname, wreg, wtask, wloc_id, wcontrols, wevent)			\
-{	.id = snd_soc_dapm_mixer, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,	\
-	.kcontrol_news = wcontrols, .num_kcontrols = ARRAY_SIZE(wcontrols),\
-	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD |	\
-					SND_SOC_DAPM_POST_REG,				\
-	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id,	\
-					    .reg = wreg }				\
-}
-
-enum sst_gain_kcontrol_type {
-	SST_GAIN_TLV,
-	SST_GAIN_MUTE,
-	SST_GAIN_RAMP_DURATION,
-};
-
-struct sst_gain_mixer_control {
-	bool stereo;
-	enum sst_gain_kcontrol_type type;
-	struct sst_gain_value *gain_val;
-	int max;
-	int min;
-	u16 instance_id;
-	u16 module_id;
-	u16 pipe_id;
-	u16 task_id;
-	char pname[44];
-	struct snd_soc_dapm_widget *w;
-};
-
-struct sst_gain_value {
-	u16 ramp_duration;
-	s16 l_gain;
-	s16 r_gain;
-	bool mute;
-};
-#define SST_GAIN_VOLUME_DEFAULT		(-1440)
-#define SST_GAIN_RAMP_DURATION_DEFAULT	5 /* timeconstant */
-#define SST_GAIN_MUTE_DEFAULT		true
-
-#define SST_GAIN_KCONTROL_TLV(xname, xhandler_get, xhandler_put, \
-			      xmod, xpipe, xinstance, xtask, tlv_array, xgain_val, \
-			      xmin, xmax, xpname) \
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
-	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
-		  SNDRV_CTL_ELEM_ACCESS_READWRITE, \
-	.tlv.p = (tlv_array), \
-	.info = sst_gain_ctl_info,\
-	.get = xhandler_get, .put = xhandler_put, \
-	.private_value = (unsigned long)&(struct sst_gain_mixer_control) \
-	{ .stereo = true, .max = xmax, .min = xmin, .type = SST_GAIN_TLV, \
-	  .module_id = xmod, .pipe_id = xpipe, .task_id = xtask,\
-	  .instance_id = xinstance, .gain_val = xgain_val, .pname = xpname}
-
-#define SST_GAIN_KCONTROL_INT(xname, xhandler_get, xhandler_put, \
-			      xmod, xpipe, xinstance, xtask, xtype, xgain_val, \
-			      xmin, xmax, xpname) \
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
-	.info = sst_gain_ctl_info, \
-	.get = xhandler_get, .put = xhandler_put, \
-	.private_value = (unsigned long)&(struct sst_gain_mixer_control) \
-	{ .stereo = false, .max = xmax, .min = xmin, .type = xtype, \
-	  .module_id = xmod, .pipe_id = xpipe, .task_id = xtask,\
-	  .instance_id = xinstance, .gain_val = xgain_val, .pname =  xpname}
-
-#define SST_GAIN_KCONTROL_BOOL(xname, xhandler_get, xhandler_put,\
-			       xmod, xpipe, xinstance, xtask, xgain_val, xpname) \
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
-	.info = snd_soc_info_bool_ext, \
-	.get = xhandler_get, .put = xhandler_put, \
-	.private_value = (unsigned long)&(struct sst_gain_mixer_control) \
-	{ .stereo = false, .type = SST_GAIN_MUTE, \
-	  .module_id = xmod, .pipe_id = xpipe, .task_id = xtask,\
-	  .instance_id = xinstance, .gain_val = xgain_val, .pname = xpname}
-#define SST_CONTROL_NAME(xpname, xmname, xinstance, xtype) \
-	xpname " " xmname " " #xinstance " " xtype
-
-#define SST_COMBO_CONTROL_NAME(xpname, xmname, xinstance, xtype, xsubmodule) \
-	xpname " " xmname " " #xinstance " " xtype " " xsubmodule
-
-/*
- * 3 Controls for each Gain module
- * e.g.	- pcm0_in Gain 0 Volume
- *	- pcm0_in Gain 0 Ramp Delay
- *	- pcm0_in Gain 0 Switch
- */
-#define SST_GAIN_KCONTROLS(xpname, xmname, xmin_gain, xmax_gain, xmin_tc, xmax_tc, \
-			   xhandler_get, xhandler_put, \
-			   xmod, xpipe, xinstance, xtask, tlv_array, xgain_val) \
-	{ SST_GAIN_KCONTROL_INT(SST_CONTROL_NAME(xpname, xmname, xinstance, "Ramp Delay"), \
-		xhandler_get, xhandler_put, xmod, xpipe, xinstance, xtask, SST_GAIN_RAMP_DURATION, \
-		xgain_val, xmin_tc, xmax_tc, xpname) }, \
-	{ SST_GAIN_KCONTROL_BOOL(SST_CONTROL_NAME(xpname, xmname, xinstance, "Switch"), \
-		xhandler_get, xhandler_put, xmod, xpipe, xinstance, xtask, \
-		xgain_val, xpname) } ,\
-	{ SST_GAIN_KCONTROL_TLV(SST_CONTROL_NAME(xpname, xmname, xinstance, "Volume"), \
-		xhandler_get, xhandler_put, xmod, xpipe, xinstance, xtask, tlv_array, \
-		xgain_val, xmin_gain, xmax_gain, xpname) }
-
-#define SST_GAIN_TC_MIN		5
-#define SST_GAIN_TC_MAX		5000
-#define SST_GAIN_MIN_VALUE	-1440 /* in 0.1 DB units */
-#define SST_GAIN_MAX_VALUE	360
-
-enum sst_algo_kcontrol_type {
-	SST_ALGO_PARAMS,
-	SST_ALGO_BYPASS,
-};
-
-struct sst_algo_control {
-	enum sst_algo_kcontrol_type type;
-	int max;
-	u16 module_id;
-	u16 pipe_id;
-	u16 task_id;
-	u16 cmd_id;
-	bool bypass;
-	unsigned char *params;
-	struct snd_soc_dapm_widget *w;
-};
-
-/* size of the control = size of params + size of length field */
-#define SST_ALGO_CTL_VALUE(xcount, xtype, xpipe, xmod, xtask, xcmd)			\
-	(struct sst_algo_control){							\
-		.max = xcount + sizeof(u16), .type = xtype, .module_id = xmod,			\
-		.pipe_id = xpipe, .task_id = xtask, .cmd_id = xcmd,			\
-	}
-
-#define SST_ALGO_KCONTROL(xname, xcount, xmod, xpipe,					\
-			  xtask, xcmd, xtype, xinfo, xget, xput)			\
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,						\
-	.name =  xname,									\
-	.info = xinfo, .get = xget, .put = xput,					\
-	.private_value = (unsigned long)&						\
-			SST_ALGO_CTL_VALUE(xcount, xtype, xpipe,			\
-					   xmod, xtask, xcmd),				\
-}
-
-#define SST_ALGO_KCONTROL_BYTES(xpname, xmname, xcount, xmod,				\
-				xpipe, xinstance, xtask, xcmd)				\
-	SST_ALGO_KCONTROL(SST_CONTROL_NAME(xpname, xmname, xinstance, "params"),	\
-			  xcount, xmod, xpipe, xtask, xcmd, SST_ALGO_PARAMS,		\
-			  sst_algo_bytes_ctl_info,					\
-			  sst_algo_control_get, sst_algo_control_set)
-
-#define SST_ALGO_KCONTROL_BOOL(xpname, xmname, xmod, xpipe, xinstance, xtask)		\
-	SST_ALGO_KCONTROL(SST_CONTROL_NAME(xpname, xmname, xinstance, "bypass"),	\
-			  0, xmod, xpipe, xtask, 0, SST_ALGO_BYPASS,			\
-			  snd_soc_info_bool_ext,					\
-			  sst_algo_control_get, sst_algo_control_set)
-
-#define SST_ALGO_BYPASS_PARAMS(xpname, xmname, xcount, xmod, xpipe,			\
-				xinstance, xtask, xcmd)					\
-	SST_ALGO_KCONTROL_BOOL(xpname, xmname, xmod, xpipe, xinstance, xtask),		\
-	SST_ALGO_KCONTROL_BYTES(xpname, xmname, xcount, xmod, xpipe, xinstance, xtask, xcmd)
-
-#define SST_COMBO_ALGO_KCONTROL_BYTES(xpname, xmname, xsubmod, xcount, xmod,		\
-				      xpipe, xinstance, xtask, xcmd)			\
-	SST_ALGO_KCONTROL(SST_COMBO_CONTROL_NAME(xpname, xmname, xinstance, "params",	\
-						 xsubmod),				\
-			  xcount, xmod, xpipe, xtask, xcmd, SST_ALGO_PARAMS,		\
-			  sst_algo_bytes_ctl_info,					\
-			  sst_algo_control_get, sst_algo_control_set)
-
-
-struct sst_enum {
-	bool tx;
-	unsigned short reg;
-	unsigned int max;
-	const char * const *texts;
-	struct snd_soc_dapm_widget *w;
-};
-
-/* only 4 slots/channels supported atm */
-#define SST_SSP_SLOT_ENUM(s_ch_no, is_tx, xtexts) \
-	(struct sst_enum){ .reg = s_ch_no, .tx = is_tx, .max = 4+1, .texts = xtexts, }
-
-#define SST_SLOT_CTL_NAME(xpname, xmname, s_ch_name) \
-	xpname " " xmname " " s_ch_name
-
-#define SST_SSP_SLOT_CTL(xpname, xmname, s_ch_name, s_ch_no, is_tx, xtexts, xget, xput) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-	.name = SST_SLOT_CTL_NAME(xpname, xmname, s_ch_name), \
-	.info = sst_slot_enum_info, \
-	.get = xget, .put = xput, \
-	.private_value = (unsigned long)&SST_SSP_SLOT_ENUM(s_ch_no, is_tx, xtexts), \
-}
-
-#define SST_MUX_CTL_NAME(xpname, xinstance) \
-	xpname " " #xinstance
-
-#define SST_SSP_MUX_ENUM(xreg, xshift, xtexts) \
-	(struct soc_enum) SOC_ENUM_DOUBLE(xreg, xshift, xshift, ARRAY_SIZE(xtexts), xtexts)
-
-#define SST_SSP_MUX_CTL(xpname, xinstance, xreg, xshift, xtexts) \
-	SOC_DAPM_ENUM(SST_MUX_CTL_NAME(xpname, xinstance), \
-			  SST_SSP_MUX_ENUM(xreg, xshift, xtexts))
-
-#endif
diff -Naur linux-3.19.old/sound/soc/intel/sst-baytrail-dsp.c linux-3.19/sound/soc/intel/sst-baytrail-dsp.c
--- linux-3.19.old/sound/soc/intel/sst-baytrail-dsp.c	2015-03-24 17:38:14.403176947 -0800
+++ linux-3.19/sound/soc/intel/sst-baytrail-dsp.c	2015-03-24 18:19:04.684663440 -0800
@@ -12,6 +12,7 @@
  * more details.
  */
 
+#include <linux/acpi.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
 #include <linux/slab.h>
@@ -156,7 +157,7 @@
 	return 0;
 }
 
-static void sst_byt_dump_shim(struct sst_dsp *sst)
+void sst_byt_dump_shim(struct sst_dsp *sst)
 {
 	int i;
 	u64 reg;
@@ -185,6 +186,7 @@
 	spin_lock(&sst->spinlock);
 
 	isrx = sst_dsp_shim_read64_unlocked(sst, SST_ISRX);
+
 	if (isrx & SST_ISRX_DONE) {
 		/* ADSP has processed the message request from IA */
 		sst_dsp_shim_update_bits64_unlocked(sst, SST_IPCX,
@@ -231,11 +233,19 @@
 
 static void sst_byt_reset(struct sst_dsp *sst)
 {
-	/* put DSP into reset, set reset vector and stall */
+	/* set reset vector and stall */
+	sst_dsp_shim_update_bits64(sst, SST_CSR,
+		SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL,
+		SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL);
+
+	udelay(10);
+
+	/* put DSP into reset */
 	sst_dsp_shim_update_bits64(sst, SST_CSR,
-		SST_BYT_CSR_RST | SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL,
-		SST_BYT_CSR_RST | SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL);
+		SST_BYT_CSR_RST, SST_BYT_CSR_RST);
 
+	/* dummy read to make sure clock is ungated */
+	sst_dsp_shim_read64_unlocked(sst, SST_IPCD);
 	udelay(10);
 
 	/* take DSP out of reset and keep stalled for FW loading */
@@ -290,6 +300,31 @@
 	return 0;
 }
 
+static int byt_enable_shim(struct sst_dsp *sst)
+{
+	/* enable shim - do dummy read */
+	writel(0, sst->addr.pci_cfg + 0x84);
+	dev_err(sst->dev, "PMCS read 0x%x\n", readl(sst->addr.pci_cfg + 0x84));
+
+	/* make sure that ADSP shim is enabled */
+	mdelay(11);
+
+	/* enable Interrupt from both sides */
+	sst_dsp_shim_update_bits64(sst, SST_IMRX, 0x3, 0x0);
+	sst_dsp_shim_update_bits64(sst, SST_IMRD, 0x3, 0x0);
+
+	sst_dsp_shim_update_bits64(sst, 0x10, 0x20, 0x0); /* unMask SSP2 */
+	sst_dsp_shim_update_bits64(sst, 0x78, 0x7, 0x5); /* 200MHz */
+
+	sst_byt_dump_shim(sst);
+	return 0;
+}
+
+int sst_byt_d0(struct sst_dsp *sst)
+{
+	return byt_enable_shim(sst);
+}
+
 static int sst_byt_init(struct sst_dsp *sst, struct sst_pdata *pdata)
 {
 	const struct sst_adsp_memregion *region;
@@ -318,7 +353,9 @@
 		return ret;
 	}
 
-	ret = dma_coerce_mask_and_coherent(sst->dma_dev, DMA_BIT_MASK(32));
+	sst_byt_d0(sst);
+
+	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
 	if (ret)
 		return ret;
 
diff -Naur linux-3.19.old/sound/soc/intel/sst-baytrail-ipc.c linux-3.19/sound/soc/intel/sst-baytrail-ipc.c
--- linux-3.19.old/sound/soc/intel/sst-baytrail-ipc.c	2015-03-24 17:38:14.409843613 -0800
+++ linux-3.19/sound/soc/intel/sst-baytrail-ipc.c	2015-03-24 18:19:04.684663440 -0800
@@ -25,7 +25,6 @@
 #include <linux/platform_device.h>
 #include <linux/kthread.h>
 #include <linux/firmware.h>
-#include <linux/io.h>
 #include <asm/div64.h>
 
 #include "sst-baytrail-ipc.h"
@@ -122,26 +121,6 @@
 	u32 channel_peak[8];
 } __packed;
 
-struct sst_byt_fw_version {
-	u8 build;
-	u8 minor;
-	u8 major;
-	u8 type;
-} __packed;
-
-struct sst_byt_fw_build_info {
-	u8 date[16];
-	u8 time[16];
-} __packed;
-
-struct sst_byt_fw_init {
-	struct sst_byt_fw_version fw_version;
-	struct sst_byt_fw_build_info build_info;
-	u16 result;
-	u8 module_id;
-	u8 debug_info;
-} __packed;
-
 /* driver internal IPC message structure */
 struct ipc_message {
 	struct list_head list;
@@ -165,6 +144,7 @@
 /* stream infomation */
 struct sst_byt_stream {
 	struct list_head node;
+	struct work_struct notify_work;
 
 	/* configuration */
 	struct sst_byt_alloc_params request;
@@ -175,6 +155,7 @@
 	int str_id;
 	bool commited;
 	bool running;
+	u32 start_offset;
 
 	/* driver callback */
 	u32 (*notify_position)(struct sst_byt_stream *stream, void *data);
@@ -188,6 +169,7 @@
 
 	/* stream */
 	struct list_head stream_list;
+	int stream_count;
 
 	/* boot */
 	wait_queue_head_t boot_wait;
@@ -203,6 +185,11 @@
 	struct kthread_worker kworker;
 	struct kthread_work kwork;
 	struct ipc_message *msg;
+
+	/* can be used to notfy that LRCLK and BCLK have started */
+	void (*notify_start)(struct sst_dsp *dsp, void *);
+	void (*notify_stop)(struct sst_dsp *dsp, void *);
+	void *notify_data;
 };
 
 static inline u64 sst_byt_header(int msg_id, int data, bool large, int str_id)
@@ -449,6 +436,22 @@
 	return msg;
 }
 
+static void sst_byt_notify_work(struct work_struct *work)
+{
+	struct sst_byt_stream *stream =
+		container_of(work, struct sst_byt_stream, notify_work);
+	struct sst_byt *byt  = stream->byt;
+
+	if (byt->stream_count > 0) {
+		if (byt->notify_start)
+			byt->notify_start(byt->dsp, byt->notify_data);
+	} else {
+		byt->stream_count = 0;
+		if (byt->notify_stop)
+			byt->notify_stop(byt->dsp, byt->notify_data);
+	}
+}
+
 static void sst_byt_stream_update(struct sst_byt *byt, struct ipc_message *msg)
 {
 	struct sst_byt_stream *stream;
@@ -465,10 +468,12 @@
 	case IPC_IA_PAUSE_STREAM:
 	case IPC_IA_FREE_STREAM:
 		stream->running = false;
+		schedule_work(&stream->notify_work);
 		break;
 	case IPC_IA_START_STREAM:
 	case IPC_IA_RESUME_STREAM:
 		stream->running = true;
+		schedule_work(&stream->notify_work);
 		break;
 	}
 }
@@ -580,8 +585,8 @@
 	void *data)
 {
 	struct sst_byt_stream *stream;
-	struct sst_dsp *sst = byt->dsp;
 	unsigned long flags;
+	struct sst_dsp *sst = byt->dsp;
 
 	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
 	if (stream == NULL)
@@ -589,6 +594,7 @@
 
 	spin_lock_irqsave(&sst->spinlock, flags);
 	list_add(&stream->node, &byt->stream_list);
+	INIT_WORK(&stream->notify_work, sst_byt_notify_work);
 	stream->notify_position = notify_position;
 	stream->pdata = data;
 	stream->byt = byt;
@@ -619,6 +625,13 @@
 	return 0;
 }
 
+int sst_byt_stream_set_offset(struct sst_byt *byt,
+	struct sst_byt_stream *stream, u32 offset)
+{
+	stream->start_offset = offset;
+	return 0;
+}
+
 /* stream sonfiguration */
 int sst_byt_stream_type(struct sst_byt *byt, struct sst_byt_stream *stream,
 			int codec_type, int stream_type, int operation)
@@ -688,6 +701,7 @@
 
 	stream->commited = false;
 out:
+	cancel_work_sync(&stream->notify_work);
 	spin_lock_irqsave(&sst->spinlock, flags);
 	list_del(&stream->node);
 	kfree(stream);
@@ -697,39 +711,44 @@
 }
 
 static int sst_byt_stream_operations(struct sst_byt *byt, int type,
-				     int stream_id, int wait)
+				    struct sst_byt_stream *stream, int wait)
 {
+	struct sst_byt_start_stream_params start_stream;
 	u64 header;
+	void *tx_msg = NULL;
+	size_t size = 0;
+
+	if (type != IPC_IA_START_STREAM) {
+		header = sst_byt_header(type, 0, false, stream->str_id);
+	} else {
+		start_stream.byte_offset = stream->start_offset;
+		header = sst_byt_header(IPC_IA_START_STREAM,
+					sizeof(start_stream) + sizeof(u32),
+					true, stream->str_id);
+		tx_msg = &start_stream;
+		size = sizeof(start_stream);
+	}
 
-	header = sst_byt_header(type, 0, false, stream_id);
 	if (wait)
-		return sst_byt_ipc_tx_msg_wait(byt, header, NULL, 0, NULL, 0);
+		return sst_byt_ipc_tx_msg_wait(byt, header,
+					       tx_msg, size, NULL, 0);
 	else
-		return sst_byt_ipc_tx_msg_nowait(byt, header, NULL, 0);
+		return sst_byt_ipc_tx_msg_nowait(byt, header, tx_msg, size);
 }
 
 /* stream ALSA trigger operations */
-int sst_byt_stream_start(struct sst_byt *byt, struct sst_byt_stream *stream,
-			 u32 start_offset)
+int sst_byt_stream_start(struct sst_byt *byt, struct sst_byt_stream *stream)
 {
-	struct sst_byt_start_stream_params start_stream;
-	void *tx_msg;
-	size_t size;
-	u64 header;
 	int ret;
 
-	start_stream.byte_offset = start_offset;
-	header = sst_byt_header(IPC_IA_START_STREAM,
-				sizeof(start_stream) + sizeof(u32),
-				true, stream->str_id);
-	tx_msg = &start_stream;
-	size = sizeof(start_stream);
-
-	ret = sst_byt_ipc_tx_msg_nowait(byt, header, tx_msg, size);
+	ret = sst_byt_stream_operations(byt, IPC_IA_START_STREAM, stream, 0);
 	if (ret < 0)
 		dev_err(byt->dev, "ipc: error failed to start stream %d\n",
 			stream->str_id);
 
+	/* reset start offset */
+	stream->start_offset = 0;
+	byt->stream_count++;
 	return ret;
 }
 
@@ -741,11 +760,11 @@
 	if (!stream->commited)
 		return 0;
 
-	ret = sst_byt_stream_operations(byt, IPC_IA_DROP_STREAM,
-					stream->str_id, 0);
+	ret = sst_byt_stream_operations(byt, IPC_IA_DROP_STREAM, stream, 0);
 	if (ret < 0)
 		dev_err(byt->dev, "ipc: error failed to stop stream %d\n",
 			stream->str_id);
+	byt->stream_count--;
 	return ret;
 }
 
@@ -753,8 +772,7 @@
 {
 	int ret;
 
-	ret = sst_byt_stream_operations(byt, IPC_IA_PAUSE_STREAM,
-					stream->str_id, 0);
+	ret = sst_byt_stream_operations(byt, IPC_IA_PAUSE_STREAM, stream, 0);
 	if (ret < 0)
 		dev_err(byt->dev, "ipc: error failed to pause stream %d\n",
 			stream->str_id);
@@ -766,8 +784,7 @@
 {
 	int ret;
 
-	ret = sst_byt_stream_operations(byt, IPC_IA_RESUME_STREAM,
-					stream->str_id, 0);
+	ret = sst_byt_stream_operations(byt, IPC_IA_RESUME_STREAM, stream, 0);
 	if (ret < 0)
 		dev_err(byt->dev, "ipc: error failed to resume stream %d\n",
 			stream->str_id);
@@ -817,70 +834,10 @@
 	.ops = &sst_byt_ops,
 };
 
-int sst_byt_dsp_suspend_late(struct device *dev, struct sst_pdata *pdata)
-{
-	struct sst_byt *byt = pdata->dsp;
-
-	dev_dbg(byt->dev, "dsp reset\n");
-	sst_dsp_reset(byt->dsp);
-	sst_byt_drop_all(byt);
-	dev_dbg(byt->dev, "dsp in reset\n");
-
-	dev_dbg(byt->dev, "free all blocks and unload fw\n");
-	sst_fw_unload(byt->fw);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(sst_byt_dsp_suspend_late);
-
-int sst_byt_dsp_boot(struct device *dev, struct sst_pdata *pdata)
-{
-	struct sst_byt *byt = pdata->dsp;
-	int ret;
-
-	dev_dbg(byt->dev, "reload dsp fw\n");
-
-	sst_dsp_reset(byt->dsp);
-
-	ret = sst_fw_reload(byt->fw);
-	if (ret <  0) {
-		dev_err(dev, "error: failed to reload firmware\n");
-		return ret;
-	}
-
-	/* wait for DSP boot completion */
-	byt->boot_complete = false;
-	sst_dsp_boot(byt->dsp);
-	dev_dbg(byt->dev, "dsp booting...\n");
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(sst_byt_dsp_boot);
-
-int sst_byt_dsp_wait_for_ready(struct device *dev, struct sst_pdata *pdata)
-{
-	struct sst_byt *byt = pdata->dsp;
-	int err;
-
-	dev_dbg(byt->dev, "wait for dsp reboot\n");
-
-	err = wait_event_timeout(byt->boot_wait, byt->boot_complete,
-				 msecs_to_jiffies(IPC_BOOT_MSECS));
-	if (err == 0) {
-		dev_err(byt->dev, "ipc: error DSP boot timeout\n");
-		return -EIO;
-	}
-
-	dev_dbg(byt->dev, "dsp rebooted\n");
-	return 0;
-}
-EXPORT_SYMBOL_GPL(sst_byt_dsp_wait_for_ready);
-
 int sst_byt_dsp_init(struct device *dev, struct sst_pdata *pdata)
 {
 	struct sst_byt *byt;
 	struct sst_fw *byt_sst_fw;
-	struct sst_byt_fw_init init;
 	int err;
 
 	dev_dbg(dev, "initialising Byt DSP IPC\n");
@@ -899,7 +856,7 @@
 
 	err = msg_empty_list_init(byt);
 	if (err < 0)
-		return -ENOMEM;
+		return err;
 
 	/* start the IPC message thread */
 	init_kthread_worker(&byt->kworker);
@@ -909,7 +866,7 @@
 	if (IS_ERR(byt->tx_thread)) {
 		err = PTR_ERR(byt->tx_thread);
 		dev_err(byt->dev, "error failed to create message TX task\n");
-		goto err_free_msg;
+		goto thread_err;
 	}
 	init_kthread_work(&byt->kwork, sst_byt_ipc_tx_msgs);
 
@@ -919,7 +876,7 @@
 	byt->dsp = sst_dsp_new(dev, &byt_dev, pdata);
 	if (byt->dsp == NULL) {
 		err = -ENODEV;
-		goto dsp_err;
+		goto thread_err;
 	}
 
 	/* keep the DSP in reset state for base FW loading */
@@ -942,15 +899,6 @@
 		goto boot_err;
 	}
 
-	/* show firmware information */
-	sst_dsp_inbox_read(byt->dsp, &init, sizeof(init));
-	dev_info(byt->dev, "FW version: %02x.%02x.%02x.%02x\n",
-		 init.fw_version.major, init.fw_version.minor,
-		 init.fw_version.build, init.fw_version.type);
-	dev_info(byt->dev, "Build type: %x\n", init.fw_version.type);
-	dev_info(byt->dev, "Build date: %s %s\n",
-		 init.build_info.date, init.build_info.time);
-
 	pdata->dsp = byt;
 	byt->fw = byt_sst_fw;
 
@@ -961,11 +909,8 @@
 	sst_fw_free(byt_sst_fw);
 fw_err:
 	sst_dsp_free(byt->dsp);
-dsp_err:
-	kthread_stop(byt->tx_thread);
-err_free_msg:
+thread_err:
 	kfree(byt->msg);
-
 	return err;
 }
 EXPORT_SYMBOL_GPL(sst_byt_dsp_init);
@@ -977,7 +922,94 @@
 	sst_dsp_reset(byt->dsp);
 	sst_fw_free_all(byt->dsp);
 	sst_dsp_free(byt->dsp);
-	kthread_stop(byt->tx_thread);
 	kfree(byt->msg);
 }
 EXPORT_SYMBOL_GPL(sst_byt_dsp_free);
+
+/* IRQs must be off here */
+int sst_byt_dsp_suspend_noirq(struct device *dev, struct sst_pdata *pdata)
+{
+	struct sst_byt *byt = pdata->dsp;
+
+	dev_dbg(byt->dev, "dsp reset\n");
+	sst_dsp_reset(byt->dsp);
+	sst_byt_drop_all(byt);
+	dev_dbg(byt->dev, "dsp in reset\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_byt_dsp_suspend_noirq);
+
+int sst_byt_d0(struct sst_dsp *sst);
+
+int sst_byt_dsp_suspend_late(struct device *dev, struct sst_pdata *pdata)
+{
+	struct sst_byt *byt = pdata->dsp;
+
+	dev_dbg(byt->dev, "free all blocks and unload fw\n");
+	sst_fw_unload(byt->fw);
+	
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_byt_dsp_suspend_late);
+
+int sst_byt_dsp_boot(struct device *dev, struct sst_pdata *pdata)
+{
+	struct sst_byt *byt = pdata->dsp;
+	int ret;
+
+	ret = sst_byt_d0(byt->dsp);
+	if (ret < 0) {
+		dev_err(dev, "cannot wake SHIM up\n");
+		return ret;
+	}
+
+	dev_dbg(byt->dev, "reload dsp fw\n");
+
+	sst_dsp_reset(byt->dsp);
+
+	ret = sst_fw_reload(byt->fw);
+	if (ret <  0) {
+		dev_err(dev, "error: failed to reload firmware\n");
+		return ret;
+	}
+
+	/* wait for DSP boot completion */
+	byt->boot_complete = false;
+	sst_dsp_boot(byt->dsp);
+	dev_dbg(byt->dev, "dsp booting...\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_byt_dsp_boot);
+
+int sst_byt_dsp_wait_for_ready(struct device *dev, struct sst_pdata *pdata)
+{
+	struct sst_byt *byt = pdata->dsp;
+	int err;
+
+	dev_dbg(byt->dev, "wait for dsp reboot\n");
+
+	err = wait_event_timeout(byt->boot_wait, byt->boot_complete,
+				 msecs_to_jiffies(IPC_BOOT_MSECS));
+	if (err == 0) {
+		dev_err(byt->dev, "ipc: error DSP boot timeout\n");
+		return -EIO;
+	}
+
+	dev_dbg(byt->dev, "dsp rebooted\n");
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_byt_dsp_wait_for_ready);
+
+void sst_byt_register_notifier(struct device *dev, struct sst_pdata *pdata,
+	void (*start)(struct sst_dsp *, void *),
+	void (*stop)(struct sst_dsp *, void *), void *data)
+{
+	struct sst_byt *byt = pdata->dsp;
+
+	byt->notify_start = start;
+	byt->notify_stop = stop;
+	byt->notify_data = data;
+}
+EXPORT_SYMBOL_GPL(sst_byt_register_notifier);
diff -Naur linux-3.19.old/sound/soc/intel/sst-baytrail-ipc.h linux-3.19/sound/soc/intel/sst-baytrail-ipc.h
--- linux-3.19.old/sound/soc/intel/sst-baytrail-ipc.h	2015-03-24 17:38:14.409843613 -0800
+++ linux-3.19/sound/soc/intel/sst-baytrail-ipc.h	2015-03-24 18:19:04.684663440 -0800
@@ -51,10 +51,11 @@
 			  uint32_t buffer_addr, uint32_t buffer_size);
 int sst_byt_stream_commit(struct sst_byt *byt, struct sst_byt_stream *stream);
 int sst_byt_stream_free(struct sst_byt *byt, struct sst_byt_stream *stream);
+int sst_byt_stream_set_offset(struct sst_byt *byt,
+	struct sst_byt_stream *stream, u32 offset);
 
 /* stream ALSA trigger operations */
-int sst_byt_stream_start(struct sst_byt *byt, struct sst_byt_stream *stream,
-			 u32 start_offset);
+int sst_byt_stream_start(struct sst_byt *byt, struct sst_byt_stream *stream);
 int sst_byt_stream_stop(struct sst_byt *byt, struct sst_byt_stream *stream);
 int sst_byt_stream_pause(struct sst_byt *byt, struct sst_byt_stream *stream);
 int sst_byt_stream_resume(struct sst_byt *byt, struct sst_byt_stream *stream);
@@ -66,8 +67,12 @@
 int sst_byt_dsp_init(struct device *dev, struct sst_pdata *pdata);
 void sst_byt_dsp_free(struct device *dev, struct sst_pdata *pdata);
 struct sst_dsp *sst_byt_get_dsp(struct sst_byt *byt);
+int sst_byt_dsp_suspend_noirq(struct device *dev, struct sst_pdata *pdata);
 int sst_byt_dsp_suspend_late(struct device *dev, struct sst_pdata *pdata);
 int sst_byt_dsp_boot(struct device *dev, struct sst_pdata *pdata);
 int sst_byt_dsp_wait_for_ready(struct device *dev, struct sst_pdata *pdata);
+void sst_byt_register_notifier(struct device *dev, struct sst_pdata *pdata,
+	void (*start)(struct sst_dsp *, void *),
+	void (*stop)(struct sst_dsp *, void *), void *data);
 
 #endif
diff -Naur linux-3.19.old/sound/soc/intel/sst-baytrail-pcm.c linux-3.19/sound/soc/intel/sst-baytrail-pcm.c
--- linux-3.19.old/sound/soc/intel/sst-baytrail-pcm.c	2015-03-24 17:38:14.409843613 -0800
+++ linux-3.19/sound/soc/intel/sst-baytrail-pcm.c	2015-03-24 18:19:04.684663440 -0800
@@ -46,10 +46,13 @@
 	struct snd_pcm_substream *substream;
 	struct mutex mutex;
 
-	/* latest DSP DMA hw pointer */
-	u32 hw_ptr;
+	/* DSP suspend context */
+	u32 suspend_offset;
 
 	struct work_struct work;
+
+	bool resume;
+	bool resume_stop;
 };
 
 /* private data for the driver */
@@ -59,9 +62,6 @@
 
 	/* DAI data */
 	struct sst_byt_pcm_data pcm[BYT_PCM_COUNT];
-
-	/* flag indicating is stream context restore needed after suspend */
-	bool restore_stream;
 };
 
 /* this may get called several times by oss emulation */
@@ -154,10 +154,18 @@
 		return ret;
 	}
 
-	sst_byt_stream_start(byt, pcm_data->stream, pcm_data->hw_ptr);
+	/* set stream position to last offset */
+	ret =  sst_byt_stream_set_offset(byt, pcm_data->stream,
+		pcm_data->suspend_offset);
+	if (ret < 0) {
+		dev_err(rtd->dev, "PCM: failed stream offset %d\n", ret);
+		return ret;
+	}
 
+	sst_byt_stream_start(byt, pcm_data->stream);
+	pcm_data->resume = false;
 	dev_dbg(rtd->dev, "stream context restored at offset %d\n",
-		pcm_data->hw_ptr);
+		pcm_data->suspend_offset);
 
 	return 0;
 }
@@ -167,8 +175,12 @@
 	struct sst_byt_pcm_data *pcm_data =
 		container_of(work, struct sst_byt_pcm_data, work);
 
-	if (snd_pcm_running(pcm_data->substream))
+	mutex_lock(&pcm_data->mutex);
+
+	if (pcm_data->stream)
 		sst_byt_pcm_restore_stream_context(pcm_data->substream);
+
+	mutex_unlock(&pcm_data->mutex);
 }
 
 static int sst_byt_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
@@ -183,23 +195,27 @@
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		pcm_data->hw_ptr = 0;
-		sst_byt_stream_start(byt, pcm_data->stream, 0);
+		if (!pcm_data->resume) {
+			if (pcm_data->resume_stop)
+				pcm_data->resume_stop = false;
+			else
+				sst_byt_stream_start(byt, pcm_data->stream);
+		}
 		break;
 	case SNDRV_PCM_TRIGGER_RESUME:
-		if (pdata->restore_stream == true)
-			schedule_work(&pcm_data->work);
-		else
-			sst_byt_stream_resume(byt, pcm_data->stream);
+		schedule_work(&pcm_data->work);
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		sst_byt_stream_resume(byt, pcm_data->stream);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-		sst_byt_stream_stop(byt, pcm_data->stream);
+		if (!pcm_data->resume)
+			sst_byt_stream_stop(byt, pcm_data->stream);
+		else
+			pcm_data->resume_stop = true;
 		break;
 	case SNDRV_PCM_TRIGGER_SUSPEND:
-		pdata->restore_stream = false;
+		pcm_data->resume = true;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		sst_byt_stream_pause(byt, pcm_data->stream);
 		break;
@@ -216,19 +232,13 @@
 	struct snd_pcm_substream *substream = pcm_data->substream;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct sst_byt_priv_data *pdata =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct sst_byt *byt = pdata->byt;
-	u32 pos, hw_pos;
+	u32 pos;
 
-	hw_pos = sst_byt_get_dsp_position(byt, pcm_data->stream,
-					  snd_pcm_lib_buffer_bytes(substream));
-	pcm_data->hw_ptr = hw_pos;
 	pos = frames_to_bytes(runtime,
 			      (runtime->control->appl_ptr %
 			       runtime->buffer_size));
 
-	dev_dbg(rtd->dev, "PCM: App/DMA pointer %u/%u bytes\n", pos, hw_pos);
+	dev_dbg(rtd->dev, "PCM: App pointer %d bytes\n", pos);
 
 	snd_pcm_period_elapsed(substream);
 	return pos;
@@ -241,10 +251,22 @@
 	struct sst_byt_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
 	struct sst_byt_pcm_data *pcm_data = &pdata->pcm[substream->stream];
+	struct sst_byt *byt = pdata->byt;
+	snd_pcm_uframes_t offset;
+	int pos;
 
-	dev_dbg(rtd->dev, "PCM: DMA pointer %u bytes\n", pcm_data->hw_ptr);
-
-	return bytes_to_frames(runtime, pcm_data->hw_ptr);
+	/* IPC delays can cause this to be called after close */
+	if (pcm_data->stream == NULL)
+		return 0;
+
+	pos = sst_byt_get_dsp_position(byt, pcm_data->stream,
+				       snd_pcm_lib_buffer_bytes(substream));
+	offset = bytes_to_frames(runtime, pos);
+	pcm_data->suspend_offset = pos;
+
+	dev_dbg(rtd->dev, "PCM: DMA pointer %zu bytes\n",
+		frames_to_bytes(runtime, (u32)offset));
+	return offset;
 }
 
 static int sst_byt_pcm_open(struct snd_pcm_substream *substream)
@@ -254,8 +276,12 @@
 		snd_soc_platform_get_drvdata(rtd->platform);
 	struct sst_byt_pcm_data *pcm_data = &pdata->pcm[substream->stream];
 	struct sst_byt *byt = pdata->byt;
+	int stream_id;
 
 	dev_dbg(rtd->dev, "PCM: open\n");
+	stream_id = substream->stream + 1;
+	if (pcm_data->stream)
+		return -EINVAL;
 
 	mutex_lock(&pcm_data->mutex);
 
@@ -263,7 +289,7 @@
 
 	snd_soc_set_runtime_hwparams(substream, &sst_byt_pcm_hardware);
 
-	pcm_data->stream = sst_byt_stream_new(byt, substream->stream + 1,
+	pcm_data->stream = sst_byt_stream_new(byt, stream_id,
 					      byt_notify_pointer, pcm_data);
 	if (pcm_data->stream == NULL) {
 		dev_err(rtd->dev, "failed to create stream\n");
@@ -286,7 +312,6 @@
 
 	dev_dbg(rtd->dev, "PCM: close\n");
 
-	cancel_work_sync(&pcm_data->work);
 	mutex_lock(&pcm_data->mutex);
 	ret = sst_byt_stream_free(byt, pcm_data->stream);
 	if (ret < 0) {
@@ -329,16 +354,18 @@
 {
 	struct snd_pcm *pcm = rtd->pcm;
 	size_t size;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct sst_pdata *pdata = dev_get_platdata(platform->dev);
 	int ret = 0;
 
+	ret = dma_coerce_mask_and_coherent(rtd->card->dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
 	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream ||
 	    pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
 		size = sst_byt_pcm_hardware.buffer_bytes_max;
 		ret = snd_pcm_lib_preallocate_pages_for_all(pcm,
 							    SNDRV_DMA_TYPE_DEV,
-							    pdata->dma_dev,
+							    rtd->card->dev,
 							    size, size);
 		if (ret) {
 			dev_err(rtd->dev, "dma buffer allocation failed %d\n",
@@ -352,7 +379,7 @@
 
 static struct snd_soc_dai_driver byt_dais[] = {
 	{
-		.name  = "Baytrail PCM",
+		.name  = "Front-cpu-dai",
 		.playback = {
 			.stream_name = "System Playback",
 			.channels_min = 2,
@@ -369,6 +396,16 @@
 			.formats = SNDRV_PCM_FMTBIT_S16_LE,
 		},
 	},
+	{
+		.name  = "Mic1-cpu-dai",
+		.capture = {
+			.stream_name = "Analog Capture",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_48000,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,
+		},
+	},
 };
 
 static int sst_byt_pcm_probe(struct snd_soc_platform *platform)
@@ -385,7 +422,7 @@
 	priv_data->byt = plat_data->dsp;
 	snd_soc_platform_set_drvdata(platform, priv_data);
 
-	for (i = 0; i < BYT_PCM_COUNT; i++) {
+	for (i = 0; i < ARRAY_SIZE(byt_dais); i++) {
 		mutex_init(&priv_data->pcm[i].mutex);
 		INIT_WORK(&priv_data->pcm[i].work, sst_byt_pcm_work);
 	}
@@ -410,11 +447,65 @@
 	.name		= "byt-dai",
 };
 
+static int sst_byt_pcm_dev_probe(struct platform_device *pdev)
+{
+	struct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);
+	int ret;
+
+	ret = sst_byt_dsp_init(&pdev->dev, sst_pdata);
+	if (ret < 0)
+		return -ENODEV;
+
+	ret = snd_soc_register_platform(&pdev->dev, &byt_soc_platform);
+	if (ret < 0)
+		goto err_plat;
+
+	ret = snd_soc_register_component(&pdev->dev, &byt_dai_component,
+					 byt_dais, ARRAY_SIZE(byt_dais));
+	if (ret < 0)
+		goto err_comp;
+
+	return 0;
+
+err_comp:
+	snd_soc_unregister_platform(&pdev->dev);
+err_plat:
+	sst_byt_dsp_free(&pdev->dev, sst_pdata);
+	return ret;
+}
+
+static int sst_byt_pcm_dev_remove(struct platform_device *pdev)
+{
+	struct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);
+
+	snd_soc_unregister_platform(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
+	sst_byt_dsp_free(&pdev->dev, sst_pdata);
+
+	return 0;
+}
+
 #ifdef CONFIG_PM
+static int sst_byt_pcm_dev_suspend_noirq(struct device *dev)
+{
+	struct sst_pdata *sst_pdata = dev_get_platdata(dev);
+	int ret;
+
+	dev_dbg(dev, "suspending noirq\n");
+
+	/* at this point all streams will be stopped and context saved */
+	ret = sst_byt_dsp_suspend_noirq(dev, sst_pdata);
+	if (ret < 0) {
+		dev_err(dev, "failed to suspend %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
 static int sst_byt_pcm_dev_suspend_late(struct device *dev)
 {
 	struct sst_pdata *sst_pdata = dev_get_platdata(dev);
-	struct sst_byt_priv_data *priv_data = dev_get_drvdata(dev);
 	int ret;
 
 	dev_dbg(dev, "suspending late\n");
@@ -425,30 +516,34 @@
 		return ret;
 	}
 
-	priv_data->restore_stream = true;
-
 	return ret;
 }
 
 static int sst_byt_pcm_dev_resume_early(struct device *dev)
 {
 	struct sst_pdata *sst_pdata = dev_get_platdata(dev);
-	int ret;
 
 	dev_dbg(dev, "resume early\n");
 
 	/* load fw and boot DSP */
-	ret = sst_byt_dsp_boot(dev, sst_pdata);
-	if (ret)
-		return ret;
+	return sst_byt_dsp_boot(dev, sst_pdata);
+}
+
+static int sst_byt_pcm_dev_resume(struct device *dev)
+{
+	struct sst_pdata *sst_pdata = dev_get_platdata(dev);
+
+	dev_dbg(dev, "resume\n");
 
 	/* wait for FW to finish booting */
 	return sst_byt_dsp_wait_for_ready(dev, sst_pdata);
 }
 
 static const struct dev_pm_ops sst_byt_pm_ops = {
+	.suspend_noirq = sst_byt_pcm_dev_suspend_noirq,
 	.suspend_late = sst_byt_pcm_dev_suspend_late,
 	.resume_early = sst_byt_pcm_dev_resume_early,
+	.resume = sst_byt_pcm_dev_resume,
 };
 
 #define SST_BYT_PM_OPS	(&sst_byt_pm_ops)
@@ -456,47 +551,10 @@
 #define SST_BYT_PM_OPS	NULL
 #endif
 
-static int sst_byt_pcm_dev_probe(struct platform_device *pdev)
-{
-	struct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);
-	int ret;
-
-	ret = sst_byt_dsp_init(&pdev->dev, sst_pdata);
-	if (ret < 0)
-		return -ENODEV;
-
-	ret = snd_soc_register_platform(&pdev->dev, &byt_soc_platform);
-	if (ret < 0)
-		goto err_plat;
-
-	ret = snd_soc_register_component(&pdev->dev, &byt_dai_component,
-					 byt_dais, ARRAY_SIZE(byt_dais));
-	if (ret < 0)
-		goto err_comp;
-
-	return 0;
-
-err_comp:
-	snd_soc_unregister_platform(&pdev->dev);
-err_plat:
-	sst_byt_dsp_free(&pdev->dev, sst_pdata);
-	return ret;
-}
-
-static int sst_byt_pcm_dev_remove(struct platform_device *pdev)
-{
-	struct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);
-
-	snd_soc_unregister_platform(&pdev->dev);
-	snd_soc_unregister_component(&pdev->dev);
-	sst_byt_dsp_free(&pdev->dev, sst_pdata);
-
-	return 0;
-}
-
 static struct platform_driver sst_byt_pcm_driver = {
 	.driver = {
 		.name = "baytrail-pcm-audio",
+		.owner = THIS_MODULE,
 		.pm = SST_BYT_PM_OPS,
 	},
 
diff -Naur linux-3.19.old/sound/soc/intel/sst-debugfs.c linux-3.19/sound/soc/intel/sst-debugfs.c
--- linux-3.19.old/sound/soc/intel/sst-debugfs.c	1969-12-31 14:00:00.000000000 -1000
+++ linux-3.19/sound/soc/intel/sst-debugfs.c	2015-03-24 18:19:04.687996773 -0800
@@ -0,0 +1,170 @@
+/*
+ * Intel Smart Sound Technology (SST) debugfs support
+ *
+ * Copyright (C) 2014, Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+
+static struct dentry *rootdir;
+
+struct sst_dfsentry {
+	struct dentry *dfsentry;
+	size_t size;
+	void *buf;
+};
+
+static int sst_dfsentry_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+
+	return 0;
+}
+
+static ssize_t sst_dfsentry_read(struct file *file, char __user *buffer,
+				 size_t count, loff_t *ppos)
+{
+	struct sst_dfsentry *dfse = file->private_data;
+	int i, size;
+	u32 *buf;
+
+	pr_debug("%s: pbuf: %p, *ppos: 0x%llx", __func__, buffer, *ppos);
+
+	size = dfse->size;
+
+	if (*ppos >= size)
+		return 0;
+	if (*ppos + count > size)
+		count = size - *ppos;
+
+	size = (count + 3) & (~3);
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf) {
+		pr_err(" %s: kzalloc failed, aborting\n", __func__);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < size / sizeof(*buf); i++)
+		buf[i] = *(u32 *)(dfse->buf + *ppos + i * sizeof(*buf));
+
+	if (copy_to_user(buffer, buf, count))
+		return 0;
+	kfree(buf);
+
+	*ppos += count;
+
+	pr_debug("%s: *ppos: 0x%llx, count: %zu", __func__, *ppos, count);
+
+	return count;
+}
+
+static ssize_t sst_dfsentry_write(struct file *file, const char __user *buffer,
+				  size_t count, loff_t *ppos)
+{
+	struct sst_dfsentry *dfse = file->private_data;
+	int i, size;
+	u32 *buf;
+
+	pr_debug("%s: pbuf: %p, *ppos: 0x%llx", __func__, buffer, *ppos);
+
+	size = dfse->size;
+
+	if (*ppos >= size)
+		return 0;
+	if (*ppos + count > size)
+		count = size - *ppos;
+
+	size = (count + 3) & (~3);
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf) {
+		pr_err(" %s: kzalloc failed, aborting\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(buf, buffer, count))
+		return 0;
+
+	for (i = 0; i < size / sizeof(*buf); i++)
+		*(u32 *)(dfse->buf + *ppos + i * sizeof(*buf)) = buf[i];
+
+	kfree(buf);
+	*ppos += count;
+
+	pr_debug("%s: *ppos: 0x%llx, count: %zu", __func__, *ppos, count);
+
+	return count;
+}
+
+static const struct file_operations sst_dfs_fops = {
+	.owner = THIS_MODULE,
+	.open = sst_dfsentry_open,
+	.read = sst_dfsentry_read,
+	.write = sst_dfsentry_write,
+};
+
+int sst_debugfs_add_mmio_entry(const char *filename, void *buf,
+			       size_t size, void **ctx)
+{
+	struct sst_dfsentry *dfse;
+
+	dfse = kzalloc(sizeof(*dfse), GFP_KERNEL);
+	if (!dfse) {
+		pr_err("%s: cannot create debugfs entry.\n", __func__);
+		return -ENOMEM;
+	}
+
+	dfse->buf = buf;
+	dfse->size = size;
+	dfse->dfsentry = debugfs_create_file(
+				filename, 0644, rootdir, dfse, &sst_dfs_fops);
+	if (!dfse->dfsentry) {
+		pr_err("%s: cannot create debugfs entry.\n", __func__);
+		return -ENODEV;
+	}
+	*ctx = dfse;
+
+	return 0;
+}
+
+void sst_debugfs_remove_mmio_entry(void *ctx)
+{
+	struct sst_dfsentry *dfse = (struct sst_dfsentry *)ctx;
+
+	debugfs_remove(dfse->dfsentry);
+	kfree(dfse);
+}
+
+int sst_debugfs_init(const char *dirname)
+{
+	if (rootdir) {
+		pr_err("%s: debugfs rootdir already initiated.\n", __func__);
+		return -EEXIST;
+	}
+	rootdir = debugfs_create_dir(dirname, NULL);
+
+	return 0;
+}
+
+void sst_debugfs_exit(void)
+{
+	debugfs_remove_recursive(rootdir);
+}
+
+void sst_debugfs_get_root(struct dentry *root)
+{
+	if (root) {
+		*root = *rootdir;
+	}
+}
+
diff -Naur linux-3.19.old/sound/soc/intel/sst-debugfs.h linux-3.19/sound/soc/intel/sst-debugfs.h
--- linux-3.19.old/sound/soc/intel/sst-debugfs.h	1969-12-31 14:00:00.000000000 -1000
+++ linux-3.19/sound/soc/intel/sst-debugfs.h	2015-03-24 18:19:04.687996773 -0800
@@ -0,0 +1,34 @@
+/*
+ * Intel Smart Sound Technology (SST) debugfs support
+ *
+ * Copyright (C) 2014, Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SOUND_SOC_SST_DEBUGFS_H
+#define __SOUND_SOC_SST_DEBUGFS_H
+#define DEBUG
+#ifdef DEBUG
+int sst_debugfs_add_mmio_entry(const char *filename,
+			       void *buf, size_t size, void **ctx);
+void sst_debugfs_remove_mmio_entry(void *ctx);
+int sst_debugfs_init(const char *dirname);
+void sst_debugfs_exit(void);
+void sst_debugfs_get_root(struct dentry *root);
+#else
+#define sst_debugfs_add_mmio_entry(a, b, c, d)
+#define sst_debugfs_remove_mmio_entry(a)
+#define sst_debugfs_init(a)
+#define sst_debugfs_exit()
+#define sst_debugfs_get_root(a)
+#endif
+
+#endif
diff -Naur linux-3.19.old/sound/soc/intel/sst-dsp.h linux-3.19/sound/soc/intel/sst-dsp.h
--- linux-3.19.old/sound/soc/intel/sst-dsp.h	2015-03-24 17:38:14.416510280 -0800
+++ linux-3.19/sound/soc/intel/sst-dsp.h	2015-03-24 18:19:04.687996773 -0800
@@ -161,14 +161,12 @@
 /* VDRTCTL0 */
 #define SST_VDRTCL0_D3PGD		(1 << 0)
 #define SST_VDRTCL0_D3SRAMPGD		(1 << 1)
-#define SST_VDRTCL0_DSRAMPGE_SHIFT	12
-#define SST_VDRTCL0_DSRAMPGE_MASK	(0xfffff << SST_VDRTCL0_DSRAMPGE_SHIFT)
-#define SST_VDRTCL0_ISRAMPGE_SHIFT	2
+#define SST_VDRTCL0_DSRAMPGE_SHIFT	16
+#define SST_VDRTCL0_DSRAMPGE_MASK	(0xffff << SST_VDRTCL0_DSRAMPGE_SHIFT)
+#define SST_VDRTCL0_ISRAMPGE_SHIFT	6
 #define SST_VDRTCL0_ISRAMPGE_MASK	(0x3ff << SST_VDRTCL0_ISRAMPGE_SHIFT)
 
 /* VDRTCTL2 */
-#define SST_VDRTCL2_DCLCGE		(1 << 1)
-#define SST_VDRTCL2_DTCGE		(1 << 10)
 #define SST_VDRTCL2_APLLSE_MASK		(1 << 31)
 
 /* PMCS */
diff -Naur linux-3.19.old/sound/soc/intel/sst-dsp-priv.h linux-3.19/sound/soc/intel/sst-dsp-priv.h
--- linux-3.19.old/sound/soc/intel/sst-dsp-priv.h	2015-03-24 17:38:14.409843613 -0800
+++ linux-3.19/sound/soc/intel/sst-dsp-priv.h	2015-03-24 18:19:04.687996773 -0800
@@ -286,6 +286,10 @@
 	/* DMA FW loading */
 	struct sst_dma *dma;
 	bool fw_use_dma;
+
+	/* debugfs support */
+	void *debugfs_bar0;	/* DRAM and IRAM */
+	void *debugfs_bar1;	/* configuration space */
 };
 
 /* Size optimised DRAM/IRAM memcpy */
diff -Naur linux-3.19.old/sound/soc/intel/sst-firmware.c linux-3.19/sound/soc/intel/sst-firmware.c
--- linux-3.19.old/sound/soc/intel/sst-firmware.c	2015-03-24 17:38:14.416510280 -0800
+++ linux-3.19/sound/soc/intel/sst-firmware.c	2015-03-24 18:19:04.687996773 -0800
@@ -13,7 +13,7 @@
  * GNU General Public License for more details.
  *
  */
-
+#define DEBUG
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
@@ -50,10 +50,13 @@
 	struct dma_chan *ch;
 };
 
-static inline void sst_memcpy32(volatile void __iomem *dest, void *src, u32 bytes)
+static void sst_memcpy32(volatile void __iomem *dest, void *src, u32 bytes)
 {
-	/* __iowrite32_copy use 32bit size values so divide by 4 */
-	__iowrite32_copy((void *)dest, src, bytes/4);
+	u32 i;
+
+	/* copy one 32 bit word at a time as 64 bit access is not supported */
+	for (i = 0; i < bytes; i += 4)
+		memcpy_toio(dest + i, src + i, 4);
 }
 
 static void sst_dma_transfer_complete(void *arg)
@@ -169,7 +172,7 @@
 	return ret;
 }
 
-static struct dw_dma_platform_data dw_pdata = {
+struct dw_dma_platform_data dw_pdata = {
 	.is_private = 1,
 	.chan_allocation_order = CHAN_ALLOCATION_ASCENDING,
 	.chan_priority = CHAN_PRIORITY_ASCENDING,
@@ -609,6 +612,7 @@
 	}
 
 	list_splice(&tmp, &dsp->used_block_list);
+
 	return 0;
 }
 
@@ -706,7 +710,6 @@
 	struct list_head *block_list)
 {
 	struct sst_mem_block *block, *tmp;
-	struct sst_block_allocator ba_tmp = *ba;
 	u32 end = ba->offset + ba->size, block_end;
 	int err;
 
@@ -731,9 +734,9 @@
 		if (ba->offset >= block->offset && ba->offset < block_end) {
 
 			/* align ba to block boundary */
-			ba_tmp.size -= block_end - ba->offset;
-			ba_tmp.offset = block_end;
-			err = block_alloc_contiguous(dsp, &ba_tmp, block_list);
+			ba->size -= block_end - ba->offset;
+			ba->offset = block_end;
+			err = block_alloc_contiguous(dsp, ba, block_list);
 			if (err < 0)
 				return -ENOMEM;
 
@@ -764,17 +767,12 @@
 		/* does block span more than 1 section */
 		if (ba->offset >= block->offset && ba->offset < block_end) {
 
-			/* add block */
-			list_move(&block->list, &dsp->used_block_list);
-			list_add(&block->module_list, block_list);
 			/* align ba to block boundary */
-			ba_tmp.size -= block_end - ba->offset;
-			ba_tmp.offset = block_end;
+			ba->offset = block->offset;
 
-			err = block_alloc_contiguous(dsp, &ba_tmp, block_list);
+			err = block_alloc_contiguous(dsp, ba, block_list);
 			if (err < 0)
 				return -ENOMEM;
-
 			return 0;
 		}
 	}
@@ -831,7 +829,7 @@
 			module->size);
 
 	mutex_unlock(&dsp->mutex);
-	return ret;
+	return 0;
 
 err:
 	block_list_remove(dsp, &module->block_list);
@@ -1125,7 +1123,6 @@
 	ret = block_list_prepare(dsp, &dsp->scratch_block_list);
 	if (ret < 0) {
 		dev_err(dsp->dev, "error: scratch block prepare failed\n");
-		mutex_unlock(&dsp->mutex);
 		return ret;
 	}
 
diff -Naur linux-3.19.old/sound/soc/intel/sst-haswell-dsp.c linux-3.19/sound/soc/intel/sst-haswell-dsp.c
--- linux-3.19.old/sound/soc/intel/sst-haswell-dsp.c	2015-03-24 17:38:14.416510280 -0800
+++ linux-3.19/sound/soc/intel/sst-haswell-dsp.c	2015-03-24 18:19:04.687996773 -0800
@@ -31,6 +31,7 @@
 #include "sst-dsp.h"
 #include "sst-dsp-priv.h"
 #include "sst-haswell-ipc.h"
+#include "sst-debugfs.h"
 
 #include <trace/events/hswadsp.h>
 
@@ -250,12 +251,6 @@
 static void hsw_set_dsp_D3(struct sst_dsp *sst)
 {
 	u32 val;
-	u32 reg;
-
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg &= ~(SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE);
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
 
 	/* enable power gating and switch off DRAM & IRAM blocks */
 	val = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
@@ -269,23 +264,10 @@
 	val |= SST_VDRTCL2_APLLSE_MASK;
 	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
 
-	/* disable MCLK(clkctl.smos = 0) */
-	sst_dsp_shim_update_bits_unlocked(sst, SST_CLKCTL,
-		SST_CLKCTL_MASK, 0);
-
-	/* Set D3 state, delay 50 us */
+	/* Set D3 state */
 	val = readl(sst->addr.pci_cfg + SST_PMCS);
 	val |= SST_PMCS_PS_MASK;
 	writel(val, sst->addr.pci_cfg + SST_PMCS);
-	udelay(50);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg |= SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
 }
 
 static void hsw_reset(struct sst_dsp *sst)
@@ -308,16 +290,6 @@
 	int tries = 10;
 	u32 reg;
 
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg &= ~(SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE);
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	/* Disable D3PG (VDRTCTL0.D3PGD = 1) */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
-	reg |= SST_VDRTCL0_D3PGD;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL0);
-
 	/* Set D0 state */
 	reg = readl(sst->addr.pci_cfg + SST_PMCS);
 	reg &= ~SST_PMCS_PS_MASK;
@@ -335,6 +307,17 @@
 	return -ENODEV;
 
 finish:
+	hsw_reset(sst);
+
+	/* switch on audio PLL */
+	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
+	reg &= ~SST_VDRTCL2_APLLSE_MASK;
+	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
+
+	/* set default power gating control, enable power gating control for all blocks. that is,
+	can't be accessed, please enable each block before accessing. */
+	writel(0xffffffff, sst->addr.pci_cfg + SST_VDRTCTL0);
+
 	/* select SSP1 19.2MHz base clock, SSP clock 0, turn off Low Power Clock */
 	sst_dsp_shim_update_bits_unlocked(sst, SST_CSR,
 		SST_CSR_S1IOCS | SST_CSR_SBCS1 | SST_CSR_LPCS, 0x0);
@@ -349,28 +332,6 @@
 		SST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0,
 		SST_CLKCTL_MASK | SST_CLKCTL_DCPLCG | SST_CLKCTL_SCOE0);
 
-	/* Stall and reset core, set CSR */
-	hsw_reset(sst);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg |= SST_VDRTCL2_DCLCGE | SST_VDRTCL2_DTCGE;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
-	/* switch on audio PLL */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	reg &= ~SST_VDRTCL2_APLLSE_MASK;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	/* set default power gating control, enable power gating control for all blocks. that is,
-	can't be accessed, please enable each block before accessing. */
-	reg = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
-	reg |= SST_VDRTCL0_DSRAMPGE_MASK | SST_VDRTCL0_ISRAMPGE_MASK;
-	writel(reg, sst->addr.pci_cfg + SST_VDRTCTL0);
-
-
 	/* disable DMA finish function for SSP0 & SSP1 */
 	sst_dsp_shim_update_bits_unlocked(sst, SST_CSR2, SST_CSR2_SDFD_SSP1,
 		SST_CSR2_SDFD_SSP1);
@@ -392,6 +353,9 @@
 	sst_dsp_shim_write(sst, 0x80, 0x6);
 	sst_dsp_shim_write(sst, 0xe0, 0x300a);
 
+	/* disable all clock gating */
+	writel(0x0, sst->addr.pci_cfg + SST_VDRTCTL2);
+
 	return 0;
 }
 
@@ -478,6 +442,13 @@
 
 	/* SST Shim */
 	sst->addr.shim = sst->addr.lpe + sst->addr.shim_offset;
+
+	sst_debugfs_init("intel_adsp");
+	sst_debugfs_add_mmio_entry("mem", sst->addr.lpe, pdata->lpe_size,
+				   &sst->debugfs_bar0);
+	sst_debugfs_add_mmio_entry("cfg", sst->addr.pci_cfg, pdata->pcicfg_size,
+				   &sst->debugfs_bar1);
+
 	return 0;
 }
 
@@ -543,11 +514,6 @@
 	dev_dbg(block->dsp->dev, " enabled block %d:%d at offset 0x%x\n",
 		block->type, block->index, block->offset);
 
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val &= ~SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
 	val = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
 	bit = hsw_block_get_bit(block);
 	writel(val & ~bit, sst->addr.pci_cfg + SST_VDRTCTL0);
@@ -555,13 +521,6 @@
 	/* wait 18 DSP clock ticks */
 	udelay(10);
 
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val |= SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
 	/*add a dummy read before the SRAM block is written, otherwise the writing may miss bytes sometimes.*/
 	sst_mem_block_dummy_read(block);
 	return 0;
@@ -579,26 +538,10 @@
 	dev_dbg(block->dsp->dev, " disabled block %d:%d at offset 0x%x\n",
 		block->type, block->index, block->offset);
 
-	/* Disable core clock gating (VDRTCTL2.DCLCGE = 0) */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val &= ~SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-
 	val = readl(sst->addr.pci_cfg + SST_VDRTCTL0);
 	bit = hsw_block_get_bit(block);
 	writel(val | bit, sst->addr.pci_cfg + SST_VDRTCTL0);
 
-	/* wait 18 DSP clock ticks */
-	udelay(10);
-
-	/* Enable core clock gating (VDRTCTL2.DCLCGE = 1), delay 50 us */
-	val = readl(sst->addr.pci_cfg + SST_VDRTCTL2);
-	val |= SST_VDRTCL2_DCLCGE;
-	writel(val, sst->addr.pci_cfg + SST_VDRTCTL2);
-
-	udelay(50);
-
 	return 0;
 }
 
@@ -678,6 +621,9 @@
 
 static void hsw_free(struct sst_dsp *sst)
 {
+	sst_debugfs_remove_mmio_entry(sst->debugfs_bar0);
+	sst_debugfs_remove_mmio_entry(sst->debugfs_bar1);
+	sst_debugfs_exit();
 	sst_mem_block_unregister_all(sst);
 	iounmap(sst->addr.lpe);
 	iounmap(sst->addr.pci_cfg);
diff -Naur linux-3.19.old/sound/soc/intel/sst-haswell-ipc.c linux-3.19/sound/soc/intel/sst-haswell-ipc.c
--- linux-3.19.old/sound/soc/intel/sst-haswell-ipc.c	2015-03-24 17:38:14.423176947 -0800
+++ linux-3.19/sound/soc/intel/sst-haswell-ipc.c	2015-03-24 18:53:19.974724695 -0800
@@ -31,6 +31,10 @@
 #include <linux/dma-mapping.h>
 #include <linux/debugfs.h>
 #include <linux/pm_runtime.h>
+//#include <asm/page.h>
+//#include <asm/pgtable.h>
+#include <sound/memalloc.h>
+
 
 #include "sst-haswell-ipc.h"
 #include "sst-dsp.h"
@@ -94,6 +98,8 @@
 /* Mailbox */
 #define IPC_MAX_MAILBOX_BYTES	256
 
+#define INVALID_STREAM_HW_ID	0xffffffff
+
 /* Global Message - Types and Replies */
 enum ipc_glb_type {
 	IPC_GLB_GET_FW_VERSION = 0,		/* Retrieves firmware version */
@@ -177,6 +183,13 @@
 	IPC_DEBUG_MAX_DEBUG_LOG
 };
 
+enum dx_state {
+	d0_state = 0,
+	idle_state = 1,
+	d3_state = 3,
+	unknown_state,
+};
+
 /* Firmware Ready */
 struct sst_hsw_ipc_fw_ready {
 	u32 inbox_offset;
@@ -293,6 +306,12 @@
 	struct sst_hsw_ipc_dx_reply dx;
 	void *dx_context;
 	dma_addr_t dx_context_paddr;
+	int dx_state;
+	int cnt_state_idle;
+	int cnt_state_d0;
+	int cnt_state_d3;
+	int cnt_state_s0;
+	int cnt_state_s3;
 
 	/* boot */
 	wait_queue_head_t boot_wait;
@@ -454,6 +473,13 @@
 	unsigned long flags;
 	u32 ipcx;
 
+	/* This delay is to avoid message timeout error during repeated arecord.
+	 * Binary search on the delay value shows that timeouts start to happen
+	 * when delay is at ~70us. At 100us delay, tested 500 arecord without
+	 * timeout error.
+	 */
+	udelay(100);
+
 	spin_lock_irqsave(&hsw->dsp->spinlock, flags);
 
 	if (list_empty(&hsw->tx_list) || hsw->pending) {
@@ -658,6 +684,26 @@
 	sst_dsp_shim_update_bits(hsw->dsp, SST_IMRX, SST_IMRX_BUSY, 0);
 }
 
+static void hsw_log_notification_work(struct work_struct *work)
+{
+	struct sst_hsw_log_stream *stream = container_of(work,
+	struct sst_hsw_log_stream, notify_work);
+	struct sst_hsw *hsw = stream->hsw;
+	u32 header;
+	int ret;
+
+	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
+	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_NOTIFY_LOG_DUMP);
+	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
+	ret = ipc_tx_message_nowait(hsw, header,
+		&stream->curr_pos, sizeof(stream->curr_pos));
+	if (ret < 0)
+		dev_err(hsw->dev,
+			"ipc: send ipc to notify fw log position failed\n");
+
+	wake_up_interruptible(&stream->readers_wait_q);
+}
+
 static struct ipc_message *reply_find_msg(struct sst_hsw *hsw, u32 header)
 {
 	struct ipc_message *msg;
@@ -1042,9 +1088,14 @@
 
 	trace_ipc_request("set stream volume", stream->reply.stream_hw_id);
 
-	if (channel >= 2 && channel != SST_HSW_CHANNELS_ALL)
+	if (channel > 1)
 		return -EINVAL;
 
+	if (stream->mute[channel]) {
+		stream->mute_volume[channel] = volume;
+		return 0;
+	}
+
 	header = IPC_GLB_TYPE(IPC_GLB_STREAM_MESSAGE) |
 		IPC_STR_TYPE(IPC_STR_STAGE_MESSAGE);
 	header |= (stream->reply.stream_hw_id << IPC_STR_ID_SHIFT);
@@ -1052,28 +1103,9 @@
 	header |= (stage_id << IPC_STG_ID_SHIFT);
 
 	req = &stream->vol_req;
+	req->channel = channel;
 	req->target_volume = volume;
 
-	/* set both at same time ? */
-	if (channel == SST_HSW_CHANNELS_ALL) {
-		if (hsw->mute[0] && hsw->mute[1]) {
-			hsw->mute_volume[0] = hsw->mute_volume[1] = volume;
-			return 0;
-		} else if (hsw->mute[0])
-			req->channel = 1;
-		else if (hsw->mute[1])
-			req->channel = 0;
-		else
-			req->channel = SST_HSW_CHANNELS_ALL;
-	} else {
-		/* set only 1 channel */
-		if (hsw->mute[channel]) {
-			hsw->mute_volume[channel] = volume;
-			return 0;
-		}
-		req->channel = channel;
-	}
-
 	ret = ipc_tx_message_wait(hsw, header, req, sizeof(*req), NULL, 0);
 	if (ret < 0) {
 		dev_err(hsw->dev, "error: set stream volume failed\n");
@@ -1152,11 +1184,8 @@
 
 	trace_ipc_request("set mixer volume", volume);
 
-	if (channel >= 2 && channel != SST_HSW_CHANNELS_ALL)
-		return -EINVAL;
-
 	/* set both at same time ? */
-	if (channel == SST_HSW_CHANNELS_ALL) {
+	if (channel == 2) {
 		if (hsw->mute[0] && hsw->mute[1]) {
 			hsw->mute_volume[0] = hsw->mute_volume[1] = volume;
 			return 0;
@@ -1165,7 +1194,7 @@
 		else if (hsw->mute[1])
 			req.channel = 0;
 		else
-			req.channel = SST_HSW_CHANNELS_ALL;
+			req.channel = 0xffffffff;
 	} else {
 		/* set only 1 channel */
 		if (hsw->mute[channel]) {
@@ -1208,6 +1237,7 @@
 		return NULL;
 
 	spin_lock_irqsave(&sst->spinlock, flags);
+	stream->reply.stream_hw_id = INVALID_STREAM_HW_ID;
 	list_add(&stream->node, &hsw->stream_list);
 	stream->notify_position = notify_position;
 	stream->pdata = data;
@@ -1228,11 +1258,6 @@
 	struct sst_dsp *sst = hsw->dsp;
 	unsigned long flags;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to free, ignore it.\n");
-		return 0;
-	}
-
 	/* dont free DSP streams that are not commited */
 	if (!stream->commited)
 		goto out;
@@ -1420,16 +1445,6 @@
 	u32 header;
 	int ret;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to commit, ignore it.\n");
-		return 0;
-	}
-
-	if (stream->commited) {
-		dev_warn(hsw->dev, "warning: stream is already committed, ignore it.\n");
-		return 0;
-	}
-
 	trace_ipc_request("stream alloc", stream->host_id);
 
 	header = IPC_GLB_TYPE(IPC_GLB_ALLOCATE_STREAM);
@@ -1534,11 +1549,6 @@
 {
 	int ret;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to pause, ignore it.\n");
-		return 0;
-	}
-
 	trace_ipc_request("stream pause", stream->reply.stream_hw_id);
 
 	ret = sst_hsw_stream_operations(hsw, IPC_STR_PAUSE,
@@ -1555,11 +1565,6 @@
 {
 	int ret;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to resume, ignore it.\n");
-		return 0;
-	}
-
 	trace_ipc_request("stream resume", stream->reply.stream_hw_id);
 
 	ret = sst_hsw_stream_operations(hsw, IPC_STR_RESUME,
@@ -1575,11 +1580,6 @@
 {
 	int ret, tries = 10;
 
-	if (!stream) {
-		dev_warn(hsw->dev, "warning: stream is NULL, no stream to reset, ignore it.\n");
-		return 0;
-	}
-
 	/* dont reset streams that are not commited */
 	if (!stream->commited)
 		return 0;
@@ -1771,7 +1771,7 @@
 		dev_err(hsw->dev,
 			"error: number of FW context regions greater than %d\n",
 			SST_HSW_MAX_DX_REGIONS);
-		memset(&hsw->dx, 0, sizeof(hsw->dx));
+		memset(&hsw->dx, sizeof(hsw->dx), 0);
 		return -EINVAL;
 	}
 
@@ -1801,7 +1801,7 @@
 			if (ret < 0) {
 				dev_err(hsw->dev,
 					"error: FW context dump failed\n");
-				memset(&hsw->dx, 0, sizeof(hsw->dx));
+				memset(&hsw->dx, sizeof(hsw->dx), 0);
 				goto out;
 			}
 		}
@@ -1841,6 +1841,384 @@
 	return 0;
 }
 
+static int fw_log_open_data(struct inode *inode, struct file *file)
+{
+	struct sst_hsw_log_stream *log_stream = inode->i_private;
+	struct sst_hsw_ipc_debug_log_enable_req req;
+	u32 header;
+	int ret;
+
+	pm_runtime_get(log_stream->hsw->dev);
+	file->private_data = inode->i_private;
+
+	req.ringinfo.ring_pt_address = virt_to_phys(log_stream->ring_descr);
+	req.ringinfo.num_pages = log_stream->pages;
+	req.ringinfo.ring_size = log_stream->size;
+	req.ringinfo.ring_offset = 0;
+	req.ringinfo.ring_first_pfn = virt_to_phys(log_stream->dma_area);
+	memcpy(req.config, log_stream->config, sizeof(log_stream->config));
+
+	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
+	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_ENABLE_LOG);
+	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
+
+	dev_info(log_stream->hsw->dev, "send ipc to enable fw log\n");
+
+	ret = ipc_tx_message_wait(log_stream->hsw, header, &req, sizeof(req), NULL, 0);
+	if (ret < 0) {
+		dev_err(log_stream->hsw->dev, "ipc: enable fw log failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int fw_log_release(struct inode *inode, struct file *file)
+{
+	struct sst_hsw_log_stream *log_stream = inode->i_private;
+	u32 header;
+	int ret;
+
+	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
+	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_DISABLE_LOG);
+	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
+
+	dev_info(log_stream->hsw->dev, "send ipc to disable fw log\n");
+
+	ret = ipc_tx_message_nowait(log_stream->hsw, header, NULL, 0);
+	if (ret < 0) {
+		dev_err(log_stream->hsw->dev,
+			"ipc: disable fw log failed, returned %d\n", ret);
+		return ret;
+	}
+
+	pm_runtime_put(log_stream->hsw->dev);
+	return 0;
+}
+
+static ssize_t fw_log_copy_to_user(struct sst_hsw_log_stream *log_stream,
+					char __user *user_buf, size_t count)
+{
+	/* check for reader buffer wrap */
+	if (log_stream->reader_pos + count > log_stream->size) {
+		size_t size = log_stream->size - log_stream->reader_pos;
+
+		/* wrap */
+		if (copy_to_user(user_buf,
+			log_stream->dma_area + log_stream->reader_pos, size))
+			return -EFAULT;
+
+		if (copy_to_user(user_buf + size,
+			log_stream->dma_area, count - size))
+			return -EFAULT;
+
+		log_stream->reader_pos = count - size;
+
+		return count;
+
+	} else {
+		/* no wrap */
+		if (copy_to_user(user_buf,
+			log_stream->dma_area + log_stream->reader_pos, count))
+			return -EFAULT;
+
+		log_stream->reader_pos += count;
+
+		return count;
+	}
+}
+
+static ssize_t fw_log_read_data(struct file *file, char __user *user_buf,
+					size_t count, loff_t *ppos)
+{
+	struct sst_hsw_log_stream *log_stream = file->private_data;
+	size_t bytes;
+	ssize_t ret = 0;
+
+	do {
+		mutex_lock(&log_stream->rw_mutex);
+
+		if (log_stream->last_pos < log_stream->curr_pos) {
+			if (log_stream->reader_pos < log_stream->last_pos
+			|| log_stream->reader_pos > log_stream->curr_pos)
+
+				log_stream->reader_pos = log_stream->last_pos;
+		} else {
+			if (log_stream->reader_pos < log_stream->last_pos
+			&& log_stream->reader_pos > log_stream->curr_pos)
+
+				log_stream->reader_pos = log_stream->last_pos;
+		}
+
+		if (log_stream->curr_pos >= log_stream->reader_pos) {
+			bytes = log_stream->curr_pos - log_stream->reader_pos;
+		} else {
+			bytes = log_stream->curr_pos + log_stream->size -
+				log_stream->reader_pos;
+		}
+		mutex_unlock(&log_stream->rw_mutex);
+
+		if (bytes > count)
+			bytes = count;
+
+		if (bytes > 0) {
+			ret = fw_log_copy_to_user(log_stream, user_buf, bytes);
+			break;
+		}
+
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			break;
+		}
+
+		if (wait_event_interruptible(log_stream->readers_wait_q,
+			log_stream->curr_pos != log_stream->reader_pos)) {
+			ret = -ERESTARTSYS;
+			break;
+		}
+
+	} while (1);
+
+	return ret;
+}
+
+static const struct file_operations fw_log_fops = {
+	.open = fw_log_open_data,
+	.read = fw_log_read_data,
+	.release = fw_log_release,
+};
+
+static int fw_log_config_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t fw_log_config_read(struct file *file, char __user *buffer,
+						size_t count, loff_t *ppos)
+{
+	struct sst_hsw_log_stream *log_stream = file->private_data;
+	int max_size = sizeof(log_stream->config);
+
+	if (*ppos >= max_size)
+		return 0;
+	if (*ppos + count > max_size)
+		count = max_size - *ppos;
+
+	if (copy_to_user(buffer, log_stream->config + *ppos, count))
+		return -EFAULT;
+
+	*ppos += count;
+
+	return count;
+}
+
+static ssize_t fw_log_config_write(struct file *file,
+	const char __user *buffer, size_t count, loff_t *ppos)
+{
+	struct sst_hsw_log_stream *log_stream = file->private_data;
+	struct sst_hsw_ipc_debug_log_enable_req req;
+	u32 header;
+	int max_size = sizeof(log_stream->config);
+	int ret;
+
+	if (*ppos >= max_size)
+		return 0;
+	if (*ppos + count > max_size)
+		count = max_size - *ppos;
+
+	if (copy_from_user(log_stream->config + *ppos, buffer, count))
+		return -EFAULT;
+
+	*ppos += count;
+
+	req.ringinfo.ring_pt_address = virt_to_phys(log_stream->ring_descr);
+	req.ringinfo.num_pages = log_stream->pages;
+	req.ringinfo.ring_size = log_stream->size;
+	req.ringinfo.ring_offset = 0;
+	req.ringinfo.ring_first_pfn = virt_to_phys(log_stream->dma_area);
+	memcpy(req.config, log_stream->config, sizeof(log_stream->config));
+
+	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
+	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_ENABLE_LOG);
+	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
+
+	dev_info(log_stream->hsw->dev, "send ipc to configure fw log\n");
+
+	ret = ipc_tx_message_nowait(log_stream->hsw, header, &req, sizeof(req));
+	if (ret < 0) {
+		dev_err(log_stream->hsw->dev, "ipc: setting config fw log failed\n");
+		return ret;
+	}
+
+	return count;
+}
+
+static const struct file_operations fw_log_config_fops = {
+	.open = fw_log_config_open,
+	.read = fw_log_config_read,
+	.write = fw_log_config_write,
+};
+
+#ifdef CONFIG_PM
+static int suspend_stats_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static const char *get_dstate_name(int state)
+{
+	const char *state_name[] = {"D0", "IDLE", "D3", "UNKNOWN"};
+	switch (state) {
+	case d0_state: return state_name[0];
+	case idle_state: return state_name[1];
+	case d3_state: return state_name[2];
+	default: return state_name[3];
+	}
+}
+
+static ssize_t suspend_stats_read(struct file *file, char __user *buffer,
+				  size_t count, loff_t *ppos)
+{
+	struct sst_hsw_log_stream *log_stream = file->private_data;
+	struct sst_hsw *hsw = log_stream->hsw;
+	char *buf = NULL;
+
+	if (*ppos)
+		return 0;
+
+	buf = kzalloc(PAGE_SIZE, GFP_DMA);
+	if (buf == NULL) {
+		pr_err("suspend stats buf kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	count = snprintf(buf, PAGE_SIZE,
+		"current state %s (%d)\ncount of :\n"
+		"Idle %d\n"
+		"D0 %d\nD3 %d\nS0 %d\nS3 %d\n",
+		get_dstate_name(hsw->dx_state), hsw->dx_state,
+		hsw->cnt_state_idle,
+		hsw->cnt_state_d0, hsw->cnt_state_d3,
+		hsw->cnt_state_s0, hsw->cnt_state_s3);
+
+	if (copy_to_user(buffer, buf, count)) {
+		pr_err("suspend stats copy_to_user failed\n");
+		kfree(buf);
+		return -EFAULT;
+	}
+
+	*ppos = count;
+	kfree(buf);
+
+	return count;
+}
+
+static const struct file_operations suspend_stats_fops = {
+	.open = suspend_stats_open,
+	.read = suspend_stats_read,
+};
+#endif
+
+/* debug control - sysFS */
+int sst_hsw_dbg_enable(struct sst_hsw *hsw,
+	struct dentry *debugfs_card_root)
+{
+	struct sst_hsw_log_stream *log_stream = &hsw->log_stream;
+	int i;
+	struct snd_dma_buffer *dma_buf[2];
+	static struct dentry *fwdir;
+	
+	dma_buf[0] = devm_kzalloc(hsw->dsp->dev, sizeof(*dma_buf[0]), GFP_KERNEL);
+	dma_buf[1] = devm_kzalloc(hsw->dsp->dev, sizeof(*dma_buf[1]), GFP_KERNEL);
+	memset(log_stream->config, 0xFF, sizeof(log_stream->config));
+	log_stream->size = 32 * PAGE_SIZE;
+	log_stream->hsw = hsw;
+
+//	log_stream->dma_area = dma_alloc_coherent(/*hsw->dsp->dma_dev*/log_stream->hsw->dev,
+//		log_stream->size, &log_stream->dma_addr, GFP_KERNEL);
+	snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, hsw->dsp->dma_dev,
+				log_stream->size, dma_buf[0]);
+	log_stream->dma_addr = dma_buf[0]->addr;
+	log_stream->dma_area = dma_buf[0]->area;
+	dev_info(log_stream->hsw->dev,
+		"alloc dma buffer: area=%p, addr=%p, size=%d\n",
+		(void *)log_stream->dma_area,
+		(void *)log_stream->dma_addr,
+		log_stream->size);
+
+	if (!log_stream->dma_area) {
+		dev_err(log_stream->hsw->dev, "alloc dma buffer failed\n");
+		return -EINVAL;
+	}
+
+//	log_stream->ring_descr = kzalloc(PAGE_SIZE, GFP_DMA);
+	snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, hsw->dsp->dma_dev,
+				PAGE_SIZE, dma_buf[1]);
+	log_stream->ring_descr = dma_buf[1]->area;
+
+	if (!log_stream->ring_descr) {
+		dev_err(log_stream->hsw->dev, "alloc ring descriptor failed\n");
+		return -EINVAL;
+	}
+
+	if (log_stream->size % PAGE_SIZE)
+		log_stream->pages = (log_stream->size / PAGE_SIZE) + 1;
+	else
+		log_stream->pages = log_stream->size / PAGE_SIZE;
+
+	dev_info(log_stream->hsw->dev,
+		"generating page table for %p size 0x%x pages %d\n",
+		log_stream->dma_area, log_stream->size, log_stream->pages);
+
+	for (i = 0; i < log_stream->pages; i++) {
+		u32 idx = (((i << 2) + i)) >> 1;
+		u32 pfn = (virt_to_phys(log_stream->dma_area + i * PAGE_SIZE))
+				>> PAGE_SHIFT;
+		u32 *pg_table;
+
+		pg_table = (u32 *)(log_stream->ring_descr + idx);
+
+		if (i & 1)
+			*pg_table |= (pfn << 4);
+		else
+			*pg_table |= pfn;
+	}
+
+	INIT_WORK(&log_stream->notify_work, hsw_log_notification_work);
+	init_waitqueue_head(&log_stream->readers_wait_q);
+	mutex_init(&log_stream->rw_mutex);
+
+	dev_dbg(log_stream->hsw->dev,"debugfs_card_root:%s", debugfs_card_root->d_name.name);
+
+	fwdir = debugfs_create_dir("fw_logs", NULL);
+
+	if (!debugfs_create_file("fw_log", 0444, fwdir,
+			&hsw->log_stream, &fw_log_fops))
+		pr_warn("ASoC: Failed to create fw_log debugfs file\n");
+
+#if 1
+	if (!debugfs_create_file("fw_log_config", 0644, fwdir,
+			&hsw->log_stream, &fw_log_config_fops))
+		pr_warn("ASoC: Failed to create fw_log_config debugfs file\n");
+
+#ifdef CONFIG_PM
+	if (!debugfs_create_file("suspend_stats", 0444, fwdir,
+			&hsw->log_stream, &suspend_stats_fops))
+		pr_warn("ASoC: Failed to create suspend_stats file\n");
+#endif
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(sst_hsw_dbg_enable);
+
+int sst_hsw_dbg_disable(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 log_id)
+{
+	return 0;
+}
+
 static void sst_hsw_drop_all(struct sst_hsw *hsw)
 {
 	struct ipc_message *msg, *tmp;
@@ -2040,7 +2418,7 @@
 
 	ret = msg_empty_list_init(hsw);
 	if (ret < 0)
-		return -ENOMEM;
+		goto list_err;
 
 	/* start the IPC message thread */
 	init_kthread_worker(&hsw->kworker);
@@ -2050,7 +2428,7 @@
 	if (IS_ERR(hsw->tx_thread)) {
 		ret = PTR_ERR(hsw->tx_thread);
 		dev_err(hsw->dev, "error: failed to create message TX task\n");
-		goto err_free_msg;
+		goto list_err;
 	}
 	init_kthread_work(&hsw->kwork, ipc_tx_msgs);
 
@@ -2060,7 +2438,7 @@
 	hsw->dsp = sst_dsp_new(dev, &hsw_dev, pdata);
 	if (hsw->dsp == NULL) {
 		ret = -ENODEV;
-		goto dsp_err;
+		goto list_err;
 	}
 
 	/* allocate DMA buffer for context storage */
@@ -2114,11 +2492,8 @@
 			hsw->dx_context, hsw->dx_context_paddr);
 dma_err:
 	sst_dsp_free(hsw->dsp);
-dsp_err:
-	kthread_stop(hsw->tx_thread);
-err_free_msg:
 	kfree(hsw->msg);
-
+list_err:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(sst_hsw_dsp_init);
@@ -2133,7 +2508,6 @@
 			hsw->dx_context, hsw->dx_context_paddr);
 	sst_dsp_free(hsw->dsp);
 	kfree(hsw->scratch);
-	kthread_stop(hsw->tx_thread);
 	kfree(hsw->msg);
 }
 EXPORT_SYMBOL_GPL(sst_hsw_dsp_free);
diff -Naur linux-3.19.old/sound/soc/intel/sst-haswell-ipc.h linux-3.19/sound/soc/intel/sst-haswell-ipc.h
--- linux-3.19.old/sound/soc/intel/sst-haswell-ipc.h	2015-03-24 17:38:14.423176947 -0800
+++ linux-3.19/sound/soc/intel/sst-haswell-ipc.h	2015-03-24 18:19:04.687996773 -0800
@@ -21,10 +21,9 @@
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
 
-#define SST_HSW_NO_CHANNELS		4
+#define SST_HSW_NO_CHANNELS		2
 #define SST_HSW_MAX_DX_REGIONS		14
 #define SST_HSW_DX_CONTEXT_SIZE        (640 * 1024)
-#define SST_HSW_CHANNELS_ALL		0xffffffff
 
 #define SST_HSW_FW_LOG_CONFIG_DWORDS	12
 #define SST_HSW_GLOBAL_LOG		15
@@ -488,6 +487,8 @@
 int sst_hsw_dsp_init(struct device *dev, struct sst_pdata *pdata);
 void sst_hsw_dsp_free(struct device *dev, struct sst_pdata *pdata);
 struct sst_dsp *sst_hsw_get_dsp(struct sst_hsw *hsw);
+int sst_hsw_dbg_enable(struct sst_hsw *hsw,
+	struct dentry *debugfs_card_root);
 
 /* runtime module management */
 struct sst_module_runtime *sst_hsw_runtime_module_create(struct sst_hsw *hsw,
diff -Naur linux-3.19.old/sound/soc/intel/sst-haswell-pcm.c linux-3.19/sound/soc/intel/sst-haswell-pcm.c
--- linux-3.19.old/sound/soc/intel/sst-haswell-pcm.c	2015-03-24 17:38:14.423176947 -0800
+++ linux-3.19/sound/soc/intel/sst-haswell-pcm.c	2015-03-24 18:54:33.004726866 -0800
@@ -32,6 +32,7 @@
 #include "sst-haswell-ipc.h"
 #include "sst-dsp-priv.h"
 #include "sst-dsp.h"
+#include "sst-debugfs.h"
 
 #define HSW_PCM_COUNT		6
 #define HSW_VOLUME_MAX		0x7FFFFFFF	/* 0dB */
@@ -189,8 +190,7 @@
 	if (ucontrol->value.integer.value[0] ==
 		ucontrol->value.integer.value[1]) {
 		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		/* apply volume value to all channels */
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, SST_HSW_CHANNELS_ALL, volume);
+		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, 2, volume);
 	} else {
 		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
 		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, 0, volume);
@@ -256,7 +256,7 @@
 		ucontrol->value.integer.value[1]) {
 
 		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		sst_hsw_mixer_set_volume(hsw, 0, SST_HSW_CHANNELS_ALL, volume);
+		sst_hsw_mixer_set_volume(hsw, 0, 2, volume);
 
 	} else {
 		volume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
@@ -298,19 +298,23 @@
 static const struct snd_kcontrol_new hsw_volume_controls[] = {
 	/* Global DSP volume */
 	SOC_DOUBLE_EXT_TLV("Master Playback Volume", 0, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
+		ARRAY_SIZE(volume_map) -1, 0,
 		hsw_volume_get, hsw_volume_put, hsw_vol_tlv),
 	/* Offload 0 volume */
 	SOC_DOUBLE_EXT_TLV("Media0 Playback Volume", 1, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
+		ARRAY_SIZE(volume_map), 0,
 		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
 	/* Offload 1 volume */
 	SOC_DOUBLE_EXT_TLV("Media1 Playback Volume", 2, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
+		ARRAY_SIZE(volume_map), 0,
+		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
+	/* Loopback volume */
+	SOC_DOUBLE_EXT_TLV("Loopback Capture Volume", 3, 0, 8,
+		ARRAY_SIZE(volume_map), 0,
 		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
 	/* Mic Capture volume */
-	SOC_DOUBLE_EXT_TLV("Mic Capture Volume", 0, 0, 8,
-		ARRAY_SIZE(volume_map) - 1, 0,
+	SOC_DOUBLE_EXT_TLV("Mic Capture Volume", 4, 0, 8,
+		ARRAY_SIZE(volume_map), 0,
 		hsw_stream_volume_get, hsw_stream_volume_put, hsw_vol_tlv),
 };
 
@@ -396,14 +400,8 @@
 	/* DSP stream type depends on DAI ID */
 	switch (rtd->cpu_dai->id) {
 	case 0:
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			stream_type = SST_HSW_STREAM_TYPE_SYSTEM;
-			module_id = SST_HSW_MODULE_PCM_SYSTEM;
-		}
-		else {
-			stream_type = SST_HSW_STREAM_TYPE_CAPTURE;
-			module_id = SST_HSW_MODULE_PCM_CAPTURE;
-		}
+		stream_type = SST_HSW_STREAM_TYPE_SYSTEM;
+		module_id = SST_HSW_MODULE_PCM_SYSTEM;
 		break;
 	case 1:
 	case 2:
@@ -416,6 +414,10 @@
 		path_id = SST_HSW_STREAM_PATH_SSP0_OUT;
 		module_id = SST_HSW_MODULE_PCM_REFERENCE;
 		break;
+	case 4:
+		stream_type = SST_HSW_STREAM_TYPE_CAPTURE;
+		module_id = SST_HSW_MODULE_PCM_CAPTURE;
+		break;
 	default:
 		dev_err(rtd->dev, "error: invalid DAI ID %d\n",
 			rtd->cpu_dai->id);
@@ -524,20 +526,18 @@
 		dev_err(rtd->dev, "error: failed to commit stream %d\n", ret);
 		return ret;
 	}
-
-	if (!pcm_data->allocated) {
-		/* Set previous saved volume */
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
-				0, pcm_data->volume[0]);
-		sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
-				1, pcm_data->volume[1]);
-		pcm_data->allocated = true;
-	}
+	pcm_data->allocated = true;
 
 	ret = sst_hsw_stream_pause(hsw, pcm_data->stream, 1);
 	if (ret < 0)
 		dev_err(rtd->dev, "error: failed to pause %d\n", ret);
 
+	/* Set previous saved volume */
+	sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
+			0, pcm_data->volume[0]);
+	sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
+			1, pcm_data->volume[1]);
+
 	return 0;
 }
 
@@ -556,14 +556,14 @@
 	struct sst_hsw *hsw = pdata->hsw;
 
 	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		sst_hsw_stream_resume(hsw, pcm_data->stream, 0);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		sst_hsw_stream_pause(hsw, pcm_data->stream, 0);
 		break;
 	default:
@@ -781,13 +781,6 @@
 			.rates = SNDRV_PCM_RATE_48000,
 			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
 		},
-		.capture = {
-			.stream_name = "Analog Capture",
-			.channels_min = 2,
-			.channels_max = 4,
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
-		},
 	},
 	{
 		/* PCM */
@@ -824,6 +817,17 @@
 			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
 		},
 	},
+	{
+		.name  = "Capture Pin",
+		.id = HSW_PCM_DAI_ID_CAPTURE,
+		.capture = {
+			.stream_name = "Analog Capture",
+			.channels_min = 2,
+			.channels_max = 4,
+			.rates = SNDRV_PCM_RATE_48000,
+			.formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE,
+		},
+	},
 };
 
 static const struct snd_soc_dapm_widget widgets[] = {
@@ -852,8 +856,8 @@
 
 static int hsw_pcm_probe(struct snd_soc_platform *platform)
 {
-	struct hsw_priv_data *priv_data = snd_soc_platform_get_drvdata(platform);
 	struct sst_pdata *pdata = dev_get_platdata(platform->dev);
+	struct hsw_priv_data *priv_data;
 	struct device *dma_dev, *dev;
 	int i, ret = 0;
 
@@ -863,10 +867,12 @@
 	dev = platform->dev;
 	dma_dev = pdata->dma_dev;
 
+	priv_data = devm_kzalloc(platform->dev, sizeof(*priv_data), GFP_KERNEL);
 	priv_data->hsw = pdata->dsp;
 	priv_data->dev = platform->dev;
 	priv_data->pm_state = HSW_PM_STATE_D0;
 	priv_data->soc_card = platform->component.card;
+	snd_soc_platform_set_drvdata(platform, priv_data);
 
 	/* allocate DSP buffer page tables */
 	for (i = 0; i < ARRAY_SIZE(hsw_dais); i++) {
@@ -937,38 +943,29 @@
 	.ops		= &hsw_pcm_ops,
 	.pcm_new	= hsw_pcm_new,
 	.pcm_free	= hsw_pcm_free,
+	.controls	= hsw_volume_controls,
+	.num_controls	= ARRAY_SIZE(hsw_volume_controls),
+	.dapm_widgets	= widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(widgets),
+	.dapm_routes	= graph,
+	.num_dapm_routes	= ARRAY_SIZE(graph),
 };
 
 static const struct snd_soc_component_driver hsw_dai_component = {
-	.name = "haswell-dai",
-	.controls = hsw_volume_controls,
-	.num_controls = ARRAY_SIZE(hsw_volume_controls),
-	.dapm_widgets = widgets,
-	.num_dapm_widgets = ARRAY_SIZE(widgets),
-	.dapm_routes = graph,
-	.num_dapm_routes = ARRAY_SIZE(graph),
+	.name		= "haswell-dai",
 };
 
 static int hsw_pcm_dev_probe(struct platform_device *pdev)
 {
 	struct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);
 	struct hsw_priv_data *priv_data;
+	struct dentry root;
 	int ret;
 
-	if (!sst_pdata)
-		return -EINVAL;
-
-	priv_data = devm_kzalloc(&pdev->dev, sizeof(*priv_data), GFP_KERNEL);
-	if (!priv_data)
-		return -ENOMEM;
-
 	ret = sst_hsw_dsp_init(&pdev->dev, sst_pdata);
 	if (ret < 0)
 		return -ENODEV;
 
-	priv_data->hsw = sst_pdata->dsp;
-	platform_set_drvdata(pdev, priv_data);
-
 	ret = snd_soc_register_platform(&pdev->dev, &hsw_soc_platform);
 	if (ret < 0)
 		goto err_plat;
@@ -978,6 +975,12 @@
 	if (ret < 0)
 		goto err_comp;
 
+#ifdef CONFIG_DEBUG_FS
+	priv_data->hsw = sst_pdata->dsp;
+	sst_debugfs_get_root(&root);
+	sst_hsw_dbg_enable(priv_data->hsw, &root);
+#endif
+
 	return 0;
 
 err_comp:
@@ -999,6 +1002,7 @@
 }
 
 #ifdef CONFIG_PM
+#ifdef CONFIG_PM
 
 static int hsw_pcm_runtime_idle(struct device *dev)
 {
@@ -1051,14 +1055,6 @@
 	return ret;
 }
 
-#else
-#define hsw_pcm_runtime_idle		NULL
-#define hsw_pcm_runtime_suspend		NULL
-#define hsw_pcm_runtime_resume		NULL
-#endif
-
-#ifdef CONFIG_PM
-
 static void hsw_pcm_complete(struct device *dev)
 {
 	struct hsw_priv_data *pdata = dev_get_drvdata(dev);
@@ -1153,10 +1149,12 @@
 
 	return 0;
 }
-
 #else
-#define hsw_pcm_prepare		NULL
-#define hsw_pcm_complete	NULL
+#define hsw_pcm_runtime_idle		NULL
+#define hsw_pcm_runtime_suspend		NULL
+#define hsw_pcm_runtime_resume		NULL
+#define hsw_pcm_runtime_complete	NULL
+#define hsw_pcm_runtime_prepare		NULL
 #endif
 
 static const struct dev_pm_ops hsw_pcm_pm = {
@@ -1166,11 +1164,16 @@
 	.prepare = hsw_pcm_prepare,
 	.complete = hsw_pcm_complete,
 };
+#else
+#define hsw_pcm_pm	NULL
+#endif
 
 static struct platform_driver hsw_pcm_driver = {
 	.driver = {
 		.name = "haswell-pcm-audio",
+		.owner = THIS_MODULE,
 		.pm = &hsw_pcm_pm,
+
 	},
 
 	.probe = hsw_pcm_dev_probe,
diff -Naur linux-3.19.old/sound/soc/intel/sst-mfld-dsp.h linux-3.19/sound/soc/intel/sst-mfld-dsp.h
--- linux-3.19.old/sound/soc/intel/sst-mfld-dsp.h	2015-03-24 17:38:14.426510279 -0800
+++ linux-3.19/sound/soc/intel/sst-mfld-dsp.h	2015-03-24 18:19:04.687996773 -0800
@@ -3,7 +3,7 @@
 /*
  *  sst_mfld_dsp.h - Intel SST Driver for audio engine
  *
- *  Copyright (C) 2008-14 Intel Corporation
+ *  Copyright (C) 2008-12 Intel Corporation
  *  Authors:	Vinod Koul <vinod.koul@linux.intel.com>
  *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
@@ -19,142 +19,6 @@
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
-#define SST_MAX_BIN_BYTES 1024
-
-#define MAX_DBG_RW_BYTES 80
-#define MAX_NUM_SCATTER_BUFFERS 8
-#define MAX_LOOP_BACK_DWORDS 8
-/* IPC base address and mailbox, timestamp offsets */
-#define SST_MAILBOX_SIZE 0x0400
-#define SST_MAILBOX_SEND 0x0000
-#define SST_TIME_STAMP 0x1800
-#define SST_TIME_STAMP_MRFLD 0x800
-#define SST_RESERVED_OFFSET 0x1A00
-#define SST_SCU_LPE_MAILBOX 0x1000
-#define SST_LPE_SCU_MAILBOX 0x1400
-#define SST_SCU_LPE_LOG_BUF (SST_SCU_LPE_MAILBOX+16)
-#define PROCESS_MSG 0x80
-
-/* Message ID's for IPC messages */
-/* Bits B7: SST or IA/SC ; B6-B4: Msg Category; B3-B0: Msg Type */
-
-/* I2L Firmware/Codec Download msgs */
-#define IPC_IA_PREP_LIB_DNLD 0x01
-#define IPC_IA_LIB_DNLD_CMPLT 0x02
-#define IPC_IA_GET_FW_VERSION 0x04
-#define IPC_IA_GET_FW_BUILD_INF 0x05
-#define IPC_IA_GET_FW_INFO 0x06
-#define IPC_IA_GET_FW_CTXT 0x07
-#define IPC_IA_SET_FW_CTXT 0x08
-#define IPC_IA_PREPARE_SHUTDOWN 0x31
-/* I2L Codec Config/control msgs */
-#define IPC_PREP_D3 0x10
-#define IPC_IA_SET_CODEC_PARAMS 0x10
-#define IPC_IA_GET_CODEC_PARAMS 0x11
-#define IPC_IA_SET_PPP_PARAMS 0x12
-#define IPC_IA_GET_PPP_PARAMS 0x13
-#define IPC_SST_PERIOD_ELAPSED_MRFLD 0xA
-#define IPC_IA_ALG_PARAMS 0x1A
-#define IPC_IA_TUNING_PARAMS 0x1B
-#define IPC_IA_SET_RUNTIME_PARAMS 0x1C
-#define IPC_IA_SET_PARAMS 0x1
-#define IPC_IA_GET_PARAMS 0x2
-
-#define IPC_EFFECTS_CREATE 0xE
-#define IPC_EFFECTS_DESTROY 0xF
-
-/* I2L Stream config/control msgs */
-#define IPC_IA_ALLOC_STREAM_MRFLD 0x2
-#define IPC_IA_ALLOC_STREAM 0x20 /* Allocate a stream ID */
-#define IPC_IA_FREE_STREAM_MRFLD 0x03
-#define IPC_IA_FREE_STREAM 0x21 /* Free the stream ID */
-#define IPC_IA_SET_STREAM_PARAMS 0x22
-#define IPC_IA_SET_STREAM_PARAMS_MRFLD 0x12
-#define IPC_IA_GET_STREAM_PARAMS 0x23
-#define IPC_IA_PAUSE_STREAM 0x24
-#define IPC_IA_PAUSE_STREAM_MRFLD 0x4
-#define IPC_IA_RESUME_STREAM 0x25
-#define IPC_IA_RESUME_STREAM_MRFLD 0x5
-#define IPC_IA_DROP_STREAM 0x26
-#define IPC_IA_DROP_STREAM_MRFLD 0x07
-#define IPC_IA_DRAIN_STREAM 0x27 /* Short msg with str_id */
-#define IPC_IA_DRAIN_STREAM_MRFLD 0x8
-#define IPC_IA_CONTROL_ROUTING 0x29
-#define IPC_IA_VTSV_UPDATE_MODULES 0x20
-#define IPC_IA_VTSV_DETECTED 0x21
-
-#define IPC_IA_START_STREAM_MRFLD 0X06
-#define IPC_IA_START_STREAM 0x30 /* Short msg with str_id */
-
-#define IPC_IA_SET_GAIN_MRFLD 0x21
-/* Debug msgs */
-#define IPC_IA_DBG_MEM_READ 0x40
-#define IPC_IA_DBG_MEM_WRITE 0x41
-#define IPC_IA_DBG_LOOP_BACK 0x42
-#define IPC_IA_DBG_LOG_ENABLE 0x45
-#define IPC_IA_DBG_SET_PROBE_PARAMS 0x47
-
-/* L2I Firmware/Codec Download msgs */
-#define IPC_IA_FW_INIT_CMPLT 0x81
-#define IPC_IA_FW_INIT_CMPLT_MRFLD 0x01
-#define IPC_IA_FW_ASYNC_ERR_MRFLD 0x11
-
-/* L2I Codec Config/control msgs */
-#define IPC_SST_FRAGMENT_ELPASED 0x90 /* Request IA more data */
-
-#define IPC_SST_BUF_UNDER_RUN 0x92 /* PB Under run and stopped */
-#define IPC_SST_BUF_OVER_RUN 0x93 /* CAP Under run and stopped */
-#define IPC_SST_DRAIN_END 0x94 /* PB Drain complete and stopped */
-#define IPC_SST_CHNGE_SSP_PARAMS 0x95 /* PB SSP parameters changed */
-#define IPC_SST_STREAM_PROCESS_FATAL_ERR 0x96/* error in processing a stream */
-#define IPC_SST_PERIOD_ELAPSED 0x97 /* period elapsed */
-
-#define IPC_SST_ERROR_EVENT 0x99 /* Buffer over run occurred */
-/* L2S messages */
-#define IPC_SC_DDR_LINK_UP 0xC0
-#define IPC_SC_DDR_LINK_DOWN 0xC1
-#define IPC_SC_SET_LPECLK_REQ 0xC2
-#define IPC_SC_SSP_BIT_BANG 0xC3
-
-/* L2I Error reporting msgs */
-#define IPC_IA_MEM_ALLOC_FAIL 0xE0
-#define IPC_IA_PROC_ERR 0xE1 /* error in processing a
-					stream can be used by playback and
-					capture modules */
-
-/* L2I Debug msgs */
-#define IPC_IA_PRINT_STRING 0xF0
-
-/* Buffer under-run */
-#define IPC_IA_BUF_UNDER_RUN_MRFLD 0x0B
-
-/* Mrfld specific defines:
- * For asynchronous messages(INIT_CMPLT, PERIOD_ELAPSED, ASYNC_ERROR)
- * received from FW, the format is:
- *  - IPC High: pvt_id is set to zero. Always short message.
- *  - msg_id is in lower 16-bits of IPC low payload.
- *  - pipe_id is in higher 16-bits of IPC low payload for period_elapsed.
- *  - error id is in higher 16-bits of IPC low payload for async errors.
- */
-#define SST_ASYNC_DRV_ID 0
-
-/* Command Response or Acknowledge message to any IPC message will have
- * same message ID and stream ID information which is sent.
- * There is no specific Ack message ID. The data field is used as response
- * meaning.
- */
-enum ackData {
-	IPC_ACK_SUCCESS = 0,
-	IPC_ACK_FAILURE,
-};
-
-enum ipc_ia_msg_id {
-	IPC_CMD = 1,		/*!< Task Control message ID */
-	IPC_SET_PARAMS = 2,/*!< Task Set param message ID */
-	IPC_GET_PARAMS = 3,	/*!< Task Get param message ID */
-	IPC_INVALID = 0xFF,	/*!<Task Get param message ID */
-};
-
 enum sst_codec_types {
 	/*  AUDIO/MUSIC	CODEC Type Definitions */
 	SST_CODEC_TYPE_UNKNOWN = 0,
@@ -171,157 +35,14 @@
 	SST_STREAM_TYPE_MUSIC = 1,
 };
 
-enum sst_error_codes {
-	/* Error code,response to msgId: Description */
-	/* Common error codes */
-	SST_SUCCESS = 0,        /* Success */
-	SST_ERR_INVALID_STREAM_ID = 1,
-	SST_ERR_INVALID_MSG_ID = 2,
-	SST_ERR_INVALID_STREAM_OP = 3,
-	SST_ERR_INVALID_PARAMS = 4,
-	SST_ERR_INVALID_CODEC = 5,
-	SST_ERR_INVALID_MEDIA_TYPE = 6,
-	SST_ERR_STREAM_ERR = 7,
-
-	SST_ERR_STREAM_IN_USE = 15,
-};
-
-struct ipc_dsp_hdr {
-	u16 mod_index_id:8;		/*!< DSP Command ID specific to tasks */
-	u16 pipe_id:8;	/*!< instance of the module in the pipeline */
-	u16 mod_id;		/*!< Pipe_id */
-	u16 cmd_id;		/*!< Module ID = lpe_algo_types_t */
-	u16 length;		/*!< Length of the payload only */
-} __packed;
-
-union ipc_header_high {
-	struct {
-		u32  msg_id:8;	    /* Message ID - Max 256 Message Types */
-		u32  task_id:4;	    /* Task ID associated with this comand */
-		u32  drv_id:4;    /* Identifier for the driver to track*/
-		u32  rsvd1:8;	    /* Reserved */
-		u32  result:4;	    /* Reserved */
-		u32  res_rqd:1;	    /* Response rqd */
-		u32  large:1;	    /* Large Message if large = 1 */
-		u32  done:1;	    /* bit 30 - Done bit */
-		u32  busy:1;	    /* bit 31 - busy bit*/
-	} part;
-	u32 full;
-} __packed;
-/* IPC header */
-union ipc_header_mrfld {
-	struct {
-		u32 header_low_payload;
-		union ipc_header_high header_high;
-	} p;
-	u64 full;
-} __packed;
-/* CAUTION NOTE: All IPC message body must be multiple of 32 bits.*/
-
-/* IPC Header */
-union ipc_header {
-	struct {
-		u32  msg_id:8; /* Message ID - Max 256 Message Types */
-		u32  str_id:5;
-		u32  large:1;	/* Large Message if large = 1 */
-		u32  reserved:2;	/* Reserved for future use */
-		u32  data:14;	/* Ack/Info for msg, size of msg in Mailbox */
-		u32  done:1; /* bit 30 */
-		u32  busy:1; /* bit 31 */
-	} part;
-	u32 full;
-} __packed;
-
-/* Firmware build info */
-struct sst_fw_build_info {
-	unsigned char  date[16]; /* Firmware build date */
-	unsigned char  time[16]; /* Firmware build time */
-} __packed;
-
-/* Firmware Version info */
-struct snd_sst_fw_version {
-	u8 build;	/* build number*/
-	u8 minor;	/* minor number*/
-	u8 major;	/* major number*/
-	u8 type;	/* build type */
-};
-
-struct ipc_header_fw_init {
-	struct snd_sst_fw_version fw_version;/* Firmware version details */
-	struct sst_fw_build_info build_info;
-	u16 result;	/* Fw init result */
-	u8 module_id; /* Module ID in case of error */
-	u8 debug_info; /* Debug info from Module ID in case of fail */
-} __packed;
-
-struct snd_sst_tstamp {
-	u64 ring_buffer_counter;	/* PB/CP: Bytes copied from/to DDR. */
-	u64 hardware_counter;	    /* PB/CP: Bytes DMAed to/from SSP. */
-	u64 frames_decoded;
-	u64 bytes_decoded;
-	u64 bytes_copied;
-	u32 sampling_frequency;
-	u32 channel_peak[8];
-} __packed;
-
-/* Stream type params struture for Alloc stream */
-struct snd_sst_str_type {
-	u8 codec_type;		/* Codec type */
-	u8 str_type;		/* 1 = voice 2 = music */
-	u8 operation;		/* Playback or Capture */
-	u8 protected_str;	/* 0=Non DRM, 1=DRM */
-	u8 time_slots;
-	u8 reserved;		/* Reserved */
-	u16 result;		/* Result used for acknowledgment */
-} __packed;
-
-/* Library info structure */
-struct module_info {
-	u32 lib_version;
-	u32 lib_type;/*TBD- KLOCKWORK u8 lib_type;*/
-	u32 media_type;
-	u8  lib_name[12];
-	u32 lib_caps;
-	unsigned char  b_date[16]; /* Lib build date */
-	unsigned char  b_time[16]; /* Lib build time */
-} __packed;
-
-/* Library slot info */
-struct lib_slot_info {
-	u8  slot_num; /* 1 or 2 */
-	u8  reserved1;
-	u16 reserved2;
-	u32 iram_size; /* slot size in IRAM */
-	u32 dram_size; /* slot size in DRAM */
-	u32 iram_offset; /* starting offset of slot in IRAM */
-	u32 dram_offset; /* starting offset of slot in DRAM */
-} __packed;
-
-struct snd_ppp_mixer_params {
-	__u32			type; /*Type of the parameter */
-	__u32			size;
-	__u32			input_stream_bitmap; /*Input stream Bit Map*/
-} __packed;
-
-struct snd_sst_lib_download {
-	struct module_info lib_info; /* library info type, capabilities etc */
-	struct lib_slot_info slot_info; /* slot info to be downloaded */
-	u32 mod_entry_pt;
-};
-
-struct snd_sst_lib_download_info {
-	struct snd_sst_lib_download dload_lib;
-	u16 result;	/* Result used for acknowledgment */
-	u8 pvt_id; /* Private ID */
-	u8 reserved;  /* for alignment */
-};
 struct snd_pcm_params {
 	u8 num_chan;	/* 1=Mono, 2=Stereo */
 	u8 pcm_wd_sz;	/* 16/24 - bit*/
-	u8 use_offload_path;	/* 0-PCM using period elpased & ALSA interfaces
-				   1-PCM stream via compressed interface  */
+	u32 reserved;	/* Bitrate in bits per second */
+	u32 sfreq;	/* Sampling rate in Hz */
+	u8 use_offload_path;
 	u8 reserved2;
-	u32 sfreq;    /* Sampling rate in Hz */
+	u16 reserved3;
 	u8 channel_map[8];
 } __packed;
 
@@ -355,7 +76,6 @@
 struct snd_wma_params {
 	u8  num_chan;	/* 1=Mono, 2=Stereo */
 	u8  pcm_wd_sz;	/* 16/24 - bit*/
-	u16 reserved1;
 	u32 brate;	/* Use the hard coded value. */
 	u32 sfreq;	/* Sampling freq eg. 8000, 441000, 48000 */
 	u32 channel_mask;  /* Channel Mask */
@@ -381,153 +101,26 @@
 };
 
 struct snd_sst_alloc_params_ext {
-	__u16 sg_count;
-	__u16 reserved;
-	__u32 frag_size;	/*Number of samples after which period elapsed
-				  message is sent valid only if path  = 0*/
 	struct sst_address_info  ring_buf_info[8];
-};
+	u8 sg_count;
+	u8 reserved;
+	u16 reserved2;
+	u32 frag_size;	/*Number of samples after which period elapsed
+				  message is sent valid only if path  = 0*/
+} __packed;
 
 struct snd_sst_stream_params {
 	union snd_sst_codec_params uc;
 } __packed;
 
 struct snd_sst_params {
-	u32 result;
 	u32 stream_id;
 	u8 codec;
 	u8 ops;
 	u8 stream_type;
 	u8 device_type;
-	u8 task;
 	struct snd_sst_stream_params sparams;
 	struct snd_sst_alloc_params_ext aparams;
 };
 
-struct snd_sst_alloc_mrfld {
-	u16 codec_type;
-	u8 operation;
-	u8 sg_count;
-	struct sst_address_info ring_buf_info[8];
-	u32 frag_size;
-	u32 ts;
-	struct snd_sst_stream_params codec_params;
-} __packed;
-
-/* Alloc stream params structure */
-struct snd_sst_alloc_params {
-	struct snd_sst_str_type str_type;
-	struct snd_sst_stream_params stream_params;
-	struct snd_sst_alloc_params_ext alloc_params;
-} __packed;
-
-/* Alloc stream response message */
-struct snd_sst_alloc_response {
-	struct snd_sst_str_type str_type; /* Stream type for allocation */
-	struct snd_sst_lib_download lib_dnld; /* Valid only for codec dnld */
-};
-
-/* Drop response */
-struct snd_sst_drop_response {
-	u32 result;
-	u32 bytes;
-};
-
-struct snd_sst_async_msg {
-	u32 msg_id; /* Async msg id */
-	u32 payload[0];
-};
-
-struct snd_sst_async_err_msg {
-	u32 fw_resp; /* Firmware Result */
-	u32 lib_resp; /*Library result */
-} __packed;
-
-struct snd_sst_vol {
-	u32	stream_id;
-	s32	volume;
-	u32	ramp_duration;
-	u32	ramp_type;		/* Ramp type, default=0 */
-};
-
-/* Gain library parameters for mrfld
- * based on DSP command spec v0.82
- */
-struct snd_sst_gain_v2 {
-	u16 gain_cell_num;  /* num of gain cells to modify*/
-	u8 cell_nbr_idx; /* instance index*/
-	u8 cell_path_idx; /* pipe-id */
-	u16 module_id; /*module id */
-	u16 left_cell_gain; /* left gain value in dB*/
-	u16 right_cell_gain; /* right gain value in dB*/
-	u16 gain_time_const; /* gain time constant*/
-} __packed;
-
-struct snd_sst_mute {
-	u32	stream_id;
-	u32	mute;
-};
-
-struct snd_sst_runtime_params {
-	u8 type;
-	u8 str_id;
-	u8 size;
-	u8 rsvd;
-	void *addr;
-} __packed;
-
-enum stream_param_type {
-	SST_SET_TIME_SLOT = 0,
-	SST_SET_CHANNEL_INFO = 1,
-	OTHERS = 2, /*reserved for future params*/
-};
-
-/* CSV Voice call routing structure */
-struct snd_sst_control_routing {
-	u8 control; /* 0=start, 1=Stop */
-	u8 reserved[3];	/* Reserved- for 32 bit alignment */
-};
-
-struct ipc_post {
-	struct list_head node;
-	union ipc_header header; /* driver specific */
-	bool is_large;
-	bool is_process_reply;
-	union ipc_header_mrfld mrfld_header;
-	char *mailbox_data;
-};
-
-struct snd_sst_ctxt_params {
-	u32 address; /* Physical Address in DDR where the context is stored */
-	u32 size; /* size of the context */
-};
-
-struct snd_sst_lpe_log_params {
-	u8 dbg_type;
-	u8 module_id;
-	u8 log_level;
-	u8 reserved;
-} __packed;
-
-enum snd_sst_bytes_type {
-	SND_SST_BYTES_SET = 0x1,
-	SND_SST_BYTES_GET = 0x2,
-};
-
-struct snd_sst_bytes_v2 {
-	u8 type;
-	u8 ipc_msg;
-	u8 block;
-	u8 task_id;
-	u8 pipe_id;
-	u8 rsvd;
-	u16 len;
-	char bytes[0];
-};
-
-#define MAX_VTSV_FILES 2
-struct snd_sst_vtsv_info {
-	struct sst_address_info vfiles[MAX_VTSV_FILES];
-} __packed;
-
 #endif /* __SST_MFLD_DSP_H__ */
diff -Naur linux-3.19.old/sound/soc/intel/sst-mfld-platform-compress.c linux-3.19/sound/soc/intel/sst-mfld-platform-compress.c
--- linux-3.19.old/sound/soc/intel/sst-mfld-platform-compress.c	2015-03-24 17:38:14.426510279 -0800
+++ linux-3.19/sound/soc/intel/sst-mfld-platform-compress.c	2015-03-24 18:19:04.687996773 -0800
@@ -67,11 +67,8 @@
 		goto out_ops;
 	}
 	stream->compr_ops = sst->compr_ops;
-	stream->id = 0;
-
-	/* Turn on LPE */
-	sst->compr_ops->power(sst->dev, true);
 
+	stream->id = 0;
 	sst_set_stream_status(stream, SST_PLATFORM_INIT);
 	runtime->private_data = stream;
 	return 0;
@@ -86,13 +83,10 @@
 	int ret_val = 0, str_id;
 
 	stream = cstream->runtime->private_data;
-	/* Turn off LPE */
-	sst->compr_ops->power(sst->dev, false);
-
 	/*need to check*/
 	str_id = stream->id;
 	if (str_id)
-		ret_val = stream->compr_ops->close(sst->dev, str_id);
+		ret_val = stream->compr_ops->close(str_id);
 	module_put(sst->dev->driver->owner);
 	kfree(stream);
 	pr_debug("%s: %d\n", __func__, ret_val);
@@ -106,19 +100,14 @@
 	int retval;
 	struct snd_sst_params str_params;
 	struct sst_compress_cb cb;
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct snd_soc_platform *platform = rtd->platform;
-	struct sst_data *ctx = snd_soc_platform_get_drvdata(platform);
 
 	stream = cstream->runtime->private_data;
 	/* construct fw structure for this*/
 	memset(&str_params, 0, sizeof(str_params));
 
-	/* fill the device type and stream id to pass to SST driver */
-	retval = sst_fill_stream_params(cstream, ctx, &str_params, true);
-	pr_debug("compr_set_params: fill stream params ret_val = 0x%x\n", retval);
-	if (retval < 0)
-		return retval;
+	str_params.ops = STREAM_OPS_PLAYBACK;
+	str_params.stream_type = SST_STREAM_TYPE_MUSIC;
+	str_params.device_type = SND_SST_DEVICE_COMPRESS;
 
 	switch (params->codec.id) {
 	case SND_AUDIOCODEC_MP3: {
@@ -164,7 +153,7 @@
 	cb.drain_cb_param = cstream;
 	cb.drain_notify = sst_drain_notify;
 
-	retval = stream->compr_ops->open(sst->dev, &str_params, &cb);
+	retval = stream->compr_ops->open(&str_params, &cb);
 	if (retval < 0) {
 		pr_err("stream allocation failed %d\n", retval);
 		return retval;
@@ -176,30 +165,10 @@
 
 static int sst_platform_compr_trigger(struct snd_compr_stream *cstream, int cmd)
 {
-	struct sst_runtime_stream *stream = cstream->runtime->private_data;
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
 
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		if (stream->compr_ops->stream_start)
-			return stream->compr_ops->stream_start(sst->dev, stream->id);
-	case SNDRV_PCM_TRIGGER_STOP:
-		if (stream->compr_ops->stream_drop)
-			return stream->compr_ops->stream_drop(sst->dev, stream->id);
-	case SND_COMPR_TRIGGER_DRAIN:
-		if (stream->compr_ops->stream_drain)
-			return stream->compr_ops->stream_drain(sst->dev, stream->id);
-	case SND_COMPR_TRIGGER_PARTIAL_DRAIN:
-		if (stream->compr_ops->stream_partial_drain)
-			return stream->compr_ops->stream_partial_drain(sst->dev, stream->id);
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (stream->compr_ops->stream_pause)
-			return stream->compr_ops->stream_pause(sst->dev, stream->id);
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (stream->compr_ops->stream_pause_release)
-			return stream->compr_ops->stream_pause_release(sst->dev, stream->id);
-	default:
-		return -EINVAL;
-	}
+	return stream->compr_ops->control(cmd, stream->id);
 }
 
 static int sst_platform_compr_pointer(struct snd_compr_stream *cstream,
@@ -208,7 +177,7 @@
 	struct sst_runtime_stream *stream;
 
 	stream  = cstream->runtime->private_data;
-	stream->compr_ops->tstamp(sst->dev, stream->id, tstamp);
+	stream->compr_ops->tstamp(stream->id, tstamp);
 	tstamp->byte_offset = tstamp->copied_total %
 				 (u32)cstream->runtime->buffer_size;
 	pr_debug("calc bytes offset/copied bytes as %d\n", tstamp->byte_offset);
@@ -221,7 +190,7 @@
 	struct sst_runtime_stream *stream;
 
 	stream  = cstream->runtime->private_data;
-	stream->compr_ops->ack(sst->dev, stream->id, (unsigned long)bytes);
+	stream->compr_ops->ack(stream->id, (unsigned long)bytes);
 	stream->bytes_written += bytes;
 
 	return 0;
@@ -251,7 +220,7 @@
 	struct sst_runtime_stream *stream  =
 		 cstream->runtime->private_data;
 
-	return stream->compr_ops->set_metadata(sst->dev, stream->id, metadata);
+	return stream->compr_ops->set_metadata(stream->id, metadata);
 }
 
 struct snd_compr_ops sst_platform_compr_ops = {
diff -Naur linux-3.19.old/sound/soc/intel/sst-mfld-platform.h linux-3.19/sound/soc/intel/sst-mfld-platform.h
--- linux-3.19.old/sound/soc/intel/sst-mfld-platform.h	2015-03-24 17:38:14.429843612 -0800
+++ linux-3.19/sound/soc/intel/sst-mfld-platform.h	2015-03-24 18:19:04.687996773 -0800
@@ -39,10 +39,9 @@
 
 struct pcm_stream_info {
 	int str_id;
-	void *arg;
-	void (*period_elapsed) (void *arg);
+	void *mad_substream;
+	void (*period_elapsed) (void *mad_substream);
 	unsigned long long buffer_ptr;
-	unsigned long long pcm_delay;
 	int sfreq;
 };
 
@@ -54,6 +53,18 @@
 	SST_PLATFORM_DROPPED,
 };
 
+enum sst_controls {
+	SST_SND_ALLOC =			0x00,
+	SST_SND_PAUSE =			0x01,
+	SST_SND_RESUME =		0x02,
+	SST_SND_DROP =			0x03,
+	SST_SND_FREE =			0x04,
+	SST_SND_BUFFER_POINTER =	0x05,
+	SST_SND_STREAM_INIT =		0x06,
+	SST_SND_START	 =		0x07,
+	SST_MAX_CONTROLS =		0x07,
+};
+
 enum sst_stream_ops {
 	STREAM_OPS_PLAYBACK = 0,
 	STREAM_OPS_CAPTURE,
@@ -99,38 +110,23 @@
 
 struct compress_sst_ops {
 	const char *name;
-	int (*open)(struct device *dev,
-		struct snd_sst_params *str_params, struct sst_compress_cb *cb);
-	int (*stream_start)(struct device *dev, unsigned int str_id);
-	int (*stream_drop)(struct device *dev, unsigned int str_id);
-	int (*stream_drain)(struct device *dev, unsigned int str_id);
-	int (*stream_partial_drain)(struct device *dev,	unsigned int str_id);
-	int (*stream_pause)(struct device *dev, unsigned int str_id);
-	int (*stream_pause_release)(struct device *dev,	unsigned int str_id);
-
-	int (*tstamp)(struct device *dev, unsigned int str_id,
-			struct snd_compr_tstamp *tstamp);
-	int (*ack)(struct device *dev, unsigned int str_id,
-			unsigned long bytes);
-	int (*close)(struct device *dev, unsigned int str_id);
-	int (*get_caps)(struct snd_compr_caps *caps);
-	int (*get_codec_caps)(struct snd_compr_codec_caps *codec);
-	int (*set_metadata)(struct device *dev,	unsigned int str_id,
+	int (*open) (struct snd_sst_params *str_params,
+			struct sst_compress_cb *cb);
+	int (*control) (unsigned int cmd, unsigned int str_id);
+	int (*tstamp) (unsigned int str_id, struct snd_compr_tstamp *tstamp);
+	int (*ack) (unsigned int str_id, unsigned long bytes);
+	int (*close) (unsigned int str_id);
+	int (*get_caps) (struct snd_compr_caps *caps);
+	int (*get_codec_caps) (struct snd_compr_codec_caps *codec);
+	int (*set_metadata) (unsigned int str_id,
 			struct snd_compr_metadata *mdata);
-	int (*power)(struct device *dev, bool state);
+
 };
 
 struct sst_ops {
-	int (*open)(struct device *dev, struct snd_sst_params *str_param);
-	int (*stream_init)(struct device *dev, struct pcm_stream_info *str_info);
-	int (*stream_start)(struct device *dev, int str_id);
-	int (*stream_drop)(struct device *dev, int str_id);
-	int (*stream_pause)(struct device *dev, int str_id);
-	int (*stream_pause_release)(struct device *dev, int str_id);
-	int (*stream_read_tstamp)(struct device *dev, struct pcm_stream_info *str_info);
-	int (*send_byte_stream)(struct device *dev, struct snd_sst_bytes_v2 *bytes);
-	int (*close)(struct device *dev, unsigned int str_id);
-	int (*power)(struct device *dev, bool state);
+	int (*open) (struct sst_stream_params *str_param);
+	int (*device_control) (int cmd, void *arg);
+	int (*close) (unsigned int str_id);
 };
 
 struct sst_runtime_stream {
@@ -147,34 +143,10 @@
 	char *name;
 	struct device *dev;
 	struct sst_ops *ops;
-	struct platform_device *pdev;
 	struct compress_sst_ops *compr_ops;
 };
 
-struct sst_data;
-
-int sst_dsp_init_v2_dpcm(struct snd_soc_platform *platform);
-int sst_send_pipe_gains(struct snd_soc_dai *dai, int stream, int mute);
-int send_ssp_cmd(struct snd_soc_dai *dai, const char *id, bool enable);
-int sst_handle_vb_timer(struct snd_soc_dai *dai, bool enable);
-
 void sst_set_stream_status(struct sst_runtime_stream *stream, int state);
-int sst_fill_stream_params(void *substream, const struct sst_data *ctx,
-			   struct snd_sst_params *str_params, bool is_compress);
-
-struct sst_algo_int_control_v2 {
-	struct soc_mixer_control mc;
-	u16 module_id; /* module identifieer */
-	u16 pipe_id; /* location info: pipe_id + instance_id */
-	u16 instance_id;
-	unsigned int value; /* Value received is stored here */
-};
-struct sst_data {
-	struct platform_device *pdev;
-	struct sst_platform_data *pdata;
-	struct snd_sst_bytes_v2 *byte_stream;
-	struct mutex lock;
-};
 int sst_register_dsp(struct sst_device *sst);
 int sst_unregister_dsp(struct sst_device *sst);
 #endif
diff -Naur linux-3.19.old/sound/soc/intel/sst-mfld-platform-pcm.c linux-3.19/sound/soc/intel/sst-mfld-platform-pcm.c
--- linux-3.19.old/sound/soc/intel/sst-mfld-platform-pcm.c	2015-03-24 17:38:14.426510279 -0800
+++ linux-3.19/sound/soc/intel/sst-mfld-platform-pcm.c	2015-03-24 18:19:04.687996773 -0800
@@ -1,7 +1,7 @@
 /*
  *  sst_mfld_platform.c - Intel MID Platform driver
  *
- *  Copyright (C) 2010-2014 Intel Corp
+ *  Copyright (C) 2010-2013 Intel Corp
  *  Author: Vinod Koul <vinod.koul@intel.com>
  *  Author: Harsha Priya <priya.harsha@intel.com>
  *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -27,9 +27,7 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/compress_driver.h>
-#include <asm/platform_sst_audio.h>
 #include "sst-mfld-platform.h"
-#include "sst-atom-controls.h"
 
 struct sst_device *sst;
 static DEFINE_MUTEX(sst_lock);
@@ -43,12 +41,12 @@
 		return -ENODEV;
 	mutex_lock(&sst_lock);
 	if (sst) {
-		dev_err(dev->dev, "we already have a device %s\n", sst->name);
+		pr_err("we already have a device %s\n", sst->name);
 		module_put(dev->dev->driver->owner);
 		mutex_unlock(&sst_lock);
 		return -EEXIST;
 	}
-	dev_dbg(dev->dev, "registering device %s\n", dev->name);
+	pr_debug("registering device %s\n", dev->name);
 	sst = dev;
 	mutex_unlock(&sst_lock);
 	return 0;
@@ -70,7 +68,7 @@
 	}
 
 	module_put(sst->dev->driver->owner);
-	dev_dbg(dev->dev, "unreg %s\n", sst->name);
+	pr_debug("unreg %s\n", sst->name);
 	sst = NULL;
 	mutex_unlock(&sst_lock);
 	return 0;
@@ -94,18 +92,35 @@
 	.fifo_size = SST_FIFO_SIZE,
 };
 
-static struct sst_dev_stream_map dpcm_strm_map[] = {
-	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, /* Reserved, not in use */
-	{MERR_DPCM_AUDIO, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA1_IN, SST_TASK_ID_MEDIA, 0},
-	{MERR_DPCM_COMPR, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA0_IN, SST_TASK_ID_MEDIA, 0},
-	{MERR_DPCM_AUDIO, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_PCM1_OUT, SST_TASK_ID_MEDIA, 0},
-};
-
-static int sst_media_digital_mute(struct snd_soc_dai *dai, int mute, int stream)
+/* MFLD - MSIC */
+static struct snd_soc_dai_driver sst_platform_dai[] = {
 {
-
-	return sst_send_pipe_gains(dai, stream, mute);
-}
+	.name = "Headset-cpu-dai",
+	.id = 0,
+	.playback = {
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 5,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+},
+{
+	.name = "Compress-cpu-dai",
+	.compress_dai = 1,
+	.playback = {
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+};
 
 /* helper functions */
 void sst_set_stream_status(struct sst_runtime_stream *stream,
@@ -128,142 +143,58 @@
 	return state;
 }
 
-static void sst_fill_alloc_params(struct snd_pcm_substream *substream,
-				struct snd_sst_alloc_params_ext *alloc_param)
-{
-	unsigned int channels;
-	snd_pcm_uframes_t period_size;
-	ssize_t periodbytes;
-	ssize_t buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
-	u32 buffer_addr = virt_to_phys(substream->dma_buffer.area);
-
-	channels = substream->runtime->channels;
-	period_size = substream->runtime->period_size;
-	periodbytes = samples_to_bytes(substream->runtime, period_size);
-	alloc_param->ring_buf_info[0].addr = buffer_addr;
-	alloc_param->ring_buf_info[0].size = buffer_bytes;
-	alloc_param->sg_count = 1;
-	alloc_param->reserved = 0;
-	alloc_param->frag_size = periodbytes * channels;
-
-}
 static void sst_fill_pcm_params(struct snd_pcm_substream *substream,
-				struct snd_sst_stream_params *param)
-{
-	param->uc.pcm_params.num_chan = (u8) substream->runtime->channels;
-	param->uc.pcm_params.pcm_wd_sz = substream->runtime->sample_bits;
-	param->uc.pcm_params.sfreq = substream->runtime->rate;
-
-	/* PCM stream via ALSA interface */
-	param->uc.pcm_params.use_offload_path = 0;
-	param->uc.pcm_params.reserved2 = 0;
-	memset(param->uc.pcm_params.channel_map, 0, sizeof(u8));
-
-}
-
-static int sst_get_stream_mapping(int dev, int sdev, int dir,
-	struct sst_dev_stream_map *map, int size)
-{
-	int i;
-
-	if (map == NULL)
-		return -EINVAL;
-
-
-	/* index 0 is not used in stream map */
-	for (i = 1; i < size; i++) {
-		if ((map[i].dev_num == dev) && (map[i].direction == dir))
-			return i;
-	}
-	return 0;
-}
-
-int sst_fill_stream_params(void *substream,
-	const struct sst_data *ctx, struct snd_sst_params *str_params, bool is_compress)
+				struct sst_pcm_params *param)
 {
-	int map_size;
-	int index;
-	struct sst_dev_stream_map *map;
-	struct snd_pcm_substream *pstream = NULL;
-	struct snd_compr_stream *cstream = NULL;
-
-	map = ctx->pdata->pdev_strm_map;
-	map_size = ctx->pdata->strm_map_size;
-
-	if (is_compress == true)
-		cstream = (struct snd_compr_stream *)substream;
-	else
-		pstream = (struct snd_pcm_substream *)substream;
-
-	str_params->stream_type = SST_STREAM_TYPE_MUSIC;
-
-	/* For pcm streams */
-	if (pstream) {
-		index = sst_get_stream_mapping(pstream->pcm->device,
-					  pstream->number, pstream->stream,
-					  map, map_size);
-		if (index <= 0)
-			return -EINVAL;
-
-		str_params->stream_id = index;
-		str_params->device_type = map[index].device_id;
-		str_params->task = map[index].task_id;
-
-		str_params->ops = (u8)pstream->stream;
-	}
-
-	if (cstream) {
-		index = sst_get_stream_mapping(cstream->device->device,
-					       0, cstream->direction,
-					       map, map_size);
-		if (index <= 0)
-			return -EINVAL;
-		str_params->stream_id = index;
-		str_params->device_type = map[index].device_id;
-		str_params->task = map[index].task_id;
 
-		str_params->ops = (u8)cstream->direction;
-	}
-	return 0;
+	param->num_chan = (u8) substream->runtime->channels;
+	param->pcm_wd_sz = substream->runtime->sample_bits;
+	param->reserved = 0;
+	param->sfreq = substream->runtime->rate;
+	param->ring_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	param->period_count = substream->runtime->period_size;
+	param->ring_buffer_addr = virt_to_phys(substream->dma_buffer.area);
+	pr_debug("period_cnt = %d\n", param->period_count);
+	pr_debug("sfreq= %d, wd_sz = %d\n", param->sfreq, param->pcm_wd_sz);
 }
 
-static int sst_platform_alloc_stream(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
+static int sst_platform_alloc_stream(struct snd_pcm_substream *substream)
 {
 	struct sst_runtime_stream *stream =
 			substream->runtime->private_data;
-	struct snd_sst_stream_params param = {{{0,},},};
-	struct snd_sst_params str_params = {0};
-	struct snd_sst_alloc_params_ext alloc_params = {0};
-	int ret_val = 0;
-	struct sst_data *ctx = snd_soc_dai_get_drvdata(dai);
+	struct sst_pcm_params param = {0};
+	struct sst_stream_params str_params = {0};
+	int ret_val;
 
 	/* set codec params and inform SST driver the same */
 	sst_fill_pcm_params(substream, &param);
-	sst_fill_alloc_params(substream, &alloc_params);
 	substream->runtime->dma_area = substream->dma_buffer.area;
 	str_params.sparams = param;
-	str_params.aparams = alloc_params;
-	str_params.codec = SST_CODEC_TYPE_PCM;
-
-	/* fill the device type and stream id to pass to SST driver */
-	ret_val = sst_fill_stream_params(substream, ctx, &str_params, false);
+	str_params.codec =  param.codec;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		str_params.ops = STREAM_OPS_PLAYBACK;
+		str_params.device_type = substream->pcm->device + 1;
+		pr_debug("Playbck stream,Device %d\n",
+					substream->pcm->device);
+	} else {
+		str_params.ops = STREAM_OPS_CAPTURE;
+		str_params.device_type = SND_SST_DEVICE_CAPTURE;
+		pr_debug("Capture stream,Device %d\n",
+					substream->pcm->device);
+	}
+	ret_val = stream->ops->open(&str_params);
+	pr_debug("SST_SND_PLAY/CAPTURE ret_val = %x\n", ret_val);
 	if (ret_val < 0)
 		return ret_val;
 
-	stream->stream_info.str_id = str_params.stream_id;
-
-	ret_val = stream->ops->open(sst->dev, &str_params);
-	if (ret_val <= 0)
-		return ret_val;
-
-
+	stream->stream_info.str_id = ret_val;
+	pr_debug("str id :  %d\n", stream->stream_info.str_id);
 	return ret_val;
 }
 
-static void sst_period_elapsed(void *arg)
+static void sst_period_elapsed(void *mad_substream)
 {
-	struct snd_pcm_substream *substream = arg;
+	struct snd_pcm_substream *substream = mad_substream;
 	struct sst_runtime_stream *stream;
 	int status;
 
@@ -282,38 +213,36 @@
 {
 	struct sst_runtime_stream *stream =
 			substream->runtime->private_data;
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	int ret_val;
 
-	dev_dbg(rtd->dev, "setting buffer ptr param\n");
+	pr_debug("setting buffer ptr param\n");
 	sst_set_stream_status(stream, SST_PLATFORM_INIT);
 	stream->stream_info.period_elapsed = sst_period_elapsed;
-	stream->stream_info.arg = substream;
+	stream->stream_info.mad_substream = substream;
 	stream->stream_info.buffer_ptr = 0;
 	stream->stream_info.sfreq = substream->runtime->rate;
-	ret_val = stream->ops->stream_init(sst->dev, &stream->stream_info);
+	ret_val = stream->ops->device_control(
+			SST_SND_STREAM_INIT, &stream->stream_info);
 	if (ret_val)
-		dev_err(rtd->dev, "control_set ret error %d\n", ret_val);
+		pr_err("control_set ret error %d\n", ret_val);
 	return ret_val;
 
 }
+/* end -- helper functions */
 
-static int power_up_sst(struct sst_runtime_stream *stream)
-{
-	return stream->ops->power(sst->dev, true);
-}
-
-static void power_down_sst(struct sst_runtime_stream *stream)
-{
-	stream->ops->power(sst->dev, false);
-}
-
-static int sst_media_open(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
+static int sst_platform_open(struct snd_pcm_substream *substream)
 {
-	int ret_val = 0;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sst_runtime_stream *stream;
+	int ret_val;
+
+	pr_debug("sst_platform_open called\n");
+
+	snd_soc_set_runtime_hwparams(substream, &sst_platform_pcm_hw);
+	ret_val = snd_pcm_hw_constraint_integer(runtime,
+						SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret_val < 0)
+		return ret_val;
 
 	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
 	if (!stream)
@@ -322,85 +251,60 @@
 
 	/* get the sst ops */
 	mutex_lock(&sst_lock);
-	if (!sst ||
-	    !try_module_get(sst->dev->driver->owner)) {
-		dev_err(dai->dev, "no device available to run\n");
-		ret_val = -ENODEV;
-		goto out_ops;
+	if (!sst) {
+		pr_err("no device available to run\n");
+		mutex_unlock(&sst_lock);
+		kfree(stream);
+		return -ENODEV;
+	}
+	if (!try_module_get(sst->dev->driver->owner)) {
+		mutex_unlock(&sst_lock);
+		kfree(stream);
+		return -ENODEV;
 	}
 	stream->ops = sst->ops;
 	mutex_unlock(&sst_lock);
 
 	stream->stream_info.str_id = 0;
-
-	stream->stream_info.arg = substream;
+	sst_set_stream_status(stream, SST_PLATFORM_INIT);
+	stream->stream_info.mad_substream = substream;
 	/* allocate memory for SST API set */
 	runtime->private_data = stream;
 
-	ret_val = power_up_sst(stream);
-	if (ret_val < 0)
-		return ret_val;
-
-	/* Make sure, that the period size is always even */
-	snd_pcm_hw_constraint_step(substream->runtime, 0,
-			   SNDRV_PCM_HW_PARAM_PERIODS, 2);
-
-	return snd_pcm_hw_constraint_integer(runtime,
-			 SNDRV_PCM_HW_PARAM_PERIODS);
-out_ops:
-	kfree(stream);
-	mutex_unlock(&sst_lock);
-	return ret_val;
+	return 0;
 }
 
-static void sst_media_close(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
+static int sst_platform_close(struct snd_pcm_substream *substream)
 {
 	struct sst_runtime_stream *stream;
 	int ret_val = 0, str_id;
 
+	pr_debug("sst_platform_close called\n");
 	stream = substream->runtime->private_data;
-	power_down_sst(stream);
-
 	str_id = stream->stream_info.str_id;
 	if (str_id)
-		ret_val = stream->ops->close(sst->dev, str_id);
+		ret_val = stream->ops->close(str_id);
 	module_put(sst->dev->driver->owner);
 	kfree(stream);
+	return ret_val;
 }
 
-static inline unsigned int get_current_pipe_id(struct snd_soc_dai *dai,
-					       struct snd_pcm_substream *substream)
-{
-	struct sst_data *sst = snd_soc_dai_get_drvdata(dai);
-	struct sst_dev_stream_map *map = sst->pdata->pdev_strm_map;
-	struct sst_runtime_stream *stream =
-			substream->runtime->private_data;
-	u32 str_id = stream->stream_info.str_id;
-	unsigned int pipe_id;
-
-	pipe_id = map[str_id].device_id;
-
-	dev_dbg(dai->dev, "got pipe_id = %#x for str_id = %d\n",
-			pipe_id, str_id);
-	return pipe_id;
-}
-
-static int sst_media_prepare(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
+static int sst_platform_pcm_prepare(struct snd_pcm_substream *substream)
 {
 	struct sst_runtime_stream *stream;
 	int ret_val = 0, str_id;
 
+	pr_debug("sst_platform_pcm_prepare called\n");
 	stream = substream->runtime->private_data;
 	str_id = stream->stream_info.str_id;
 	if (stream->stream_info.str_id) {
-		ret_val = stream->ops->stream_drop(sst->dev, str_id);
+		ret_val = stream->ops->device_control(
+				SST_SND_DROP, &str_id);
 		return ret_val;
 	}
 
-	ret_val = sst_platform_alloc_stream(substream, dai);
-	if (ret_val <= 0)
+	ret_val = sst_platform_alloc_stream(substream);
+	if (ret_val < 0)
 		return ret_val;
 	snprintf(substream->pcm->id, sizeof(substream->pcm->id),
 			"%d", stream->stream_info.str_id);
@@ -412,201 +316,42 @@
 	return ret_val;
 }
 
-static int sst_media_hw_params(struct snd_pcm_substream *substream,
-				struct snd_pcm_hw_params *params,
-				struct snd_soc_dai *dai)
-{
-	snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
-	memset(substream->runtime->dma_area, 0, params_buffer_bytes(params));
-	return 0;
-}
-
-static int sst_media_hw_free(struct snd_pcm_substream *substream,
-		struct snd_soc_dai *dai)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
-static int sst_enable_ssp(struct snd_pcm_substream *substream,
-			struct snd_soc_dai *dai)
-{
-	int ret = 0;
-
-	if (!dai->active) {
-		ret = sst_handle_vb_timer(dai, true);
-		if (ret)
-			return ret;
-		ret = send_ssp_cmd(dai, dai->name, 1);
-	}
-	return ret;
-}
-
-static void sst_disable_ssp(struct snd_pcm_substream *substream,
-			struct snd_soc_dai *dai)
-{
-	if (!dai->active) {
-		send_ssp_cmd(dai, dai->name, 0);
-		sst_handle_vb_timer(dai, false);
-	}
-}
-
-static struct snd_soc_dai_ops sst_media_dai_ops = {
-	.startup = sst_media_open,
-	.shutdown = sst_media_close,
-	.prepare = sst_media_prepare,
-	.hw_params = sst_media_hw_params,
-	.hw_free = sst_media_hw_free,
-	.mute_stream = sst_media_digital_mute,
-};
-
-static struct snd_soc_dai_ops sst_compr_dai_ops = {
-	.mute_stream = sst_media_digital_mute,
-};
-
-static struct snd_soc_dai_ops sst_be_dai_ops = {
-	.startup = sst_enable_ssp,
-	.shutdown = sst_disable_ssp,
-};
-
-static struct snd_soc_dai_driver sst_platform_dai[] = {
-{
-	.name = "media-cpu-dai",
-	.ops = &sst_media_dai_ops,
-	.playback = {
-		.stream_name = "Headset Playback",
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-	.capture = {
-		.stream_name = "Headset Capture",
-		.channels_min = 1,
-		.channels_max = 2,
-		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-},
-{
-	.name = "compress-cpu-dai",
-	.compress_dai = 1,
-	.ops = &sst_compr_dai_ops,
-	.playback = {
-		.stream_name = "Compress Playback",
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-},
-/* BE CPU  Dais */
-{
-	.name = "ssp0-port",
-	.ops = &sst_be_dai_ops,
-	.playback = {
-		.stream_name = "ssp0 Tx",
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-	.capture = {
-		.stream_name = "ssp0 Rx",
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-},
-{
-	.name = "ssp1-port",
-	.ops = &sst_be_dai_ops,
-	.playback = {
-		.stream_name = "ssp1 Tx",
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-	.capture = {
-		.stream_name = "ssp1 Rx",
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-},
-{
-	.name = "ssp2-port",
-	.ops = &sst_be_dai_ops,
-	.playback = {
-		.stream_name = "ssp2 Tx",
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-	.capture = {
-		.stream_name = "ssp2 Rx",
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-},
-};
-
-static int sst_platform_open(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime;
-
-	if (substream->pcm->internal)
-		return 0;
-
-	runtime = substream->runtime;
-	runtime->hw = sst_platform_pcm_hw;
-	return 0;
-}
-
 static int sst_platform_pcm_trigger(struct snd_pcm_substream *substream,
 					int cmd)
 {
 	int ret_val = 0, str_id;
 	struct sst_runtime_stream *stream;
-	int status;
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int str_cmd, status;
 
-	dev_dbg(rtd->dev, "sst_platform_pcm_trigger called\n");
-	if (substream->pcm->internal)
-		return 0;
+	pr_debug("sst_platform_pcm_trigger called\n");
 	stream = substream->runtime->private_data;
 	str_id = stream->stream_info.str_id;
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		dev_dbg(rtd->dev, "sst: Trigger Start\n");
+		pr_debug("sst: Trigger Start\n");
+		str_cmd = SST_SND_START;
 		status = SST_PLATFORM_RUNNING;
-		stream->stream_info.arg = substream;
-		ret_val = stream->ops->stream_start(sst->dev, str_id);
+		stream->stream_info.mad_substream = substream;
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-		dev_dbg(rtd->dev, "sst: in stop\n");
+		pr_debug("sst: in stop\n");
+		str_cmd = SST_SND_DROP;
 		status = SST_PLATFORM_DROPPED;
-		ret_val = stream->ops->stream_drop(sst->dev, str_id);
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		dev_dbg(rtd->dev, "sst: in pause\n");
+		pr_debug("sst: in pause\n");
+		str_cmd = SST_SND_PAUSE;
 		status = SST_PLATFORM_PAUSED;
-		ret_val = stream->ops->stream_pause(sst->dev, str_id);
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		dev_dbg(rtd->dev, "sst: in pause release\n");
+		pr_debug("sst: in pause release\n");
+		str_cmd = SST_SND_RESUME;
 		status = SST_PLATFORM_RUNNING;
-		ret_val = stream->ops->stream_pause_release(sst->dev, str_id);
 		break;
 	default:
 		return -EINVAL;
 	}
-
+	ret_val = stream->ops->device_control(str_cmd, &str_id);
 	if (!ret_val)
 		sst_set_stream_status(stream, status);
 
@@ -620,62 +365,73 @@
 	struct sst_runtime_stream *stream;
 	int ret_val, status;
 	struct pcm_stream_info *str_info;
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 
 	stream = substream->runtime->private_data;
 	status = sst_get_stream_status(stream);
 	if (status == SST_PLATFORM_INIT)
 		return 0;
 	str_info = &stream->stream_info;
-	ret_val = stream->ops->stream_read_tstamp(sst->dev, str_info);
+	ret_val = stream->ops->device_control(
+				SST_SND_BUFFER_POINTER, str_info);
 	if (ret_val) {
-		dev_err(rtd->dev, "sst: error code = %d\n", ret_val);
+		pr_err("sst: error code = %d\n", ret_val);
 		return ret_val;
 	}
-	substream->runtime->delay = str_info->pcm_delay;
-	return str_info->buffer_ptr;
+	return stream->stream_info.buffer_ptr;
+}
+
+static int sst_platform_pcm_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+	memset(substream->runtime->dma_area, 0, params_buffer_bytes(params));
+
+	return 0;
+}
+
+static int sst_platform_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
 }
 
 static struct snd_pcm_ops sst_platform_ops = {
 	.open = sst_platform_open,
+	.close = sst_platform_close,
 	.ioctl = snd_pcm_lib_ioctl,
+	.prepare = sst_platform_pcm_prepare,
 	.trigger = sst_platform_pcm_trigger,
 	.pointer = sst_platform_pcm_pointer,
+	.hw_params = sst_platform_pcm_hw_params,
+	.hw_free = sst_platform_pcm_hw_free,
 };
 
 static void sst_pcm_free(struct snd_pcm *pcm)
 {
-	dev_dbg(pcm->dev, "sst_pcm_free called\n");
+	pr_debug("sst_pcm_free called\n");
 	snd_pcm_lib_preallocate_free_for_all(pcm);
 }
 
 static int sst_pcm_new(struct snd_soc_pcm_runtime *rtd)
 {
-	struct snd_soc_dai *dai = rtd->cpu_dai;
 	struct snd_pcm *pcm = rtd->pcm;
 	int retval = 0;
 
-	if (dai->driver->playback.channels_min ||
-			dai->driver->capture.channels_min) {
+	pr_debug("sst_pcm_new called\n");
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream ||
+			pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
 		retval =  snd_pcm_lib_preallocate_pages_for_all(pcm,
 			SNDRV_DMA_TYPE_CONTINUOUS,
-			snd_dma_continuous_data(GFP_DMA),
+			snd_dma_continuous_data(GFP_KERNEL),
 			SST_MIN_BUFFER, SST_MAX_BUFFER);
 		if (retval) {
-			dev_err(rtd->dev, "dma buffer allocationf fail\n");
+			pr_err("dma buffer allocationf fail\n");
 			return retval;
 		}
 	}
 	return retval;
 }
 
-static int sst_soc_probe(struct snd_soc_platform *platform)
-{
-	return sst_dsp_init_v2_dpcm(platform);
-}
-
-static struct snd_soc_platform_driver sst_soc_platform_drv  = {
-	.probe		= sst_soc_probe,
+static struct snd_soc_platform_driver sst_soc_platform_drv = {
 	.ops		= &sst_platform_ops,
 	.compr_ops	= &sst_platform_compr_ops,
 	.pcm_new	= sst_pcm_new,
@@ -689,37 +445,20 @@
 
 static int sst_platform_probe(struct platform_device *pdev)
 {
-	struct sst_data *drv;
 	int ret;
-	struct sst_platform_data *pdata;
-
-	drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);
-	if (drv == NULL) {
-		return -ENOMEM;
-	}
-
-	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
-	if (pdata == NULL) {
-		return -ENOMEM;
-	}
-
-	pdata->pdev_strm_map = dpcm_strm_map;
-	pdata->strm_map_size = ARRAY_SIZE(dpcm_strm_map);
-	drv->pdata = pdata;
-	drv->pdev = pdev;
-	mutex_init(&drv->lock);
-	dev_set_drvdata(&pdev->dev, drv);
 
+	pr_debug("sst_platform_probe called\n");
+	sst = NULL;
 	ret = snd_soc_register_platform(&pdev->dev, &sst_soc_platform_drv);
 	if (ret) {
-		dev_err(&pdev->dev, "registering soc platform failed\n");
+		pr_err("registering soc platform failed\n");
 		return ret;
 	}
 
 	ret = snd_soc_register_component(&pdev->dev, &sst_component,
 				sst_platform_dai, ARRAY_SIZE(sst_platform_dai));
 	if (ret) {
-		dev_err(&pdev->dev, "registering cpu dais failed\n");
+		pr_err("registering cpu dais failed\n");
 		snd_soc_unregister_platform(&pdev->dev);
 	}
 	return ret;
@@ -730,13 +469,14 @@
 
 	snd_soc_unregister_component(&pdev->dev);
 	snd_soc_unregister_platform(&pdev->dev);
-	dev_dbg(&pdev->dev, "sst_platform_remove success\n");
+	pr_debug("sst_platform_remove success\n");
 	return 0;
 }
 
 static struct platform_driver sst_platform_driver = {
 	.driver		= {
 		.name		= "sst-mfld-platform",
+		.owner		= THIS_MODULE,
 	},
 	.probe		= sst_platform_probe,
 	.remove		= sst_platform_remove,
diff -Naur linux-3.19.old/sound/soc/Makefile linux-3.19/sound/soc/Makefile
--- linux-3.19.old/sound/soc/Makefile	2015-03-24 17:38:13.583176983 -0800
+++ linux-3.19/sound/soc/Makefile	2015-03-24 18:47:23.614714074 -0800
@@ -1,5 +1,5 @@
 snd-soc-core-objs := soc-core.o soc-dapm.o soc-jack.o soc-cache.o soc-utils.o
-snd-soc-core-objs += soc-pcm.o soc-compress.o soc-io.o soc-devres.o soc-ops.o
+snd-soc-core-objs += soc-pcm.o soc-compress.o soc-io.o soc-devres.o
 
 ifneq ($(CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM),)
 snd-soc-core-objs += soc-generic-dmaengine-pcm.o
diff -Naur linux-3.19.old/sound/soc/soc-cache.c linux-3.19/sound/soc/soc-cache.c
--- linux-3.19.old/sound/soc/soc-cache.c	2015-03-24 17:38:14.643176937 -0800
+++ linux-3.19/sound/soc/soc-cache.c	2015-03-24 18:40:57.358035890 -0800
@@ -15,6 +15,56 @@
 #include <linux/export.h>
 #include <linux/slab.h>
 
+#include <trace/events/asoc.h>
+
+static bool snd_soc_set_cache_val(void *base, unsigned int idx,
+				  unsigned int val, unsigned int word_size)
+{
+	switch (word_size) {
+	case 1: {
+		u8 *cache = base;
+		if (cache[idx] == val)
+			return true;
+		cache[idx] = val;
+		break;
+	}
+	case 2: {
+		u16 *cache = base;
+		if (cache[idx] == val)
+			return true;
+		cache[idx] = val;
+		break;
+	}
+	default:
+		WARN(1, "Invalid word_size %d\n", word_size);
+		break;
+	}
+	return false;
+}
+
+static unsigned int snd_soc_get_cache_val(const void *base, unsigned int idx,
+		unsigned int word_size)
+{
+	if (!base)
+		return -1;
+
+	switch (word_size) {
+	case 1: {
+		const u8 *cache = base;
+		return cache[idx];
+	}
+	case 2: {
+		const u16 *cache = base;
+		return cache[idx];
+	}
+	default:
+		WARN(1, "Invalid word_size %d\n", word_size);
+		break;
+	}
+	/* unreachable */
+	return -1;
+}
+
 int snd_soc_cache_init(struct snd_soc_codec *codec)
 {
 	const struct snd_soc_codec_driver *codec_drv = codec->driver;
@@ -25,6 +75,8 @@
 	if (!reg_size)
 		return 0;
 
+	mutex_init(&codec->cache_rw_mutex);
+
 	dev_dbg(codec->dev, "ASoC: Initializing cache for %s codec\n",
 				codec->component.name);
 
@@ -51,3 +103,98 @@
 	codec->reg_cache = NULL;
 	return 0;
 }
+
+/**
+ * snd_soc_cache_read: Fetch the value of a given register from the cache.
+ *
+ * @codec: CODEC to configure.
+ * @reg: The register index.
+ * @value: The value to be returned.
+ */
+int snd_soc_cache_read(struct snd_soc_codec *codec,
+		       unsigned int reg, unsigned int *value)
+{
+	if (!value)
+		return -EINVAL;
+
+	mutex_lock(&codec->cache_rw_mutex);
+	if (!ZERO_OR_NULL_PTR(codec->reg_cache))
+		*value = snd_soc_get_cache_val(codec->reg_cache, reg,
+					       codec->driver->reg_word_size);
+	mutex_unlock(&codec->cache_rw_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_cache_read);
+
+/**
+ * snd_soc_cache_write: Set the value of a given register in the cache.
+ *
+ * @codec: CODEC to configure.
+ * @reg: The register index.
+ * @value: The new register value.
+ */
+int snd_soc_cache_write(struct snd_soc_codec *codec,
+			unsigned int reg, unsigned int value)
+{
+	mutex_lock(&codec->cache_rw_mutex);
+	if (!ZERO_OR_NULL_PTR(codec->reg_cache))
+		snd_soc_set_cache_val(codec->reg_cache, reg, value,
+				      codec->driver->reg_word_size);
+	mutex_unlock(&codec->cache_rw_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_cache_write);
+
+static int snd_soc_flat_cache_sync(struct snd_soc_codec *codec)
+{
+	int i;
+	int ret;
+	const struct snd_soc_codec_driver *codec_drv;
+	unsigned int val;
+
+	codec_drv = codec->driver;
+	for (i = 0; i < codec_drv->reg_cache_size; ++i) {
+		ret = snd_soc_cache_read(codec, i, &val);
+		if (ret)
+			return ret;
+		if (codec_drv->reg_cache_default)
+			if (snd_soc_get_cache_val(codec_drv->reg_cache_default,
+						  i, codec_drv->reg_word_size) == val)
+				continue;
+
+		ret = snd_soc_write(codec, i, val);
+		if (ret)
+			return ret;
+		dev_dbg(codec->dev, "ASoC: Synced register %#x, value = %#x\n",
+			i, val);
+	}
+	return 0;
+}
+
+/**
+ * snd_soc_cache_sync: Sync the register cache with the hardware.
+ *
+ * @codec: CODEC to configure.
+ *
+ * Any registers that should not be synced should be marked as
+ * volatile.  In general drivers can choose not to use the provided
+ * syncing functionality if they so require.
+ */
+int snd_soc_cache_sync(struct snd_soc_codec *codec)
+{
+	const char *name = "flat";
+	int ret;
+
+	if (!codec->cache_sync)
+		return 0;
+
+	dev_dbg(codec->dev, "ASoC: Syncing cache for %s codec\n",
+		codec->component.name);
+	ret = snd_soc_flat_cache_sync(codec);
+	if (!ret)
+		codec->cache_sync = 0;
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_cache_sync);
diff -Naur linux-3.19.old/sound/soc/soc-compress.c linux-3.19/sound/soc/soc-compress.c
--- linux-3.19.old/sound/soc/soc-compress.c	2015-03-24 17:38:14.643176937 -0800
+++ linux-3.19/sound/soc/soc-compress.c	2015-03-24 18:36:44.528028363 -0800
@@ -101,12 +101,10 @@
 
 	fe->dpcm[stream].runtime = fe_substream->runtime;
 
-	ret = dpcm_path_get(fe, stream, &list);
-	if (ret < 0)
-		goto fe_err;
-	else if (ret == 0)
+	if (dpcm_path_get(fe, stream, &list) <= 0) {
 		dev_dbg(fe->dev, "ASoC: %s no valid %s route\n",
 			fe->dai_link->name, stream ? "capture" : "playback");
+	}
 
 	/* calculate valid and active FE <-> BE dpcms */
 	dpcm_process_paths(fe, stream, &list, 1);
@@ -258,7 +256,10 @@
 	list_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)
 		dpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;
 
-	dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
+	else
+		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
 
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;
 	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
@@ -453,7 +454,11 @@
 	if (ret < 0)
 		goto out;
 
-	dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);
+	else
+		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);
+
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;
 
 out:
@@ -659,8 +664,7 @@
 			rtd->dai_link->stream_name);
 
 		ret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,
-				rtd->dai_link->dpcm_playback,
-				rtd->dai_link->dpcm_capture, &be_pcm);
+				1, 0, &be_pcm);
 		if (ret < 0) {
 			dev_err(rtd->card->dev, "ASoC: can't create compressed for %s\n",
 				rtd->dai_link->name);
@@ -669,10 +673,8 @@
 
 		rtd->pcm = be_pcm;
 		rtd->fe_compr = 1;
-		if (rtd->dai_link->dpcm_playback)
-			be_pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;
-		else if (rtd->dai_link->dpcm_capture)
-			be_pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;
+		be_pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;
+		be_pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;
 		memcpy(compr->ops, &soc_compr_dyn_ops, sizeof(soc_compr_dyn_ops));
 	} else
 		memcpy(compr->ops, &soc_compr_ops, sizeof(soc_compr_ops));
diff -Naur linux-3.19.old/sound/soc/soc-core.c linux-3.19/sound/soc/soc-core.c
--- linux-3.19.old/sound/soc/soc-core.c	2015-03-24 17:38:14.649843604 -0800
+++ linux-3.19/sound/soc/soc-core.c	2015-03-24 18:36:44.528028363 -0800
@@ -34,6 +34,9 @@
 #include <linux/ctype.h>
 #include <linux/slab.h>
 #include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <sound/ac97_codec.h>
 #include <sound/core.h>
 #include <sound/jack.h>
 #include <sound/pcm.h>
@@ -66,6 +69,16 @@
 module_param(pmdown_time, int, 0);
 MODULE_PARM_DESC(pmdown_time, "DAPM stream powerdown time (msecs)");
 
+struct snd_ac97_reset_cfg {
+	struct pinctrl *pctl;
+	struct pinctrl_state *pstate_reset;
+	struct pinctrl_state *pstate_warm_reset;
+	struct pinctrl_state *pstate_run;
+	int gpio_sdata;
+	int gpio_sync;
+	int gpio_reset;
+};
+
 /* returns the minimum number of bytes needed to represent
  * a particular given value */
 static int min_bytes_needed(unsigned long val)
@@ -257,51 +270,79 @@
 	.llseek = default_llseek,
 };
 
-static void soc_init_component_debugfs(struct snd_soc_component *component)
+static struct dentry *soc_debugfs_create_dir(struct dentry *parent,
+	const char *fmt, ...)
 {
-	if (component->debugfs_prefix) {
-		char *name;
-
-		name = kasprintf(GFP_KERNEL, "%s:%s",
-			component->debugfs_prefix, component->name);
-		if (name) {
-			component->debugfs_root = debugfs_create_dir(name,
-				component->card->debugfs_card_root);
-			kfree(name);
-		}
-	} else {
-		component->debugfs_root = debugfs_create_dir(component->name,
-				component->card->debugfs_card_root);
-	}
+	struct dentry *de;
+	va_list ap;
+	char *s;
+
+	va_start(ap, fmt);
+	s = kvasprintf(GFP_KERNEL, fmt, ap);
+	va_end(ap);
 
-	if (!component->debugfs_root) {
-		dev_warn(component->dev,
-			"ASoC: Failed to create component debugfs directory\n");
-		return;
-	}
+	if (!s)
+		return NULL;
 
-	snd_soc_dapm_debugfs_init(snd_soc_component_get_dapm(component),
-		component->debugfs_root);
+	de = debugfs_create_dir(s, parent);
+	kfree(s);
 
-	if (component->init_debugfs)
-		component->init_debugfs(component);
+	return de;
 }
 
-static void soc_cleanup_component_debugfs(struct snd_soc_component *component)
+static void soc_init_codec_debugfs(struct snd_soc_codec *codec)
 {
-	debugfs_remove_recursive(component->debugfs_root);
-}
+	struct dentry *debugfs_card_root = codec->component.card->debugfs_card_root;
 
-static void soc_init_codec_debugfs(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
+	codec->debugfs_codec_root = soc_debugfs_create_dir(debugfs_card_root,
+						"codec:%s",
+						codec->component.name);
+	if (!codec->debugfs_codec_root) {
+		dev_warn(codec->dev,
+			"ASoC: Failed to create codec debugfs directory\n");
+		return;
+	}
+
+	debugfs_create_bool("cache_sync", 0444, codec->debugfs_codec_root,
+			    &codec->cache_sync);
+	debugfs_create_bool("cache_only", 0444, codec->debugfs_codec_root,
+			    &codec->cache_only);
 
 	codec->debugfs_reg = debugfs_create_file("codec_reg", 0644,
-						 codec->component.debugfs_root,
+						 codec->debugfs_codec_root,
 						 codec, &codec_reg_fops);
 	if (!codec->debugfs_reg)
 		dev_warn(codec->dev,
 			"ASoC: Failed to create codec register debugfs file\n");
+
+	snd_soc_dapm_debugfs_init(&codec->dapm, codec->debugfs_codec_root);
+}
+
+static void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
+{
+	debugfs_remove_recursive(codec->debugfs_codec_root);
+}
+
+static void soc_init_platform_debugfs(struct snd_soc_platform *platform)
+{
+	struct dentry *debugfs_card_root = platform->component.card->debugfs_card_root;
+
+	platform->debugfs_platform_root = soc_debugfs_create_dir(debugfs_card_root,
+						"platform:%s",
+						platform->component.name);
+	if (!platform->debugfs_platform_root) {
+		dev_warn(platform->dev,
+			"ASoC: Failed to create platform debugfs directory\n");
+		return;
+	}
+
+	snd_soc_dapm_debugfs_init(&platform->component.dapm,
+		platform->debugfs_platform_root);
+}
+
+static void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform)
+{
+	debugfs_remove_recursive(platform->debugfs_platform_root);
 }
 
 static ssize_t codec_list_read_file(struct file *file, char __user *user_buf,
@@ -433,15 +474,19 @@
 
 #else
 
-#define soc_init_codec_debugfs NULL
+static inline void soc_init_codec_debugfs(struct snd_soc_codec *codec)
+{
+}
+
+static inline void soc_cleanup_codec_debugfs(struct snd_soc_codec *codec)
+{
+}
 
-static inline void soc_init_component_debugfs(
-	struct snd_soc_component *component)
+static inline void soc_init_platform_debugfs(struct snd_soc_platform *platform)
 {
 }
 
-static inline void soc_cleanup_component_debugfs(
-	struct snd_soc_component *component)
+static inline void soc_cleanup_platform_debugfs(struct snd_soc_platform *platform)
 {
 }
 
@@ -483,6 +528,40 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);
 
+#ifdef CONFIG_SND_SOC_AC97_BUS
+/* unregister ac97 codec */
+static int soc_ac97_dev_unregister(struct snd_soc_codec *codec)
+{
+	if (codec->ac97->dev.bus)
+		device_unregister(&codec->ac97->dev);
+	return 0;
+}
+
+/* stop no dev release warning */
+static void soc_ac97_device_release(struct device *dev){}
+
+/* register ac97 codec to bus */
+static int soc_ac97_dev_register(struct snd_soc_codec *codec)
+{
+	int err;
+
+	codec->ac97->dev.bus = &ac97_bus_type;
+	codec->ac97->dev.parent = codec->component.card->dev;
+	codec->ac97->dev.release = soc_ac97_device_release;
+
+	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
+		     codec->component.card->snd_card->number, 0,
+		     codec->component.name);
+	err = device_register(&codec->ac97->dev);
+	if (err < 0) {
+		dev_err(codec->dev, "ASoC: Can't register ac97 bus\n");
+		codec->ac97->dev.bus = NULL;
+		return err;
+	}
+	return 0;
+}
+#endif
+
 static void codec2codec_close_delayed_work(struct work_struct *work)
 {
 	/* Currently nothing to do for c2c links
@@ -500,8 +579,10 @@
 	struct snd_soc_codec *codec;
 	int i, j;
 
-	/* If the card is not initialized yet there is nothing to do */
-	if (!card->instantiated)
+	/* If the initialization of this soc device failed, there is no codec
+	 * associated with it. Just bail out in this case.
+	 */
+	if (list_empty(&card->codec_dev_list))
 		return 0;
 
 	/* Due to the resume being scheduled into a workqueue we could
@@ -542,12 +623,17 @@
 
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_platform *platform = card->rtd[i].platform;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->suspend && !cpu_dai->driver->bus_control)
+		if (cpu_dai->driver->suspend && !cpu_dai->driver->ac97_control)
 			cpu_dai->driver->suspend(cpu_dai);
+		if (platform->driver->suspend && !platform->suspended) {
+			platform->driver->suspend(cpu_dai);
+			platform->suspended = 1;
+		}
 	}
 
 	/* close any waiting streams and save state */
@@ -574,15 +660,15 @@
 					  SND_SOC_DAPM_STREAM_SUSPEND);
 	}
 
-	/* Recheck all endpoints too, their state is affected by suspend */
-	dapm_mark_endpoints_dirty(card);
+	/* Recheck all analogue paths too */
+	dapm_mark_io_dirty(&card->dapm);
 	snd_soc_dapm_sync(&card->dapm);
 
 	/* suspend all CODECs */
 	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
 		/* If there are paths active then the CODEC will be held with
 		 * bias _ON and should not be suspended. */
-		if (!codec->suspended) {
+		if (!codec->suspended && codec->driver->suspend) {
 			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
 				/*
@@ -596,11 +682,10 @@
 						"ASoC: idle_bias_off CODEC on over suspend\n");
 					break;
 				}
-
 			case SND_SOC_BIAS_OFF:
-				if (codec->driver->suspend)
-					codec->driver->suspend(codec);
+				codec->driver->suspend(codec);
 				codec->suspended = 1;
+				codec->cache_sync = 1;
 				if (codec->component.regmap)
 					regcache_mark_dirty(codec->component.regmap);
 				/* deactivate pins to sleep state */
@@ -620,7 +705,7 @@
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->suspend && cpu_dai->driver->bus_control)
+		if (cpu_dai->driver->suspend && cpu_dai->driver->ac97_control)
 			cpu_dai->driver->suspend(cpu_dai);
 
 		/* deactivate pins to sleep state */
@@ -656,14 +741,14 @@
 	if (card->resume_pre)
 		card->resume_pre(card);
 
-	/* resume control bus DAIs */
+	/* resume AC97 DAIs */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->resume && cpu_dai->driver->bus_control)
+		if (cpu_dai->driver->resume && cpu_dai->driver->ac97_control)
 			cpu_dai->driver->resume(cpu_dai);
 	}
 
@@ -672,12 +757,11 @@
 		 * left with bias OFF or STANDBY and suspended so we must now
 		 * resume.  Otherwise the suspend was suppressed.
 		 */
-		if (codec->suspended) {
+		if (codec->driver->resume && codec->suspended) {
 			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
 			case SND_SOC_BIAS_OFF:
-				if (codec->driver->resume)
-					codec->driver->resume(codec);
+				codec->driver->resume(codec);
 				codec->suspended = 0;
 				break;
 			default:
@@ -719,12 +803,17 @@
 
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
+		struct snd_soc_platform *platform = card->rtd[i].platform;
 
 		if (card->rtd[i].dai_link->ignore_suspend)
 			continue;
 
-		if (cpu_dai->driver->resume && !cpu_dai->driver->bus_control)
+		if (cpu_dai->driver->resume && !cpu_dai->driver->ac97_control)
 			cpu_dai->driver->resume(cpu_dai);
+		if (platform->driver->resume && platform->suspended) {
+			platform->driver->resume(cpu_dai);
+			platform->suspended = 0;
+		}
 	}
 
 	if (card->resume_post)
@@ -735,8 +824,8 @@
 	/* userspace can access us now we are back as we were before */
 	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
 
-	/* Recheck all endpoints too, their state is affected by suspend */
-	dapm_mark_endpoints_dirty(card);
+	/* Recheck all analogue paths too */
+	dapm_mark_io_dirty(&card->dapm);
 	snd_soc_dapm_sync(&card->dapm);
 }
 
@@ -744,11 +833,12 @@
 int snd_soc_resume(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
-	bool bus_control = false;
-	int i;
+	int i, ac97_control = 0;
 
-	/* If the card is not initialized yet there is nothing to do */
-	if (!card->instantiated)
+	/* If the initialization of this soc device failed, there is no codec
+	 * associated with it. Just bail out in this case.
+	 */
+	if (list_empty(&card->codec_dev_list))
 		return 0;
 
 	/* activate pins from sleep state */
@@ -768,18 +858,17 @@
 		}
 	}
 
-	/*
-	 * DAIs that also act as the control bus master might have other drivers
-	 * hanging off them so need to resume immediately. Other drivers don't
-	 * have that problem and may take a substantial amount of time to resume
+	/* AC97 devices might have other drivers hanging off them so
+	 * need to resume immediately.  Other drivers don't have that
+	 * problem and may take a substantial amount of time to resume
 	 * due to I/O costs and anti-pop so handle them out of line.
 	 */
 	for (i = 0; i < card->num_rtd; i++) {
 		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
-		bus_control |= cpu_dai->driver->bus_control;
+		ac97_control |= cpu_dai->driver->ac97_control;
 	}
-	if (bus_control) {
-		dev_dbg(dev, "ASoC: Resuming control bus master immediately\n");
+	if (ac97_control) {
+		dev_dbg(dev, "ASoC: Resuming AC97 immediately\n");
 		soc_resume_deferred(&card->deferred_resume_work);
 	} else {
 		dev_dbg(dev, "ASoC: Scheduling resume work\n");
@@ -798,40 +887,35 @@
 static const struct snd_soc_dai_ops null_dai_ops = {
 };
 
-static struct snd_soc_component *soc_find_component(
-	const struct device_node *of_node, const char *name)
+static struct snd_soc_codec *soc_find_codec(
+					const struct device_node *codec_of_node,
+					const char *codec_name)
 {
-	struct snd_soc_component *component;
+	struct snd_soc_codec *codec;
 
-	list_for_each_entry(component, &component_list, list) {
-		if (of_node) {
-			if (component->dev->of_node == of_node)
-				return component;
-		} else if (strcmp(component->name, name) == 0) {
-			return component;
+	list_for_each_entry(codec, &codec_list, list) {
+		if (codec_of_node) {
+			if (codec->dev->of_node != codec_of_node)
+				continue;
+		} else {
+			if (strcmp(codec->component.name, codec_name))
+				continue;
 		}
+
+		return codec;
 	}
 
 	return NULL;
 }
 
-static struct snd_soc_dai *snd_soc_find_dai(
-	const struct snd_soc_dai_link_component *dlc)
+static struct snd_soc_dai *soc_find_codec_dai(struct snd_soc_codec *codec,
+					      const char *codec_dai_name)
 {
-	struct snd_soc_component *component;
-	struct snd_soc_dai *dai;
-
-	/* Find CPU DAI from registered DAIs*/
-	list_for_each_entry(component, &component_list, list) {
-		if (dlc->of_node && component->dev->of_node != dlc->of_node)
-			continue;
-		if (dlc->name && strcmp(component->name, dlc->name))
-			continue;
-		list_for_each_entry(dai, &component->dai_list, list) {
-			if (dlc->dai_name && strcmp(dai->name, dlc->dai_name))
-				continue;
+	struct snd_soc_dai *codec_dai;
 
-			return dai;
+	list_for_each_entry(codec_dai, &codec->component.dai_list, list) {
+		if (!strcmp(codec_dai->name, codec_dai_name)) {
+			return codec_dai;
 		}
 	}
 
@@ -842,19 +926,33 @@
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_component *component;
 	struct snd_soc_dai_link_component *codecs = dai_link->codecs;
-	struct snd_soc_dai_link_component cpu_dai_component;
 	struct snd_soc_dai **codec_dais = rtd->codec_dais;
 	struct snd_soc_platform *platform;
+	struct snd_soc_dai *cpu_dai;
 	const char *platform_name;
 	int i;
 
 	dev_dbg(card->dev, "ASoC: binding %s at idx %d\n", dai_link->name, num);
 
-	cpu_dai_component.name = dai_link->cpu_name;
-	cpu_dai_component.of_node = dai_link->cpu_of_node;
-	cpu_dai_component.dai_name = dai_link->cpu_dai_name;
-	rtd->cpu_dai = snd_soc_find_dai(&cpu_dai_component);
+	/* Find CPU DAI from registered DAIs*/
+	list_for_each_entry(component, &component_list, list) {
+		if (dai_link->cpu_of_node &&
+			component->dev->of_node != dai_link->cpu_of_node)
+			continue;
+		if (dai_link->cpu_name &&
+			strcmp(dev_name(component->dev), dai_link->cpu_name))
+			continue;
+		list_for_each_entry(cpu_dai, &component->dai_list, list) {
+			if (dai_link->cpu_dai_name &&
+				strcmp(cpu_dai->name, dai_link->cpu_dai_name))
+				continue;
+
+			rtd->cpu_dai = cpu_dai;
+		}
+	}
+
 	if (!rtd->cpu_dai) {
 		dev_err(card->dev, "ASoC: CPU DAI %s not registered\n",
 			dai_link->cpu_dai_name);
@@ -865,7 +963,15 @@
 
 	/* Find CODEC from registered CODECs */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		codec_dais[i] = snd_soc_find_dai(&codecs[i]);
+		struct snd_soc_codec *codec;
+		codec = soc_find_codec(codecs[i].of_node, codecs[i].name);
+		if (!codec) {
+			dev_err(card->dev, "ASoC: CODEC %s not registered\n",
+				codecs[i].name);
+			return -EPROBE_DEFER;
+		}
+
+		codec_dais[i] = soc_find_codec_dai(codec, codecs[i].dai_name);
 		if (!codec_dais[i]) {
 			dev_err(card->dev, "ASoC: CODEC DAI %s not registered\n",
 				codecs[i].dai_name);
@@ -906,46 +1012,68 @@
 	return 0;
 }
 
-static void soc_remove_component(struct snd_soc_component *component)
+static int soc_remove_platform(struct snd_soc_platform *platform)
 {
-	if (!component->probed)
-		return;
+	int ret;
+
+	if (platform->driver->remove) {
+		ret = platform->driver->remove(platform);
+		if (ret < 0)
+			dev_err(platform->dev, "ASoC: failed to remove %d\n",
+				ret);
+	}
+
+	/* Make sure all DAPM widgets are freed */
+	snd_soc_dapm_free(&platform->component.dapm);
+
+	soc_cleanup_platform_debugfs(platform);
+	platform->probed = 0;
+	module_put(platform->dev->driver->owner);
 
-	/* This is a HACK and will be removed soon */
-	if (component->codec)
-		list_del(&component->codec->card_list);
+	return 0;
+}
+
+static void soc_remove_codec(struct snd_soc_codec *codec)
+{
+	int err;
 
-	if (component->remove)
-		component->remove(component);
+	if (codec->driver->remove) {
+		err = codec->driver->remove(codec);
+		if (err < 0)
+			dev_err(codec->dev, "ASoC: failed to remove %d\n", err);
+	}
 
-	snd_soc_dapm_free(snd_soc_component_get_dapm(component));
+	/* Make sure all DAPM widgets are freed */
+	snd_soc_dapm_free(&codec->dapm);
 
-	soc_cleanup_component_debugfs(component);
-	component->probed = 0;
-	module_put(component->dev->driver->owner);
+	soc_cleanup_codec_debugfs(codec);
+	codec->probed = 0;
+	list_del(&codec->card_list);
+	module_put(codec->dev->driver->owner);
 }
 
-static void soc_remove_dai(struct snd_soc_dai *dai, int order)
+static void soc_remove_codec_dai(struct snd_soc_dai *codec_dai, int order)
 {
 	int err;
 
-	if (dai && dai->probed &&
-			dai->driver->remove_order == order) {
-		if (dai->driver->remove) {
-			err = dai->driver->remove(dai);
+	if (codec_dai && codec_dai->probed &&
+			codec_dai->driver->remove_order == order) {
+		if (codec_dai->driver->remove) {
+			err = codec_dai->driver->remove(codec_dai);
 			if (err < 0)
-				dev_err(dai->dev,
+				dev_err(codec_dai->dev,
 					"ASoC: failed to remove %s: %d\n",
-					dai->name, err);
+					codec_dai->name, err);
 		}
-		dai->probed = 0;
+		codec_dai->probed = 0;
 	}
 }
 
 static void soc_remove_link_dais(struct snd_soc_card *card, int num, int order)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
-	int i;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int i, err;
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
@@ -957,9 +1085,22 @@
 
 	/* remove the CODEC DAI */
 	for (i = 0; i < rtd->num_codecs; i++)
-		soc_remove_dai(rtd->codec_dais[i], order);
+		soc_remove_codec_dai(rtd->codec_dais[i], order);
 
-	soc_remove_dai(rtd->cpu_dai, order);
+	/* remove the cpu_dai */
+	if (cpu_dai && cpu_dai->probed &&
+			cpu_dai->driver->remove_order == order) {
+		if (cpu_dai->driver->remove) {
+			err = cpu_dai->driver->remove(cpu_dai);
+			if (err < 0)
+				dev_err(cpu_dai->dev,
+					"ASoC: failed to remove %s: %d\n",
+					cpu_dai->name, err);
+		}
+		cpu_dai->probed = 0;
+		if (!cpu_dai->codec)
+			module_put(cpu_dai->dev->driver->owner);
+	}
 }
 
 static void soc_remove_link_components(struct snd_soc_card *card, int num,
@@ -968,24 +1109,29 @@
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_component *component;
+	struct snd_soc_codec *codec;
 	int i;
 
 	/* remove the platform */
-	if (platform && platform->component.driver->remove_order == order)
-		soc_remove_component(&platform->component);
+	if (platform && platform->probed &&
+	    platform->driver->remove_order == order) {
+		soc_remove_platform(platform);
+	}
 
 	/* remove the CODEC-side CODEC */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		component = rtd->codec_dais[i]->component;
-		if (component->driver->remove_order == order)
-			soc_remove_component(component);
+		codec = rtd->codec_dais[i]->codec;
+		if (codec && codec->probed &&
+		    codec->driver->remove_order == order)
+			soc_remove_codec(codec);
 	}
 
 	/* remove any CPU-side CODEC */
 	if (cpu_dai) {
-		if (cpu_dai->component->driver->remove_order == order)
-			soc_remove_component(cpu_dai->component);
+		codec = cpu_dai->codec;
+		if (codec && codec->probed &&
+		    codec->driver->remove_order == order)
+			soc_remove_codec(codec);
 	}
 }
 
@@ -1027,78 +1173,137 @@
 	}
 }
 
-static int soc_probe_component(struct snd_soc_card *card,
-	struct snd_soc_component *component)
+static int soc_probe_codec(struct snd_soc_card *card,
+			   struct snd_soc_codec *codec)
 {
-	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	int ret = 0;
+	const struct snd_soc_codec_driver *driver = codec->driver;
 	struct snd_soc_dai *dai;
-	int ret;
-
-	if (component->probed)
-		return 0;
 
-	component->card = card;
-	dapm->card = card;
-	soc_set_name_prefix(card, component);
+	codec->component.card = card;
+	codec->dapm.card = card;
+	soc_set_name_prefix(card, &codec->component);
 
-	if (!try_module_get(component->dev->driver->owner))
+	if (!try_module_get(codec->dev->driver->owner))
 		return -ENODEV;
 
-	soc_init_component_debugfs(component);
+	soc_init_codec_debugfs(codec);
 
-	if (component->dapm_widgets) {
-		ret = snd_soc_dapm_new_controls(dapm, component->dapm_widgets,
-			component->num_dapm_widgets);
+	if (driver->dapm_widgets) {
+		ret = snd_soc_dapm_new_controls(&codec->dapm,
+						driver->dapm_widgets,
+					 	driver->num_dapm_widgets);
 
 		if (ret != 0) {
-			dev_err(component->dev,
+			dev_err(codec->dev,
 				"Failed to create new controls %d\n", ret);
 			goto err_probe;
 		}
 	}
 
-	list_for_each_entry(dai, &component->dai_list, list) {
-		ret = snd_soc_dapm_new_dai_widgets(dapm, dai);
+	/* Create DAPM widgets for each DAI stream */
+	list_for_each_entry(dai, &codec->component.dai_list, list) {
+		ret = snd_soc_dapm_new_dai_widgets(&codec->dapm, dai);
+
 		if (ret != 0) {
-			dev_err(component->dev,
+			dev_err(codec->dev,
 				"Failed to create DAI widgets %d\n", ret);
 			goto err_probe;
 		}
 	}
 
-	if (component->probe) {
-		ret = component->probe(component);
+	codec->dapm.idle_bias_off = driver->idle_bias_off;
+
+	if (driver->probe) {
+		ret = driver->probe(codec);
 		if (ret < 0) {
-			dev_err(component->dev,
-				"ASoC: failed to probe component %d\n", ret);
+			dev_err(codec->dev,
+				"ASoC: failed to probe CODEC %d\n", ret);
 			goto err_probe;
 		}
-
-		WARN(dapm->idle_bias_off &&
-			dapm->bias_level != SND_SOC_BIAS_OFF,
+		WARN(codec->dapm.idle_bias_off &&
+			codec->dapm.bias_level != SND_SOC_BIAS_OFF,
 			"codec %s can not start from non-off bias with idle_bias_off==1\n",
-			component->name);
+			codec->component.name);
+	}
+
+	if (driver->controls)
+		snd_soc_add_codec_controls(codec, driver->controls,
+				     driver->num_controls);
+	if (driver->dapm_routes)
+		snd_soc_dapm_add_routes(&codec->dapm, driver->dapm_routes,
+					driver->num_dapm_routes);
+
+	/* mark codec as probed and add to card codec list */
+	codec->probed = 1;
+	list_add(&codec->card_list, &card->codec_dev_list);
+	list_add(&codec->dapm.list, &card->dapm_list);
+
+	return 0;
+
+err_probe:
+	soc_cleanup_codec_debugfs(codec);
+	module_put(codec->dev->driver->owner);
+
+	return ret;
+}
+
+static int soc_probe_platform(struct snd_soc_card *card,
+			   struct snd_soc_platform *platform)
+{
+	int ret = 0;
+	const struct snd_soc_platform_driver *driver = platform->driver;
+	struct snd_soc_component *component;
+	struct snd_soc_dai *dai;
+
+	platform->component.card = card;
+	platform->component.dapm.card = card;
+
+	if (!try_module_get(platform->dev->driver->owner))
+		return -ENODEV;
+
+	soc_init_platform_debugfs(platform);
+
+	if (driver->dapm_widgets)
+		snd_soc_dapm_new_controls(&platform->component.dapm,
+			driver->dapm_widgets, driver->num_dapm_widgets);
+
+	/* Create DAPM widgets for each DAI stream */
+	list_for_each_entry(component, &component_list, list) {
+		if (component->dev != platform->dev)
+			continue;
+		list_for_each_entry(dai, &component->dai_list, list)
+			snd_soc_dapm_new_dai_widgets(&platform->component.dapm,
+				dai);
+	}
+
+	platform->component.dapm.idle_bias_off = 1;
+
+	if (driver->probe) {
+		ret = driver->probe(platform);
+		if (ret < 0) {
+			dev_err(platform->dev,
+				"ASoC: failed to probe platform %d\n", ret);
+			goto err_probe;
+		}
 	}
 
-	if (component->controls)
-		snd_soc_add_component_controls(component, component->controls,
-				     component->num_controls);
-	if (component->dapm_routes)
-		snd_soc_dapm_add_routes(dapm, component->dapm_routes,
-					component->num_dapm_routes);
-
-	component->probed = 1;
-	list_add(&dapm->list, &card->dapm_list);
-
-	/* This is a HACK and will be removed soon */
-	if (component->codec)
-		list_add(&component->codec->card_list, &card->codec_dev_list);
+	if (driver->controls)
+		snd_soc_add_platform_controls(platform, driver->controls,
+				     driver->num_controls);
+	if (driver->dapm_routes)
+		snd_soc_dapm_add_routes(&platform->component.dapm,
+			driver->dapm_routes, driver->num_dapm_routes);
+
+	/* mark platform as probed and add to card platform list */
+	platform->probed = 1;
+	list_add(&platform->component.dapm.list, &card->dapm_list);
 
 	return 0;
 
 err_probe:
-	soc_cleanup_component_debugfs(component);
-	module_put(component->dev->driver->owner);
+	soc_cleanup_platform_debugfs(platform);
+	module_put(platform->dev->driver->owner);
 
 	return ret;
 }
@@ -1120,7 +1325,7 @@
 	device_initialize(rtd->dev);
 	rtd->dev->parent = rtd->card->dev;
 	rtd->dev->release = rtd_release;
-	dev_set_name(rtd->dev, "%s", name);
+	rtd->dev->init_name = name;
 	dev_set_drvdata(rtd->dev, rtd);
 	mutex_init(&rtd->pcm_mutex);
 	INIT_LIST_HEAD(&rtd->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients);
@@ -1137,21 +1342,17 @@
 	}
 	rtd->dev_registered = 1;
 
-	if (rtd->codec) {
-		/* add DAPM sysfs entries for this codec */
-		ret = snd_soc_dapm_sys_add(rtd->dev);
-		if (ret < 0)
-			dev_err(rtd->dev,
-				"ASoC: failed to add codec dapm sysfs entries: %d\n",
-				ret);
+	/* add DAPM sysfs entries for this codec */
+	ret = snd_soc_dapm_sys_add(rtd->dev);
+	if (ret < 0)
+		dev_err(rtd->dev,
+			"ASoC: failed to add codec dapm sysfs entries: %d\n", ret);
 
-		/* add codec sysfs entries */
-		ret = device_create_file(rtd->dev, &dev_attr_codec_reg);
-		if (ret < 0)
-			dev_err(rtd->dev,
-				"ASoC: failed to add codec sysfs files: %d\n",
-				ret);
-	}
+	/* add codec sysfs entries */
+	ret = device_create_file(rtd->dev, &dev_attr_codec_reg);
+	if (ret < 0)
+		dev_err(rtd->dev,
+			"ASoC: failed to add codec sysfs files: %d\n", ret);
 
 	return 0;
 }
@@ -1160,31 +1361,33 @@
 				     int order)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_component *component;
 	int i, ret;
 
 	/* probe the CPU-side component, if it is a CODEC */
-	component = rtd->cpu_dai->component;
-	if (component->driver->probe_order == order) {
-		ret = soc_probe_component(card, component);
+	if (cpu_dai->codec &&
+	    !cpu_dai->codec->probed &&
+	    cpu_dai->codec->driver->probe_order == order) {
+		ret = soc_probe_codec(card, cpu_dai->codec);
 		if (ret < 0)
 			return ret;
 	}
 
 	/* probe the CODEC-side components */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		component = rtd->codec_dais[i]->component;
-		if (component->driver->probe_order == order) {
-			ret = soc_probe_component(card, component);
+		if (!rtd->codec_dais[i]->codec->probed &&
+		    rtd->codec_dais[i]->codec->driver->probe_order == order) {
+			ret = soc_probe_codec(card, rtd->codec_dais[i]->codec);
 			if (ret < 0)
 				return ret;
 		}
 	}
 
 	/* probe the platform */
-	if (platform->component.driver->probe_order == order) {
-		ret = soc_probe_component(card, &platform->component);
+	if (!platform->probed &&
+	    platform->driver->probe_order == order) {
+		ret = soc_probe_platform(card, platform);
 		if (ret < 0)
 			return ret;
 	}
@@ -1192,22 +1395,25 @@
 	return 0;
 }
 
-static int soc_probe_dai(struct snd_soc_dai *dai, int order)
+static int soc_probe_codec_dai(struct snd_soc_card *card,
+			       struct snd_soc_dai *codec_dai,
+			       int order)
 {
 	int ret;
 
-	if (!dai->probed && dai->driver->probe_order == order) {
-		if (dai->driver->probe) {
-			ret = dai->driver->probe(dai);
+	if (!codec_dai->probed && codec_dai->driver->probe_order == order) {
+		if (codec_dai->driver->probe) {
+			ret = codec_dai->driver->probe(codec_dai);
 			if (ret < 0) {
-				dev_err(dai->dev,
-					"ASoC: failed to probe DAI %s: %d\n",
-					dai->name, ret);
+				dev_err(codec_dai->dev,
+					"ASoC: failed to probe CODEC DAI %s: %d\n",
+					codec_dai->name, ret);
 				return ret;
 			}
 		}
 
-		dai->probed = 1;
+		/* mark codec_dai as probed and add to card dai list */
+		codec_dai->probed = 1;
 	}
 
 	return 0;
@@ -1257,22 +1463,46 @@
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
 	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
+	struct snd_soc_platform *platform = rtd->platform;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	int i, ret;
 
 	dev_dbg(card->dev, "ASoC: probe %s dai link %d late %d\n",
 			card->name, num, order);
 
+	/* config components */
+	cpu_dai->platform = platform;
+	cpu_dai->card = card;
+	for (i = 0; i < rtd->num_codecs; i++)
+		rtd->codec_dais[i]->card = card;
+
 	/* set default power off timeout */
 	rtd->pmdown_time = pmdown_time;
 
-	ret = soc_probe_dai(cpu_dai, order);
-	if (ret)
-		return ret;
+	/* probe the cpu_dai */
+	if (!cpu_dai->probed &&
+			cpu_dai->driver->probe_order == order) {
+		if (!cpu_dai->codec) {
+			if (!try_module_get(cpu_dai->dev->driver->owner))
+				return -ENODEV;
+		}
+
+		if (cpu_dai->driver->probe) {
+			ret = cpu_dai->driver->probe(cpu_dai);
+			if (ret < 0) {
+				dev_err(cpu_dai->dev,
+					"ASoC: failed to probe CPU DAI %s: %d\n",
+					cpu_dai->name, ret);
+				module_put(cpu_dai->dev->driver->owner);
+				return ret;
+			}
+		}
+		cpu_dai->probed = 1;
+	}
 
 	/* probe the CODEC DAI */
 	for (i = 0; i < rtd->num_codecs; i++) {
-		ret = soc_probe_dai(rtd->codec_dais[i], order);
+		ret = soc_probe_codec_dai(card, rtd->codec_dais[i], order);
 		if (ret)
 			return ret;
 	}
@@ -1342,31 +1572,99 @@
 		}
 	}
 
+	/* add platform data for AC97 devices */
+	for (i = 0; i < rtd->num_codecs; i++) {
+		if (rtd->codec_dais[i]->driver->ac97_control)
+			snd_ac97_dev_add_pdata(rtd->codec_dais[i]->codec->ac97,
+					       rtd->cpu_dai->ac97_pdata);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_SND_SOC_AC97_BUS
+static int soc_register_ac97_codec(struct snd_soc_codec *codec,
+				   struct snd_soc_dai *codec_dai)
+{
+	int ret;
+
+	/* Only instantiate AC97 if not already done by the adaptor
+	 * for the generic AC97 subsystem.
+	 */
+	if (codec_dai->driver->ac97_control && !codec->ac97_registered) {
+		/*
+		 * It is possible that the AC97 device is already registered to
+		 * the device subsystem. This happens when the device is created
+		 * via snd_ac97_mixer(). Currently only SoC codec that does so
+		 * is the generic AC97 glue but others migh emerge.
+		 *
+		 * In those cases we don't try to register the device again.
+		 */
+		if (!codec->ac97_created)
+			return 0;
+
+		ret = soc_ac97_dev_register(codec);
+		if (ret < 0) {
+			dev_err(codec->dev,
+				"ASoC: AC97 device register failed: %d\n", ret);
+			return ret;
+		}
+
+		codec->ac97_registered = 1;
+	}
+	return 0;
+}
+
+static void soc_unregister_ac97_codec(struct snd_soc_codec *codec)
+{
+	if (codec->ac97_registered) {
+		soc_ac97_dev_unregister(codec);
+		codec->ac97_registered = 0;
+	}
+}
+
+static int soc_register_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_dai *codec_dai = rtd->codec_dais[i];
+
+		ret = soc_register_ac97_codec(codec_dai->codec, codec_dai);
+		if (ret) {
+			while (--i >= 0)
+				soc_unregister_ac97_codec(codec_dai->codec);
+			return ret;
+		}
+	}
+
 	return 0;
 }
 
+static void soc_unregister_ac97_dai_link(struct snd_soc_pcm_runtime *rtd)
+{
+	int i;
+
+	for (i = 0; i < rtd->num_codecs; i++)
+		soc_unregister_ac97_codec(rtd->codec_dais[i]->codec);
+}
+#endif
+
 static int soc_bind_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
-	const char *name = aux_dev->codec_name;
+	const char *codecname = aux_dev->codec_name;
 
-	rtd->component = soc_find_component(aux_dev->codec_of_node, name);
-	if (!rtd->component) {
+	rtd->codec = soc_find_codec(aux_dev->codec_of_node, codecname);
+	if (!rtd->codec) {
 		if (aux_dev->codec_of_node)
-			name = of_node_full_name(aux_dev->codec_of_node);
+			codecname = of_node_full_name(aux_dev->codec_of_node);
 
-		dev_err(card->dev, "ASoC: %s not registered\n", name);
+		dev_err(card->dev, "ASoC: %s not registered\n", codecname);
 		return -EPROBE_DEFER;
 	}
 
-	/*
-	 * Some places still reference rtd->codec, so we have to keep that
-	 * initialized if the component is a CODEC. Once all those references
-	 * have been removed, this code can be removed as well.
-	 */
-	 rtd->codec = rtd->component->codec;
-
 	return 0;
 }
 
@@ -1376,13 +1674,18 @@
 	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
 	int ret;
 
-	ret = soc_probe_component(card, rtd->component);
+	if (rtd->codec->probed) {
+		dev_err(rtd->codec->dev, "ASoC: codec already probed\n");
+		return -EBUSY;
+	}
+
+	ret = soc_probe_codec(card, rtd->codec);
 	if (ret < 0)
 		return ret;
 
 	/* do machine specific initialization */
 	if (aux_dev->init) {
-		ret = aux_dev->init(rtd->component);
+		ret = aux_dev->init(&rtd->codec->dapm);
 		if (ret < 0) {
 			dev_err(card->dev, "ASoC: failed to init %s: %d\n",
 				aux_dev->name, ret);
@@ -1396,7 +1699,7 @@
 static void soc_remove_aux_dev(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
-	struct snd_soc_component *component = rtd->component;
+	struct snd_soc_codec *codec = rtd->codec;
 
 	/* unregister the rtd device */
 	if (rtd->dev_registered) {
@@ -1405,8 +1708,8 @@
 		rtd->dev_registered = 0;
 	}
 
-	if (component && component->probed)
-		soc_remove_component(component);
+	if (codec && codec->probed)
+		soc_remove_codec(codec);
 }
 
 static int snd_soc_init_codec_cache(struct snd_soc_codec *codec)
@@ -1638,6 +1941,20 @@
 		goto probe_aux_dev_err;
 	}
 
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	/* register any AC97 codecs */
+	for (i = 0; i < card->num_rtd; i++) {
+		ret = soc_register_ac97_dai_link(&card->rtd[i]);
+		if (ret < 0) {
+			dev_err(card->dev,
+				"ASoC: failed to register AC97: %d\n", ret);
+			while (--i >= 0)
+				soc_unregister_ac97_dai_link(&card->rtd[i]);
+			goto probe_aux_dev_err;
+		}
+	}
+#endif
+
 	card->instantiated = 1;
 	snd_soc_dapm_sync(&card->dapm);
 	mutex_unlock(&card->mutex);
@@ -1772,6 +2089,7 @@
 static struct platform_driver soc_driver = {
 	.driver		= {
 		.name		= "soc-audio",
+		.owner		= THIS_MODULE,
 		.pm		= &snd_soc_pm_ops,
 	},
 	.probe		= soc_probe,
@@ -1779,179 +2097,1407 @@
 };
 
 /**
- * snd_soc_cnew - create new control
- * @_template: control template
- * @data: control private data
- * @long_name: control long name
- * @prefix: control name prefix
- *
- * Create a new mixer control from a template control.
+ * snd_soc_new_ac97_codec - initailise AC97 device
+ * @codec: audio codec
+ * @ops: AC97 bus operations
+ * @num: AC97 codec number
  *
- * Returns 0 for success, else error.
+ * Initialises AC97 codec resources for use by ad-hoc devices only.
  */
-struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
-				  void *data, const char *long_name,
-				  const char *prefix)
+int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
+	struct snd_ac97_bus_ops *ops, int num)
 {
-	struct snd_kcontrol_new template;
-	struct snd_kcontrol *kcontrol;
-	char *name = NULL;
-
-	memcpy(&template, _template, sizeof(template));
-	template.index = 0;
-
-	if (!long_name)
-		long_name = template.name;
+	mutex_lock(&codec->mutex);
 
-	if (prefix) {
-		name = kasprintf(GFP_KERNEL, "%s %s", prefix, long_name);
-		if (!name)
-			return NULL;
+	codec->ac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);
+	if (codec->ac97 == NULL) {
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
+	}
 
-		template.name = name;
-	} else {
-		template.name = long_name;
+	codec->ac97->bus = kzalloc(sizeof(struct snd_ac97_bus), GFP_KERNEL);
+	if (codec->ac97->bus == NULL) {
+		kfree(codec->ac97);
+		codec->ac97 = NULL;
+		mutex_unlock(&codec->mutex);
+		return -ENOMEM;
 	}
 
-	kcontrol = snd_ctl_new1(&template, data);
+	codec->ac97->bus->ops = ops;
+	codec->ac97->num = num;
+
+	/*
+	 * Mark the AC97 device to be created by us. This way we ensure that the
+	 * device will be registered with the device subsystem later on.
+	 */
+	codec->ac97_created = 1;
+
+	mutex_unlock(&codec->mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_new_ac97_codec);
+
+static struct snd_ac97_reset_cfg snd_ac97_rst_cfg;
+
+static void snd_soc_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_warm_reset);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 1);
+
+	udelay(10);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
+	msleep(2);
+}
+
+static void snd_soc_ac97_reset(struct snd_ac97 *ac97)
+{
+	struct pinctrl *pctl = snd_ac97_rst_cfg.pctl;
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_reset);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sync, 0);
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_sdata, 0);
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 0);
+
+	udelay(10);
+
+	gpio_direction_output(snd_ac97_rst_cfg.gpio_reset, 1);
+
+	pinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);
+	msleep(2);
+}
+
+static int snd_soc_ac97_parse_pinctl(struct device *dev,
+		struct snd_ac97_reset_cfg *cfg)
+{
+	struct pinctrl *p;
+	struct pinctrl_state *state;
+	int gpio;
+	int ret;
+
+	p = devm_pinctrl_get(dev);
+	if (IS_ERR(p)) {
+		dev_err(dev, "Failed to get pinctrl\n");
+		return PTR_ERR(p);
+	}
+	cfg->pctl = p;
+
+	state = pinctrl_lookup_state(p, "ac97-reset");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-reset\n");
+		return PTR_ERR(state);
+	}
+	cfg->pstate_reset = state;
+
+	state = pinctrl_lookup_state(p, "ac97-warm-reset");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-warm-reset\n");
+		return PTR_ERR(state);
+	}
+	cfg->pstate_warm_reset = state;
+
+	state = pinctrl_lookup_state(p, "ac97-running");
+	if (IS_ERR(state)) {
+		dev_err(dev, "Can't find pinctrl state ac97-running\n");
+		return PTR_ERR(state);
+	}
+	cfg->pstate_run = state;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 0);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-sync gpio\n");
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link sync");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-sync gpio\n");
+		return ret;
+	}
+	cfg->gpio_sync = gpio;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 1);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-sdata gpio %d\n", gpio);
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link sdata");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-sdata gpio\n");
+		return ret;
+	}
+	cfg->gpio_sdata = gpio;
+
+	gpio = of_get_named_gpio(dev->of_node, "ac97-gpios", 2);
+	if (gpio < 0) {
+		dev_err(dev, "Can't find ac97-reset gpio\n");
+		return gpio;
+	}
+	ret = devm_gpio_request(dev, gpio, "AC97 link reset");
+	if (ret) {
+		dev_err(dev, "Failed requesting ac97-reset gpio\n");
+		return ret;
+	}
+	cfg->gpio_reset = gpio;
+
+	return 0;
+}
+
+struct snd_ac97_bus_ops *soc_ac97_ops;
+EXPORT_SYMBOL_GPL(soc_ac97_ops);
+
+int snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)
+{
+	if (ops == soc_ac97_ops)
+		return 0;
+
+	if (soc_ac97_ops && ops)
+		return -EBUSY;
+
+	soc_ac97_ops = ops;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops);
+
+/**
+ * snd_soc_set_ac97_ops_of_reset - Set ac97 ops with generic ac97 reset functions
+ *
+ * This function sets the reset and warm_reset properties of ops and parses
+ * the device node of pdev to get pinctrl states and gpio numbers to use.
+ */
+int snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,
+		struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct snd_ac97_reset_cfg cfg;
+	int ret;
+
+	ret = snd_soc_ac97_parse_pinctl(dev, &cfg);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_set_ac97_ops(ops);
+	if (ret)
+		return ret;
+
+	ops->warm_reset = snd_soc_ac97_warm_reset;
+	ops->reset = snd_soc_ac97_reset;
+
+	snd_ac97_rst_cfg = cfg;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops_of_reset);
+
+/**
+ * snd_soc_free_ac97_codec - free AC97 codec device
+ * @codec: audio codec
+ *
+ * Frees AC97 codec device resources.
+ */
+void snd_soc_free_ac97_codec(struct snd_soc_codec *codec)
+{
+	mutex_lock(&codec->mutex);
+#ifdef CONFIG_SND_SOC_AC97_BUS
+	soc_unregister_ac97_codec(codec);
+#endif
+	kfree(codec->ac97->bus);
+	kfree(codec->ac97);
+	codec->ac97 = NULL;
+	codec->ac97_created = 0;
+	mutex_unlock(&codec->mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_free_ac97_codec);
+
+/**
+ * snd_soc_cnew - create new control
+ * @_template: control template
+ * @data: control private data
+ * @long_name: control long name
+ * @prefix: control name prefix
+ *
+ * Create a new mixer control from a template control.
+ *
+ * Returns 0 for success, else error.
+ */
+struct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,
+				  void *data, const char *long_name,
+				  const char *prefix)
+{
+	struct snd_kcontrol_new template;
+	struct snd_kcontrol *kcontrol;
+	char *name = NULL;
+
+	memcpy(&template, _template, sizeof(template));
+	template.index = 0;
+
+	if (!long_name)
+		long_name = template.name;
+
+	if (prefix) {
+		name = kasprintf(GFP_KERNEL, "%s %s", prefix, long_name);
+		if (!name)
+			return NULL;
+
+		template.name = name;
+	} else {
+		template.name = long_name;
+	}
+
+	kcontrol = snd_ctl_new1(&template, data);
 
 	kfree(name);
 
-	return kcontrol;
+	return kcontrol;
+}
+EXPORT_SYMBOL_GPL(snd_soc_cnew);
+
+static int snd_soc_add_controls(struct snd_card *card, struct device *dev,
+	const struct snd_kcontrol_new *controls, int num_controls,
+	const char *prefix, void *data)
+{
+	int err, i;
+
+	for (i = 0; i < num_controls; i++) {
+		const struct snd_kcontrol_new *control = &controls[i];
+		err = snd_ctl_add(card, snd_soc_cnew(control, data,
+						     control->name, prefix));
+		if (err < 0) {
+			dev_err(dev, "ASoC: Failed to add %s: %d\n",
+				control->name, err);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+struct snd_kcontrol *snd_soc_card_get_kcontrol(struct snd_soc_card *soc_card,
+					       const char *name)
+{
+	struct snd_card *card = soc_card->snd_card;
+	struct snd_kcontrol *kctl;
+
+	if (unlikely(!name))
+		return NULL;
+
+	list_for_each_entry(kctl, &card->controls, list)
+		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name)))
+			return kctl;
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_card_get_kcontrol);
+
+/**
+ * snd_soc_add_component_controls - Add an array of controls to a component.
+ *
+ * @component: Component to add controls to
+ * @controls: Array of controls to add
+ * @num_controls: Number of elements in the array
+ *
+ * Return: 0 for success, else error.
+ */
+int snd_soc_add_component_controls(struct snd_soc_component *component,
+	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+{
+	struct snd_card *card = component->card->snd_card;
+
+	return snd_soc_add_controls(card, component->dev, controls,
+			num_controls, component->name_prefix, component);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_component_controls);
+
+/**
+ * snd_soc_add_codec_controls - add an array of controls to a codec.
+ * Convenience function to add a list of controls. Many codecs were
+ * duplicating this code.
+ *
+ * @codec: codec to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
+	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+{
+	return snd_soc_add_component_controls(&codec->component, controls,
+		num_controls);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
+
+/**
+ * snd_soc_add_platform_controls - add an array of controls to a platform.
+ * Convenience function to add a list of controls.
+ *
+ * @platform: platform to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
+	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+{
+	return snd_soc_add_component_controls(&platform->component, controls,
+		num_controls);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);
+
+/**
+ * snd_soc_add_card_controls - add an array of controls to a SoC card.
+ * Convenience function to add a list of controls.
+ *
+ * @soc_card: SoC card to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_card_controls(struct snd_soc_card *soc_card,
+	const struct snd_kcontrol_new *controls, int num_controls)
+{
+	struct snd_card *card = soc_card->snd_card;
+
+	return snd_soc_add_controls(card, soc_card->dev, controls, num_controls,
+			NULL, soc_card);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_card_controls);
+
+/**
+ * snd_soc_add_dai_controls - add an array of controls to a DAI.
+ * Convienience function to add a list of controls.
+ *
+ * @dai: DAI to add controls to
+ * @controls: array of controls to add
+ * @num_controls: number of elements in the array
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
+	const struct snd_kcontrol_new *controls, int num_controls)
+{
+	struct snd_card *card = dai->card->snd_card;
+
+	return snd_soc_add_controls(card, dai->dev, controls, num_controls,
+			NULL, dai);
+}
+EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
+
+/**
+ * snd_soc_info_enum_double - enumerated double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double enumerated
+ * mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
+	uinfo->value.enumerated.items = e->items;
+
+	if (uinfo->value.enumerated.item >= e->items)
+		uinfo->value.enumerated.item = e->items - 1;
+	strlcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item],
+		sizeof(uinfo->value.enumerated.name));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
+
+/**
+ * snd_soc_get_enum_double - enumerated double mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int val, item;
+	unsigned int reg_val;
+	int ret;
+
+	ret = snd_soc_component_read(component, e->reg, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val >> e->shift_l) & e->mask;
+	item = snd_soc_enum_val_to_item(e, val);
+	ucontrol->value.enumerated.item[0] = item;
+	if (e->shift_l != e->shift_r) {
+		val = (reg_val >> e->shift_l) & e->mask;
+		item = snd_soc_enum_val_to_item(e, val);
+		ucontrol->value.enumerated.item[1] = item;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
+
+/**
+ * snd_soc_put_enum_double - enumerated double mixer put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a double enumerated mixer.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int *item = ucontrol->value.enumerated.item;
+	unsigned int val;
+	unsigned int mask;
+
+	if (item[0] >= e->items)
+		return -EINVAL;
+	val = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;
+	mask = e->mask << e->shift_l;
+	if (e->shift_l != e->shift_r) {
+		if (item[1] >= e->items)
+			return -EINVAL;
+		val |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_r;
+		mask |= e->mask << e->shift_r;
+	}
+
+	return snd_soc_component_update_bits(component, e->reg, mask, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
+
+/**
+ * snd_soc_read_signed - Read a codec register and interprete as signed value
+ * @component: component
+ * @reg: Register to read
+ * @mask: Mask to use after shifting the register value
+ * @shift: Right shift of register value
+ * @sign_bit: Bit that describes if a number is negative or not.
+ * @signed_val: Pointer to where the read value should be stored
+ *
+ * This functions reads a codec register. The register value is shifted right
+ * by 'shift' bits and masked with the given 'mask'. Afterwards it translates
+ * the given registervalue into a signed integer if sign_bit is non-zero.
+ *
+ * Returns 0 on sucess, otherwise an error value
+ */
+static int snd_soc_read_signed(struct snd_soc_component *component,
+	unsigned int reg, unsigned int mask, unsigned int shift,
+	unsigned int sign_bit, int *signed_val)
+{
+	int ret;
+	unsigned int val;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret < 0)
+		return ret;
+
+	val = (val >> shift) & mask;
+
+	if (!sign_bit) {
+		*signed_val = val;
+		return 0;
+	}
+
+	/* non-negative number */
+	if (!(val & BIT(sign_bit))) {
+		*signed_val = val;
+		return 0;
+	}
+
+	ret = val;
+
+	/*
+	 * The register most probably does not contain a full-sized int.
+	 * Instead we have an arbitrary number of bits in a signed
+	 * representation which has to be translated into a full-sized int.
+	 * This is done by filling up all bits above the sign-bit.
+	 */
+	ret |= ~((int)(BIT(sign_bit) - 1));
+
+	*signed_val = ret;
+
+	return 0;
+}
+
+/**
+ * snd_soc_info_volsw - single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single mixer control, or a double
+ * mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int platform_max;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	if (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max - mc->min;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
+
+/**
+ * snd_soc_get_volsw - single mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	int sign_bit = mc->sign_bit;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	int val;
+	int ret;
+
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	ret = snd_soc_read_signed(component, reg, mask, shift, sign_bit, &val);
+	if (ret)
+		return ret;
+
+	ucontrol->value.integer.value[0] = val - min;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		if (reg == reg2)
+			ret = snd_soc_read_signed(component, reg, mask, rshift,
+				sign_bit, &val);
+		else
+			ret = snd_soc_read_signed(component, reg2, mask, shift,
+				sign_bit, &val);
+		if (ret)
+			return ret;
+
+		ucontrol->value.integer.value[1] = val - min;
+		if (invert)
+			ucontrol->value.integer.value[1] =
+				max - ucontrol->value.integer.value[1];
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
+
+/**
+ * snd_soc_put_volsw - single mixer put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	unsigned int sign_bit = mc->sign_bit;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	int err;
+	bool type_2r = false;
+	unsigned int val2 = 0;
+	unsigned int val, val_mask;
+
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	val = ((ucontrol->value.integer.value[0] + min) & mask);
+	if (invert)
+		val = max - val;
+	val_mask = mask << shift;
+	val = val << shift;
+	if (snd_soc_volsw_is_stereo(mc)) {
+		val2 = ((ucontrol->value.integer.value[1] + min) & mask);
+		if (invert)
+			val2 = max - val2;
+		if (reg == reg2) {
+			val_mask |= mask << rshift;
+			val |= val2 << rshift;
+		} else {
+			val2 = val2 << shift;
+			type_2r = true;
+		}
+	}
+	err = snd_soc_component_update_bits(component, reg, val_mask, val);
+	if (err < 0)
+		return err;
+
+	if (type_2r)
+		err = snd_soc_component_update_bits(component, reg2, val_mask,
+			val2);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
+
+/**
+ * snd_soc_get_volsw_sx - single mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,
+		      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+	    (struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	int mask = (1 << (fls(min + max) - 1)) - 1;
+	unsigned int val;
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret < 0)
+		return ret;
+
+	ucontrol->value.integer.value[0] = ((val >> shift) - min) & mask;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		ret = snd_soc_component_read(component, reg2, &val);
+		if (ret < 0)
+			return ret;
+
+		val = ((val >> rshift) - min) & mask;
+		ucontrol->value.integer.value[1] = val;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_sx);
+
+/**
+ * snd_soc_put_volsw_sx - double mixer set callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to set the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+	    (struct soc_mixer_control *)kcontrol->private_value;
+
+	unsigned int reg = mc->reg;
+	unsigned int reg2 = mc->rreg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	int min = mc->min;
+	int mask = (1 << (fls(min + max) - 1)) - 1;
+	int err = 0;
+	unsigned int val, val_mask, val2 = 0;
+
+	val_mask = mask << shift;
+	val = (ucontrol->value.integer.value[0] + min) & mask;
+	val = val << shift;
+
+	err = snd_soc_component_update_bits(component, reg, val_mask, val);
+	if (err < 0)
+		return err;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		val_mask = mask << rshift;
+		val2 = (ucontrol->value.integer.value[1] + min) & mask;
+		val2 = val2 << rshift;
+
+		err = snd_soc_component_update_bits(component, reg2, val_mask,
+			val2);
+	}
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_sx);
+
+/**
+ * snd_soc_info_volsw_s8 - signed mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a signed mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int platform_max;
+	int min = mc->min;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max - min;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_s8);
+
+/**
+ * snd_soc_get_volsw_s8 - signed mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a signed mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int val;
+	int min = mc->min;
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret)
+		return ret;
+
+	ucontrol->value.integer.value[0] =
+		((signed char)(val & 0xff))-min;
+	ucontrol->value.integer.value[1] =
+		((signed char)((val >> 8) & 0xff))-min;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_s8);
+
+/**
+ * snd_soc_put_volsw_sgn - signed mixer put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a signed mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	int min = mc->min;
+	unsigned int val;
+
+	val = (ucontrol->value.integer.value[0]+min) & 0xff;
+	val |= ((ucontrol->value.integer.value[1]+min) & 0xff) << 8;
+
+	return snd_soc_component_update_bits(component, reg, 0xffff, val);
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
+
+/**
+ * snd_soc_info_volsw_range - single mixer info callback with range.
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information, within a range, about a single
+ * mixer control.
+ *
+ * returns 0 for success.
+ */
+int snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int platform_max;
+	int min = mc->min;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max - min;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_range);
+
+/**
+ * snd_soc_put_volsw_range - single mixer put value callback with range.
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value, within a range, for a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned int rreg = mc->rreg;
+	unsigned int shift = mc->shift;
+	int min = mc->min;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val, val_mask;
+	int ret;
+
+	val = ((ucontrol->value.integer.value[0] + min) & mask);
+	if (invert)
+		val = max - val;
+	val_mask = mask << shift;
+	val = val << shift;
+
+	ret = snd_soc_component_update_bits(component, reg, val_mask, val);
+	if (ret < 0)
+		return ret;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		val = ((ucontrol->value.integer.value[1] + min) & mask);
+		if (invert)
+			val = max - val;
+		val_mask = mask << shift;
+		val = val << shift;
+
+		ret = snd_soc_component_update_bits(component, rreg, val_mask,
+			val);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_put_volsw_range);
+
+/**
+ * snd_soc_get_volsw_range - single mixer get callback with range
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value, within a range, of a single mixer control.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int rreg = mc->rreg;
+	unsigned int shift = mc->shift;
+	int min = mc->min;
+	int max = mc->max;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	unsigned int val;
+	int ret;
+
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret)
+		return ret;
+
+	ucontrol->value.integer.value[0] = (val >> shift) & mask;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+	ucontrol->value.integer.value[0] =
+		ucontrol->value.integer.value[0] - min;
+
+	if (snd_soc_volsw_is_stereo(mc)) {
+		ret = snd_soc_component_read(component, rreg, &val);
+		if (ret)
+			return ret;
+
+		ucontrol->value.integer.value[1] = (val >> shift) & mask;
+		if (invert)
+			ucontrol->value.integer.value[1] =
+				max - ucontrol->value.integer.value[1];
+		ucontrol->value.integer.value[1] =
+			ucontrol->value.integer.value[1] - min;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_get_volsw_range);
+
+/**
+ * snd_soc_limit_volume - Set new limit to an existing volume control.
+ *
+ * @codec: where to look for the control
+ * @name: Name of the control
+ * @max: new maximum limit
+ *
+ * Return 0 for success, else error.
+ */
+int snd_soc_limit_volume(struct snd_soc_codec *codec,
+	const char *name, int max)
+{
+	struct snd_card *card = codec->component.card->snd_card;
+	struct snd_kcontrol *kctl;
+	struct soc_mixer_control *mc;
+	int found = 0;
+	int ret = -EINVAL;
+
+	/* Sanity check for name and max */
+	if (unlikely(!name || max <= 0))
+		return -EINVAL;
+
+	list_for_each_entry(kctl, &card->controls, list) {
+		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name))) {
+			found = 1;
+			break;
+		}
+	}
+	if (found) {
+		mc = (struct soc_mixer_control *)kctl->private_value;
+		if (max <= mc->max) {
+			mc->platform_max = max;
+			ret = 0;
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_limit_volume);
+
+int snd_soc_bytes_info(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_bytes *params = (void *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = params->num_regs * component->val_bytes;
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_cnew);
+EXPORT_SYMBOL_GPL(snd_soc_bytes_info);
 
-static int snd_soc_add_controls(struct snd_card *card, struct device *dev,
-	const struct snd_kcontrol_new *controls, int num_controls,
-	const char *prefix, void *data)
+int snd_soc_bytes_get(struct snd_kcontrol *kcontrol,
+		      struct snd_ctl_elem_value *ucontrol)
 {
-	int err, i;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_bytes *params = (void *)kcontrol->private_value;
+	int ret;
 
-	for (i = 0; i < num_controls; i++) {
-		const struct snd_kcontrol_new *control = &controls[i];
-		err = snd_ctl_add(card, snd_soc_cnew(control, data,
-						     control->name, prefix));
-		if (err < 0) {
-			dev_err(dev, "ASoC: Failed to add %s: %d\n",
-				control->name, err);
-			return err;
+	if (component->regmap)
+		ret = regmap_raw_read(component->regmap, params->base,
+				      ucontrol->value.bytes.data,
+				      params->num_regs * component->val_bytes);
+	else
+		ret = -EINVAL;
+
+	/* Hide any masked bytes to ensure consistent data reporting */
+	if (ret == 0 && params->mask) {
+		switch (component->val_bytes) {
+		case 1:
+			ucontrol->value.bytes.data[0] &= ~params->mask;
+			break;
+		case 2:
+			((u16 *)(&ucontrol->value.bytes.data))[0]
+				&= cpu_to_be16(~params->mask);
+			break;
+		case 4:
+			((u32 *)(&ucontrol->value.bytes.data))[0]
+				&= cpu_to_be32(~params->mask);
+			break;
+		default:
+			return -EINVAL;
 		}
 	}
 
-	return 0;
+	return ret;
 }
+EXPORT_SYMBOL_GPL(snd_soc_bytes_get);
 
-struct snd_kcontrol *snd_soc_card_get_kcontrol(struct snd_soc_card *soc_card,
-					       const char *name)
+int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
+		      struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_card *card = soc_card->snd_card;
-	struct snd_kcontrol *kctl;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_bytes *params = (void *)kcontrol->private_value;
+	int ret, len;
+	unsigned int val, mask;
+	void *data;
 
-	if (unlikely(!name))
-		return NULL;
+	if (!component->regmap)
+		return -EINVAL;
 
-	list_for_each_entry(kctl, &card->controls, list)
-		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name)))
-			return kctl;
-	return NULL;
+	len = params->num_regs * component->val_bytes;
+
+	data = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);
+	if (!data)
+		return -ENOMEM;
+
+	/*
+	 * If we've got a mask then we need to preserve the register
+	 * bits.  We shouldn't modify the incoming data so take a
+	 * copy.
+	 */
+	if (params->mask) {
+		ret = regmap_read(component->regmap, params->base, &val);
+		if (ret != 0)
+			goto out;
+
+		val &= params->mask;
+
+		switch (component->val_bytes) {
+		case 1:
+			((u8 *)data)[0] &= ~params->mask;
+			((u8 *)data)[0] |= val;
+			break;
+		case 2:
+			mask = ~params->mask;
+			ret = regmap_parse_val(component->regmap,
+							&mask, &mask);
+			if (ret != 0)
+				goto out;
+
+			((u16 *)data)[0] &= mask;
+
+			ret = regmap_parse_val(component->regmap,
+							&val, &val);
+			if (ret != 0)
+				goto out;
+
+			((u16 *)data)[0] |= val;
+			break;
+		case 4:
+			mask = ~params->mask;
+			ret = regmap_parse_val(component->regmap,
+							&mask, &mask);
+			if (ret != 0)
+				goto out;
+
+			((u32 *)data)[0] &= mask;
+
+			ret = regmap_parse_val(component->regmap,
+							&val, &val);
+			if (ret != 0)
+				goto out;
+
+			((u32 *)data)[0] |= val;
+			break;
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+
+	ret = regmap_raw_write(component->regmap, params->base,
+			       data, len);
+
+out:
+	kfree(data);
+
+	return ret;
 }
-EXPORT_SYMBOL_GPL(snd_soc_card_get_kcontrol);
+EXPORT_SYMBOL_GPL(snd_soc_bytes_put);
+
+int snd_soc_bytes_info_ext(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *ucontrol)
+{
+	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
+
+	ucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	ucontrol->count = params->max;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_bytes_info_ext);
+
+int snd_soc_bytes_tlv_callback(struct snd_kcontrol *kcontrol, int op_flag,
+				unsigned int size, unsigned int __user *tlv)
+{
+	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
+	unsigned int count = size < params->max ? size : params->max;
+	int ret = -ENXIO;
+
+	switch (op_flag) {
+	case SNDRV_CTL_TLV_OP_READ:
+		if (params->get)
+			ret = params->get(tlv, count);
+		break;
+	case SNDRV_CTL_TLV_OP_WRITE:
+		if (params->put)
+			ret = params->put(tlv, count);
+		break;
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_bytes_tlv_callback);
 
 /**
- * snd_soc_add_component_controls - Add an array of controls to a component.
+ * snd_soc_info_xr_sx - signed multi register info callback
+ * @kcontrol: mreg control
+ * @uinfo: control element information
  *
- * @component: Component to add controls to
- * @controls: Array of controls to add
- * @num_controls: Number of elements in the array
+ * Callback to provide information of a control that can
+ * span multiple codec registers which together
+ * forms a single signed value in a MSB/LSB manner.
  *
- * Return: 0 for success, else error.
+ * Returns 0 for success.
  */
-int snd_soc_add_component_controls(struct snd_soc_component *component,
-	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+int snd_soc_info_xr_sx(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
 {
-	struct snd_card *card = component->card->snd_card;
+	struct soc_mreg_control *mc =
+		(struct soc_mreg_control *)kcontrol->private_value;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = mc->min;
+	uinfo->value.integer.max = mc->max;
 
-	return snd_soc_add_controls(card, component->dev, controls,
-			num_controls, component->name_prefix, component);
+	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_component_controls);
+EXPORT_SYMBOL_GPL(snd_soc_info_xr_sx);
 
 /**
- * snd_soc_add_codec_controls - add an array of controls to a codec.
- * Convenience function to add a list of controls. Many codecs were
- * duplicating this code.
+ * snd_soc_get_xr_sx - signed multi register get callback
+ * @kcontrol: mreg control
+ * @ucontrol: control element information
  *
- * @codec: codec to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
+ * Callback to get the value of a control that can span
+ * multiple codec registers which together forms a single
+ * signed value in a MSB/LSB manner. The control supports
+ * specifying total no of bits used to allow for bitfields
+ * across the multiple codec registers.
  *
- * Return 0 for success, else error.
+ * Returns 0 for success.
  */
-int snd_soc_add_codec_controls(struct snd_soc_codec *codec,
-	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+int snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
 {
-	return snd_soc_add_component_controls(&codec->component, controls,
-		num_controls);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mreg_control *mc =
+		(struct soc_mreg_control *)kcontrol->private_value;
+	unsigned int regbase = mc->regbase;
+	unsigned int regcount = mc->regcount;
+	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
+	unsigned int regwmask = (1<<regwshift)-1;
+	unsigned int invert = mc->invert;
+	unsigned long mask = (1UL<<mc->nbits)-1;
+	long min = mc->min;
+	long max = mc->max;
+	long val = 0;
+	unsigned int regval;
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < regcount; i++) {
+		ret = snd_soc_component_read(component, regbase+i, &regval);
+		if (ret)
+			return ret;
+		val |= (regval & regwmask) << (regwshift*(regcount-i-1));
+	}
+	val &= mask;
+	if (min < 0 && val > max)
+		val |= ~mask;
+	if (invert)
+		val = max - val;
+	ucontrol->value.integer.value[0] = val;
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_codec_controls);
+EXPORT_SYMBOL_GPL(snd_soc_get_xr_sx);
 
 /**
- * snd_soc_add_platform_controls - add an array of controls to a platform.
- * Convenience function to add a list of controls.
+ * snd_soc_put_xr_sx - signed multi register get callback
+ * @kcontrol: mreg control
+ * @ucontrol: control element information
  *
- * @platform: platform to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
+ * Callback to set the value of a control that can span
+ * multiple codec registers which together forms a single
+ * signed value in a MSB/LSB manner. The control supports
+ * specifying total no of bits used to allow for bitfields
+ * across the multiple codec registers.
  *
- * Return 0 for success, else error.
+ * Returns 0 for success.
  */
-int snd_soc_add_platform_controls(struct snd_soc_platform *platform,
-	const struct snd_kcontrol_new *controls, unsigned int num_controls)
+int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
 {
-	return snd_soc_add_component_controls(&platform->component, controls,
-		num_controls);
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mreg_control *mc =
+		(struct soc_mreg_control *)kcontrol->private_value;
+	unsigned int regbase = mc->regbase;
+	unsigned int regcount = mc->regcount;
+	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
+	unsigned int regwmask = (1<<regwshift)-1;
+	unsigned int invert = mc->invert;
+	unsigned long mask = (1UL<<mc->nbits)-1;
+	long max = mc->max;
+	long val = ucontrol->value.integer.value[0];
+	unsigned int i, regval, regmask;
+	int err;
+
+	if (invert)
+		val = max - val;
+	val &= mask;
+	for (i = 0; i < regcount; i++) {
+		regval = (val >> (regwshift*(regcount-i-1))) & regwmask;
+		regmask = (mask >> (regwshift*(regcount-i-1))) & regwmask;
+		err = snd_soc_component_update_bits(component, regbase+i,
+				regmask, regval);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_platform_controls);
+EXPORT_SYMBOL_GPL(snd_soc_put_xr_sx);
 
 /**
- * snd_soc_add_card_controls - add an array of controls to a SoC card.
- * Convenience function to add a list of controls.
+ * snd_soc_get_strobe - strobe get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
  *
- * @soc_card: SoC card to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
+ * Callback get the value of a strobe mixer control.
  *
- * Return 0 for success, else error.
+ * Returns 0 for success.
  */
-int snd_soc_add_card_controls(struct snd_soc_card *soc_card,
-	const struct snd_kcontrol_new *controls, int num_controls)
+int snd_soc_get_strobe(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_card *card = soc_card->snd_card;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = 1 << shift;
+	unsigned int invert = mc->invert != 0;
+	unsigned int val;
+	int ret;
 
-	return snd_soc_add_controls(card, soc_card->dev, controls, num_controls,
-			NULL, soc_card);
+	ret = snd_soc_component_read(component, reg, &val);
+	if (ret)
+		return ret;
+
+	val &= mask;
+
+	if (shift != 0 && val != 0)
+		val = val >> shift;
+	ucontrol->value.enumerated.item[0] = val ^ invert;
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_card_controls);
+EXPORT_SYMBOL_GPL(snd_soc_get_strobe);
 
 /**
- * snd_soc_add_dai_controls - add an array of controls to a DAI.
- * Convienience function to add a list of controls.
+ * snd_soc_put_strobe - strobe put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
  *
- * @dai: DAI to add controls to
- * @controls: array of controls to add
- * @num_controls: number of elements in the array
+ * Callback strobe a register bit to high then low (or the inverse)
+ * in one pass of a single mixer enum control.
  *
- * Return 0 for success, else error.
+ * Returns 1 for success.
  */
-int snd_soc_add_dai_controls(struct snd_soc_dai *dai,
-	const struct snd_kcontrol_new *controls, int num_controls)
+int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_card *card = dai->component->card->snd_card;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int mask = 1 << shift;
+	unsigned int invert = mc->invert != 0;
+	unsigned int strobe = ucontrol->value.enumerated.item[0] != 0;
+	unsigned int val1 = (strobe ^ invert) ? mask : 0;
+	unsigned int val2 = (strobe ^ invert) ? 0 : mask;
+	int err;
 
-	return snd_soc_add_controls(card, dai->dev, controls, num_controls,
-			NULL, dai);
+	err = snd_soc_component_update_bits(component, reg, mask, val1);
+	if (err < 0)
+		return err;
+
+	return snd_soc_component_update_bits(component, reg, mask, val2);
 }
-EXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);
+EXPORT_SYMBOL_GPL(snd_soc_put_strobe);
 
 /**
  * snd_soc_dai_set_sysclk - configure DAI system or master clock.
@@ -2382,11 +3928,8 @@
  */
 int snd_soc_unregister_card(struct snd_soc_card *card)
 {
-	if (card->instantiated) {
-		card->instantiated = false;
-		snd_soc_dapm_shutdown(card);
+	if (card->instantiated)
 		soc_cleanup_card_resources(card);
-	}
 	dev_dbg(card->dev, "ASoC: Unregistered card '%s'\n", card->name);
 
 	return 0;
@@ -2573,8 +4116,6 @@
 
 	component->dev = dev;
 	component->driver = driver;
-	component->probe = component->driver->probe;
-	component->remove = component->driver->remove;
 
 	if (!component->dapm_ptr)
 		component->dapm_ptr = &component->dapm;
@@ -2583,82 +4124,19 @@
 	dapm->dev = dev;
 	dapm->component = component;
 	dapm->bias_level = SND_SOC_BIAS_OFF;
-	dapm->idle_bias_off = true;
 	if (driver->seq_notifier)
 		dapm->seq_notifier = snd_soc_component_seq_notifier;
 	if (driver->stream_event)
 		dapm->stream_event = snd_soc_component_stream_event;
 
-	component->controls = driver->controls;
-	component->num_controls = driver->num_controls;
-	component->dapm_widgets = driver->dapm_widgets;
-	component->num_dapm_widgets = driver->num_dapm_widgets;
-	component->dapm_routes = driver->dapm_routes;
-	component->num_dapm_routes = driver->num_dapm_routes;
-
 	INIT_LIST_HEAD(&component->dai_list);
 	mutex_init(&component->io_mutex);
 
 	return 0;
 }
 
-static void snd_soc_component_setup_regmap(struct snd_soc_component *component)
-{
-	int val_bytes = regmap_get_val_bytes(component->regmap);
-
-	/* Errors are legitimate for non-integer byte multiples */
-	if (val_bytes > 0)
-		component->val_bytes = val_bytes;
-}
-
-#ifdef CONFIG_REGMAP
-
-/**
- * snd_soc_component_init_regmap() - Initialize regmap instance for the component
- * @component: The component for which to initialize the regmap instance
- * @regmap: The regmap instance that should be used by the component
- *
- * This function allows deferred assignment of the regmap instance that is
- * associated with the component. Only use this if the regmap instance is not
- * yet ready when the component is registered. The function must also be called
- * before the first IO attempt of the component.
- */
-void snd_soc_component_init_regmap(struct snd_soc_component *component,
-	struct regmap *regmap)
-{
-	component->regmap = regmap;
-	snd_soc_component_setup_regmap(component);
-}
-EXPORT_SYMBOL_GPL(snd_soc_component_init_regmap);
-
-/**
- * snd_soc_component_exit_regmap() - De-initialize regmap instance for the component
- * @component: The component for which to de-initialize the regmap instance
- *
- * Calls regmap_exit() on the regmap instance associated to the component and
- * removes the regmap instance from the component.
- *
- * This function should only be used if snd_soc_component_init_regmap() was used
- * to initialize the regmap instance.
- */
-void snd_soc_component_exit_regmap(struct snd_soc_component *component)
-{
-	regmap_exit(component->regmap);
-	component->regmap = NULL;
-}
-EXPORT_SYMBOL_GPL(snd_soc_component_exit_regmap);
-
-#endif
-
 static void snd_soc_component_add_unlocked(struct snd_soc_component *component)
 {
-	if (!component->write && !component->read) {
-		if (!component->regmap)
-			component->regmap = dev_get_regmap(component->dev, NULL);
-		if (component->regmap)
-			snd_soc_component_setup_regmap(component);
-	}
-
 	list_add(&component->list, &component_list);
 }
 
@@ -2747,18 +4225,22 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_unregister_component);
 
-static int snd_soc_platform_drv_probe(struct snd_soc_component *component)
+static int snd_soc_platform_drv_write(struct snd_soc_component *component,
+	unsigned int reg, unsigned int val)
 {
 	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
 
-	return platform->driver->probe(platform);
+	return platform->driver->write(platform, reg, val);
 }
 
-static void snd_soc_platform_drv_remove(struct snd_soc_component *component)
+static int snd_soc_platform_drv_read(struct snd_soc_component *component,
+	unsigned int reg, unsigned int *val)
 {
 	struct snd_soc_platform *platform = snd_soc_component_to_platform(component);
 
-	platform->driver->remove(platform);
+	*val = platform->driver->read(platform, reg);
+
+	return 0;
 }
 
 /**
@@ -2779,15 +4261,10 @@
 
 	platform->dev = dev;
 	platform->driver = platform_drv;
-
-	if (platform_drv->probe)
-		platform->component.probe = snd_soc_platform_drv_probe;
-	if (platform_drv->remove)
-		platform->component.remove = snd_soc_platform_drv_remove;
-
-#ifdef CONFIG_DEBUG_FS
-	platform->component.debugfs_prefix = "platform";
-#endif
+	if (platform_drv->write)
+		platform->component.write = snd_soc_platform_drv_write;
+	if (platform_drv->read)
+		platform->component.read = snd_soc_platform_drv_read;
 
 	mutex_lock(&client_mutex);
 	snd_soc_component_add_unlocked(&platform->component);
@@ -2838,10 +4315,10 @@
 	snd_soc_component_del_unlocked(&platform->component);
 	mutex_unlock(&client_mutex);
 
+	snd_soc_component_cleanup(&platform->component);
+
 	dev_dbg(platform->dev, "ASoC: Unregistered platform '%s'\n",
 		platform->component.name);
-
-	snd_soc_component_cleanup(&platform->component);
 }
 EXPORT_SYMBOL_GPL(snd_soc_remove_platform);
 
@@ -2909,20 +4386,6 @@
 			stream->formats |= codec_format_map[i];
 }
 
-static int snd_soc_codec_drv_probe(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	return codec->driver->probe(codec);
-}
-
-static void snd_soc_codec_drv_remove(struct snd_soc_component *component)
-{
-	struct snd_soc_codec *codec = snd_soc_component_to_codec(component);
-
-	codec->driver->remove(codec);
-}
-
 static int snd_soc_codec_drv_write(struct snd_soc_component *component,
 	unsigned int reg, unsigned int val)
 {
@@ -2961,6 +4424,7 @@
 {
 	struct snd_soc_codec *codec;
 	struct snd_soc_dai *dai;
+	struct regmap *regmap;
 	int ret, i;
 
 	dev_dbg(dev, "codec register %s\n", dev_name(dev));
@@ -2970,37 +4434,18 @@
 		return -ENOMEM;
 
 	codec->component.dapm_ptr = &codec->dapm;
-	codec->component.codec = codec;
 
 	ret = snd_soc_component_initialize(&codec->component,
 			&codec_drv->component_driver, dev);
 	if (ret)
 		goto err_free;
 
-	if (codec_drv->controls) {
-		codec->component.controls = codec_drv->controls;
-		codec->component.num_controls = codec_drv->num_controls;
-	}
-	if (codec_drv->dapm_widgets) {
-		codec->component.dapm_widgets = codec_drv->dapm_widgets;
-		codec->component.num_dapm_widgets = codec_drv->num_dapm_widgets;
-	}
-	if (codec_drv->dapm_routes) {
-		codec->component.dapm_routes = codec_drv->dapm_routes;
-		codec->component.num_dapm_routes = codec_drv->num_dapm_routes;
-	}
-
-	if (codec_drv->probe)
-		codec->component.probe = snd_soc_codec_drv_probe;
-	if (codec_drv->remove)
-		codec->component.remove = snd_soc_codec_drv_remove;
 	if (codec_drv->write)
 		codec->component.write = snd_soc_codec_drv_write;
 	if (codec_drv->read)
 		codec->component.read = snd_soc_codec_drv_read;
 	codec->component.ignore_pmdown_time = codec_drv->ignore_pmdown_time;
-	codec->dapm.idle_bias_off = codec_drv->idle_bias_off;
-	codec->dapm.suspend_bias_off = codec_drv->suspend_bias_off;
+	codec->dapm.codec = codec;
 	if (codec_drv->seq_notifier)
 		codec->dapm.seq_notifier = codec_drv->seq_notifier;
 	if (codec_drv->set_bias_level)
@@ -3008,14 +4453,25 @@
 	codec->dev = dev;
 	codec->driver = codec_drv;
 	codec->component.val_bytes = codec_drv->reg_word_size;
+	mutex_init(&codec->mutex);
 
-#ifdef CONFIG_DEBUG_FS
-	codec->component.init_debugfs = soc_init_codec_debugfs;
-	codec->component.debugfs_prefix = "codec";
-#endif
+	if (!codec->component.write) {
+		if (codec_drv->get_regmap)
+			regmap = codec_drv->get_regmap(dev);
+		else
+			regmap = dev_get_regmap(dev, NULL);
 
-	if (codec_drv->get_regmap)
-		codec->component.regmap = codec_drv->get_regmap(dev);
+		if (regmap) {
+			ret = snd_soc_component_init_io(&codec->component,
+				regmap);
+			if (ret) {
+				dev_err(codec->dev,
+						"Failed to set cache I/O:%d\n",
+						ret);
+				goto err_cleanup;
+			}
+		}
+	}
 
 	for (i = 0; i < num_dai; i++) {
 		fixup_codec_formats(&dai_drv[i].playback);
@@ -3395,30 +4851,36 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_daifmt);
 
-static int snd_soc_get_dai_name(struct of_phandle_args *args,
-				const char **dai_name)
+int snd_soc_of_get_dai_name(struct device_node *of_node,
+			    const char **dai_name)
 {
 	struct snd_soc_component *pos;
-	int ret = -EPROBE_DEFER;
+	struct of_phandle_args args;
+	int ret;
+
+	ret = of_parse_phandle_with_args(of_node, "sound-dai",
+					 "#sound-dai-cells", 0, &args);
+	if (ret)
+		return ret;
+
+	ret = -EPROBE_DEFER;
 
 	mutex_lock(&client_mutex);
 	list_for_each_entry(pos, &component_list, list) {
-		if (pos->dev->of_node != args->np)
+		if (pos->dev->of_node != args.np)
 			continue;
 
 		if (pos->driver->of_xlate_dai_name) {
-			ret = pos->driver->of_xlate_dai_name(pos,
-							     args,
-							     dai_name);
+			ret = pos->driver->of_xlate_dai_name(pos, &args, dai_name);
 		} else {
 			int id = -1;
 
-			switch (args->args_count) {
+			switch (args.args_count) {
 			case 0:
 				id = 0; /* same as dai_drv[0] */
 				break;
 			case 1:
-				id = args->args[0];
+				id = args.args[0];
 				break;
 			default:
 				/* not supported */
@@ -3440,21 +4902,6 @@
 		break;
 	}
 	mutex_unlock(&client_mutex);
-	return ret;
-}
-
-int snd_soc_of_get_dai_name(struct device_node *of_node,
-			    const char **dai_name)
-{
-	struct of_phandle_args args;
-	int ret;
-
-	ret = of_parse_phandle_with_args(of_node, "sound-dai",
-					 "#sound-dai-cells", 0, &args);
-	if (ret)
-		return ret;
-
-	ret = snd_soc_get_dai_name(&args, dai_name);
 
 	of_node_put(args.np);
 
@@ -3462,77 +4909,6 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_name);
 
-/*
- * snd_soc_of_get_dai_link_codecs - Parse a list of CODECs in the devicetree
- * @dev: Card device
- * @of_node: Device node
- * @dai_link: DAI link
- *
- * Builds an array of CODEC DAI components from the DAI link property
- * 'sound-dai'.
- * The array is set in the DAI link and the number of DAIs is set accordingly.
- * The device nodes in the array (of_node) must be dereferenced by the caller.
- *
- * Returns 0 for success
- */
-int snd_soc_of_get_dai_link_codecs(struct device *dev,
-				   struct device_node *of_node,
-				   struct snd_soc_dai_link *dai_link)
-{
-	struct of_phandle_args args;
-	struct snd_soc_dai_link_component *component;
-	char *name;
-	int index, num_codecs, ret;
-
-	/* Count the number of CODECs */
-	name = "sound-dai";
-	num_codecs = of_count_phandle_with_args(of_node, name,
-						"#sound-dai-cells");
-	if (num_codecs <= 0) {
-		if (num_codecs == -ENOENT)
-			dev_err(dev, "No 'sound-dai' property\n");
-		else
-			dev_err(dev, "Bad phandle in 'sound-dai'\n");
-		return num_codecs;
-	}
-	component = devm_kzalloc(dev,
-				 sizeof *component * num_codecs,
-				 GFP_KERNEL);
-	if (!component)
-		return -ENOMEM;
-	dai_link->codecs = component;
-	dai_link->num_codecs = num_codecs;
-
-	/* Parse the list */
-	for (index = 0, component = dai_link->codecs;
-	     index < dai_link->num_codecs;
-	     index++, component++) {
-		ret = of_parse_phandle_with_args(of_node, name,
-						 "#sound-dai-cells",
-						  index, &args);
-		if (ret)
-			goto err;
-		component->of_node = args.np;
-		ret = snd_soc_get_dai_name(&args, &component->dai_name);
-		if (ret < 0)
-			goto err;
-	}
-	return 0;
-err:
-	for (index = 0, component = dai_link->codecs;
-	     index < dai_link->num_codecs;
-	     index++, component++) {
-		if (!component->of_node)
-			break;
-		of_node_put(component->of_node);
-		component->of_node = NULL;
-	}
-	dai_link->codecs = NULL;
-	dai_link->num_codecs = 0;
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_of_get_dai_link_codecs);
-
 static int __init snd_soc_init(void)
 {
 #ifdef CONFIG_DEBUG_FS
diff -Naur linux-3.19.old/sound/soc/soc-dapm.c linux-3.19/sound/soc/soc-dapm.c
--- linux-3.19.old/sound/soc/soc-dapm.c	2015-03-24 17:38:14.656510269 -0800
+++ linux-3.19/sound/soc/soc-dapm.c	2015-03-24 18:36:44.528028363 -0800
@@ -159,135 +159,27 @@
 	}
 }
 
-/*
- * dapm_widget_invalidate_input_paths() - Invalidate the cached number of input
- *  paths
- * @w: The widget for which to invalidate the cached number of input paths
- *
- * The function resets the cached number of inputs for the specified widget and
- * all widgets that can be reached via outgoing paths from the widget.
- *
- * This function must be called if the number of input paths for a widget might
- * have changed. E.g. if the source state of a widget changes or a path is added
- * or activated with the widget as the sink.
- */
-static void dapm_widget_invalidate_input_paths(struct snd_soc_dapm_widget *w)
-{
-	struct snd_soc_dapm_widget *sink;
-	struct snd_soc_dapm_path *p;
-	LIST_HEAD(list);
-
-	dapm_assert_locked(w->dapm);
-
-	if (w->inputs == -1)
-		return;
-
-	w->inputs = -1;
-	list_add_tail(&w->work_list, &list);
-
-	list_for_each_entry(w, &list, work_list) {
-		list_for_each_entry(p, &w->sinks, list_source) {
-			if (p->is_supply || p->weak || !p->connect)
-				continue;
-			sink = p->sink;
-			if (sink->inputs != -1) {
-				sink->inputs = -1;
-				list_add_tail(&sink->work_list, &list);
-			}
-		}
-	}
-}
-
-/*
- * dapm_widget_invalidate_output_paths() - Invalidate the cached number of
- *  output paths
- * @w: The widget for which to invalidate the cached number of output paths
- *
- * Resets the cached number of outputs for the specified widget and all widgets
- * that can be reached via incoming paths from the widget.
- *
- * This function must be called if the number of output paths for a widget might
- * have changed. E.g. if the sink state of a widget changes or a path is added
- * or activated with the widget as the source.
- */
-static void dapm_widget_invalidate_output_paths(struct snd_soc_dapm_widget *w)
-{
-	struct snd_soc_dapm_widget *source;
-	struct snd_soc_dapm_path *p;
-	LIST_HEAD(list);
-
-	dapm_assert_locked(w->dapm);
-
-	if (w->outputs == -1)
-		return;
-
-	w->outputs = -1;
-	list_add_tail(&w->work_list, &list);
-
-	list_for_each_entry(w, &list, work_list) {
-		list_for_each_entry(p, &w->sources, list_sink) {
-			if (p->is_supply || p->weak || !p->connect)
-				continue;
-			source = p->source;
-			if (source->outputs != -1) {
-				source->outputs = -1;
-				list_add_tail(&source->work_list, &list);
-			}
-		}
-	}
-}
-
-/*
- * dapm_path_invalidate() - Invalidates the cached number of inputs and outputs
- *  for the widgets connected to a path
- * @p: The path to invalidate
- *
- * Resets the cached number of inputs for the sink of the path and the cached
- * number of outputs for the source of the path.
- *
- * This function must be called when a path is added, removed or the connected
- * state changes.
- */
-static void dapm_path_invalidate(struct snd_soc_dapm_path *p)
-{
-	/*
-	 * Weak paths or supply paths do not influence the number of input or
-	 * output paths of their neighbors.
-	 */
-	if (p->weak || p->is_supply)
-		return;
-
-	/*
-	 * The number of connected endpoints is the sum of the number of
-	 * connected endpoints of all neighbors. If a node with 0 connected
-	 * endpoints is either connected or disconnected that sum won't change,
-	 * so there is no need to re-check the path.
-	 */
-	if (p->source->inputs != 0)
-		dapm_widget_invalidate_input_paths(p->sink);
-	if (p->sink->outputs != 0)
-		dapm_widget_invalidate_output_paths(p->source);
-}
-
-void dapm_mark_endpoints_dirty(struct snd_soc_card *card)
+void dapm_mark_io_dirty(struct snd_soc_dapm_context *dapm)
 {
+	struct snd_soc_card *card = dapm->card;
 	struct snd_soc_dapm_widget *w;
 
 	mutex_lock(&card->dapm_mutex);
 
 	list_for_each_entry(w, &card->widgets, list) {
-		if (w->is_sink || w->is_source) {
-			dapm_mark_dirty(w, "Rechecking endpoints");
-			if (w->is_sink)
-				dapm_widget_invalidate_output_paths(w);
-			if (w->is_source)
-				dapm_widget_invalidate_input_paths(w);
+		switch (w->id) {
+		case snd_soc_dapm_input:
+		case snd_soc_dapm_output:
+			dapm_mark_dirty(w, "Rechecking inputs and outputs");
+			break;
+		default:
+			break;
 		}
 	}
 
 	mutex_unlock(&card->dapm_mutex);
 }
-EXPORT_SYMBOL_GPL(dapm_mark_endpoints_dirty);
+EXPORT_SYMBOL_GPL(dapm_mark_io_dirty);
 
 /* create a new dapm widget */
 static inline struct snd_soc_dapm_widget *dapm_cnew_widget(
@@ -434,13 +326,12 @@
 	list_for_each_entry(path, dapm_kcontrol_get_path_list(kcontrol), \
 		list_kcontrol)
 
-unsigned int dapm_kcontrol_get_value(const struct snd_kcontrol *kcontrol)
+static unsigned int dapm_kcontrol_get_value(const struct snd_kcontrol *kcontrol)
 {
 	struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);
 
 	return data->value;
 }
-EXPORT_SYMBOL_GPL(dapm_kcontrol_get_value);
 
 static bool dapm_kcontrol_set_value(const struct snd_kcontrol *kcontrol,
 	unsigned int value)
@@ -494,6 +385,8 @@
 	list_for_each_entry(w, &card->widgets, list) {
 		w->new_power = w->power;
 		w->power_checked = false;
+		w->inputs = -1;
+		w->outputs = -1;
 	}
 }
 
@@ -575,9 +468,10 @@
 
 /* connect mux widget to its interconnecting audio paths */
 static int dapm_connect_mux(struct snd_soc_dapm_context *dapm,
-	struct snd_soc_dapm_path *path, const char *control_name)
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
+	struct snd_soc_dapm_path *path, const char *control_name,
+	const struct snd_kcontrol_new *kcontrol)
 {
-	const struct snd_kcontrol_new *kcontrol = &path->sink->kcontrol_news[0];
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned int val, item;
 	int i;
@@ -598,7 +492,10 @@
 
 	for (i = 0; i < e->items; i++) {
 		if (!(strcmp(control_name, e->texts[i]))) {
-			path->name = e->texts[i];
+			list_add(&path->list, &dapm->card->paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = (char*)e->texts[i];
 			if (i == item)
 				path->connect = 1;
 			else
@@ -611,10 +508,11 @@
 }
 
 /* set up initial codec paths */
-static void dapm_set_mixer_path_status(struct snd_soc_dapm_path *p, int i)
+static void dapm_set_mixer_path_status(struct snd_soc_dapm_widget *w,
+	struct snd_soc_dapm_path *p, int i)
 {
 	struct soc_mixer_control *mc = (struct soc_mixer_control *)
-		p->sink->kcontrol_news[i].private_value;
+		w->kcontrol_news[i].private_value;
 	unsigned int reg = mc->reg;
 	unsigned int shift = mc->shift;
 	unsigned int max = mc->max;
@@ -623,7 +521,7 @@
 	unsigned int val;
 
 	if (reg != SND_SOC_NOPM) {
-		soc_dapm_read(p->sink->dapm, reg, &val);
+		soc_dapm_read(w->dapm, reg, &val);
 		val = (val >> shift) & mask;
 		if (invert)
 			val = max - val;
@@ -635,15 +533,19 @@
 
 /* connect mixer widget to its interconnecting audio paths */
 static int dapm_connect_mixer(struct snd_soc_dapm_context *dapm,
+	struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,
 	struct snd_soc_dapm_path *path, const char *control_name)
 {
 	int i;
 
 	/* search for mixer kcontrol */
-	for (i = 0; i < path->sink->num_kcontrols; i++) {
-		if (!strcmp(control_name, path->sink->kcontrol_news[i].name)) {
-			path->name = path->sink->kcontrol_news[i].name;
-			dapm_set_mixer_path_status(path, i);
+	for (i = 0; i < dest->num_kcontrols; i++) {
+		if (!strcmp(control_name, dest->kcontrol_news[i].name)) {
+			list_add(&path->list, &dapm->card->paths);
+			list_add(&path->list_sink, &dest->sources);
+			list_add(&path->list_source, &src->sinks);
+			path->name = dest->kcontrol_news[i].name;
+			dapm_set_mixer_path_status(dest, path, i);
 			return 0;
 		}
 	}
@@ -689,9 +591,9 @@
 	int shared;
 	struct snd_kcontrol *kcontrol;
 	bool wname_in_long_name, kcname_in_long_name;
-	char *long_name = NULL;
+	char *long_name;
 	const char *name;
-	int ret = 0;
+	int ret;
 
 	prefix = soc_dapm_prefix(dapm);
 	if (prefix)
@@ -750,17 +652,15 @@
 
 		kcontrol = snd_soc_cnew(&w->kcontrol_news[kci], NULL, name,
 					prefix);
-		if (!kcontrol) {
-			ret = -ENOMEM;
-			goto exit_free;
-		}
-
+		kfree(long_name);
+		if (!kcontrol)
+			return -ENOMEM;
 		kcontrol->private_free = dapm_kcontrol_free;
 
 		ret = dapm_kcontrol_data_alloc(w, kcontrol);
 		if (ret) {
 			snd_ctl_free_one(kcontrol);
-			goto exit_free;
+			return ret;
 		}
 
 		ret = snd_ctl_add(card, kcontrol);
@@ -768,18 +668,17 @@
 			dev_err(dapm->dev,
 				"ASoC: failed to add widget %s dapm kcontrol %s: %d\n",
 				w->name, name, ret);
-			goto exit_free;
+			return ret;
 		}
 	}
 
 	ret = dapm_kcontrol_add_widget(kcontrol, w);
-	if (ret == 0)
-		w->kcontrols[kci] = kcontrol;
+	if (ret)
+		return ret;
 
-exit_free:
-	kfree(long_name);
+	w->kcontrols[kci] = kcontrol;
 
-	return ret;
+	return 0;
 }
 
 /* create new dapm mixer control */
@@ -835,10 +734,8 @@
 	if (ret < 0)
 		return ret;
 
-	list_for_each_entry(path, &w->sources, list_sink) {
-		if (path->name)
-			dapm_kcontrol_add_path(w->kcontrols[0], path);
-	}
+	list_for_each_entry(path, &w->sources, list_sink)
+		dapm_kcontrol_add_path(w->kcontrols[0], path);
 
 	return 0;
 }
@@ -853,6 +750,34 @@
 	return 0;
 }
 
+/* reset 'walked' bit for each dapm path */
+static void dapm_clear_walk_output(struct snd_soc_dapm_context *dapm,
+				   struct list_head *sink)
+{
+	struct snd_soc_dapm_path *p;
+
+	list_for_each_entry(p, sink, list_source) {
+		if (p->walked) {
+			p->walked = 0;
+			dapm_clear_walk_output(dapm, &p->sink->sinks);
+		}
+	}
+}
+
+static void dapm_clear_walk_input(struct snd_soc_dapm_context *dapm,
+				  struct list_head *source)
+{
+	struct snd_soc_dapm_path *p;
+
+	list_for_each_entry(p, source, list_sink) {
+		if (p->walked) {
+			p->walked = 0;
+			dapm_clear_walk_input(dapm, &p->source->sources);
+		}
+	}
+}
+
+
 /* We implement power down on suspend by checking the power state of
  * the ALSA card - when we are suspending the ALSA state for the card
  * is set to D3.
@@ -927,23 +852,61 @@
 
 	DAPM_UPDATE_STAT(widget, path_checks);
 
-	if (widget->is_sink && widget->connected) {
-		widget->outputs = snd_soc_dapm_suspend_check(widget);
-		return widget->outputs;
+	switch (widget->id) {
+	case snd_soc_dapm_supply:
+	case snd_soc_dapm_regulator_supply:
+	case snd_soc_dapm_clock_supply:
+	case snd_soc_dapm_kcontrol:
+		return 0;
+	default:
+		break;
+	}
+
+	switch (widget->id) {
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_aif_out:
+	case snd_soc_dapm_dai_out:
+		if (widget->active) {
+			widget->outputs = snd_soc_dapm_suspend_check(widget);
+			return widget->outputs;
+		}
+	default:
+		break;
+	}
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_output && !widget->ext) {
+			widget->outputs = snd_soc_dapm_suspend_check(widget);
+			return widget->outputs;
+		}
+
+		/* connected jack or spk ? */
+		if (widget->id == snd_soc_dapm_hp ||
+		    widget->id == snd_soc_dapm_spk ||
+		    (widget->id == snd_soc_dapm_line &&
+		     !list_empty(&widget->sources))) {
+			widget->outputs = snd_soc_dapm_suspend_check(widget);
+			return widget->outputs;
+		}
 	}
 
 	list_for_each_entry(path, &widget->sinks, list_source) {
 		DAPM_UPDATE_STAT(widget, neighbour_checks);
 
-		if (path->weak || path->is_supply)
+		if (path->weak)
 			continue;
 
 		if (path->walking)
 			return 1;
 
+		if (path->walked)
+			continue;
+
 		trace_snd_soc_dapm_output_path(widget, path);
 
-		if (path->connect) {
+		if (path->sink && path->connect) {
+			path->walked = 1;
 			path->walking = 1;
 
 			/* do we need to add this widget to the list ? */
@@ -985,23 +948,73 @@
 
 	DAPM_UPDATE_STAT(widget, path_checks);
 
-	if (widget->is_source && widget->connected) {
-		widget->inputs = snd_soc_dapm_suspend_check(widget);
-		return widget->inputs;
+	switch (widget->id) {
+	case snd_soc_dapm_supply:
+	case snd_soc_dapm_regulator_supply:
+	case snd_soc_dapm_clock_supply:
+	case snd_soc_dapm_kcontrol:
+		return 0;
+	default:
+		break;
+	}
+
+	/* active stream ? */
+	switch (widget->id) {
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_aif_in:
+	case snd_soc_dapm_dai_in:
+		if (widget->active) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
+	default:
+		break;
+	}
+
+	if (widget->connected) {
+		/* connected pin ? */
+		if (widget->id == snd_soc_dapm_input && !widget->ext) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
+
+		/* connected VMID/Bias for lower pops */
+		if (widget->id == snd_soc_dapm_vmid) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
+
+		/* connected jack ? */
+		if (widget->id == snd_soc_dapm_mic ||
+		    (widget->id == snd_soc_dapm_line &&
+		     !list_empty(&widget->sinks))) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
+
+		/* signal generator */
+		if (widget->id == snd_soc_dapm_siggen) {
+			widget->inputs = snd_soc_dapm_suspend_check(widget);
+			return widget->inputs;
+		}
 	}
 
 	list_for_each_entry(path, &widget->sources, list_sink) {
 		DAPM_UPDATE_STAT(widget, neighbour_checks);
 
-		if (path->weak || path->is_supply)
+		if (path->weak)
 			continue;
 
 		if (path->walking)
 			return 1;
 
+		if (path->walked)
+			continue;
+
 		trace_snd_soc_dapm_input_path(widget, path);
 
-		if (path->connect) {
+		if (path->source && path->connect) {
+			path->walked = 1;
 			path->walking = 1;
 
 			/* do we need to add this widget to the list ? */
@@ -1043,25 +1056,21 @@
 int snd_soc_dapm_dai_get_connected_widgets(struct snd_soc_dai *dai, int stream,
 	struct snd_soc_dapm_widget_list **list)
 {
-	struct snd_soc_card *card = dai->component->card;
-	struct snd_soc_dapm_widget *w;
+	struct snd_soc_card *card = dai->card;
 	int paths;
 
 	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
+	dapm_reset(card);
 
-	/*
-	 * For is_connected_{output,input}_ep fully discover the graph we need
-	 * to reset the cached number of inputs and outputs.
-	 */
-	list_for_each_entry(w, &card->widgets, list) {
-		w->inputs = -1;
-		w->outputs = -1;
-	}
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		paths = is_connected_output_ep(dai->playback_widget, list);
-	else
+		dapm_clear_walk_output(&card->dapm,
+				       &dai->playback_widget->sinks);
+	} else {
 		paths = is_connected_input_ep(dai->capture_widget, list);
+		dapm_clear_walk_input(&card->dapm,
+				      &dai->capture_widget->sources);
+	}
 
 	trace_snd_soc_dapm_connected(paths, stream);
 	mutex_unlock(&card->dapm_mutex);
@@ -1150,10 +1159,44 @@
 	DAPM_UPDATE_STAT(w, power_checks);
 
 	in = is_connected_input_ep(w, NULL);
+	dapm_clear_walk_input(w->dapm, &w->sources);
 	out = is_connected_output_ep(w, NULL);
+	dapm_clear_walk_output(w->dapm, &w->sinks);
 	return out != 0 && in != 0;
 }
 
+/* Check to see if an ADC has power */
+static int dapm_adc_check_power(struct snd_soc_dapm_widget *w)
+{
+	int in;
+
+	DAPM_UPDATE_STAT(w, power_checks);
+
+	if (w->active) {
+		in = is_connected_input_ep(w, NULL);
+		dapm_clear_walk_input(w->dapm, &w->sources);
+		return in != 0;
+	} else {
+		return dapm_generic_check_power(w);
+	}
+}
+
+/* Check to see if a DAC has power */
+static int dapm_dac_check_power(struct snd_soc_dapm_widget *w)
+{
+	int out;
+
+	DAPM_UPDATE_STAT(w, power_checks);
+
+	if (w->active) {
+		out = is_connected_output_ep(w, NULL);
+		dapm_clear_walk_output(w->dapm, &w->sinks);
+		return out != 0;
+	} else {
+		return dapm_generic_check_power(w);
+	}
+}
+
 /* Check to see if a power supply is needed */
 static int dapm_supply_check_power(struct snd_soc_dapm_widget *w)
 {
@@ -1172,6 +1215,9 @@
 		    !path->connected(path->source, path->sink))
 			continue;
 
+		if (!path->sink)
+			continue;
+
 		if (dapm_widget_power_check(path->sink))
 			return 1;
 	}
@@ -1586,14 +1632,27 @@
 	/* If we changed our power state perhaps our neigbours changed
 	 * also.
 	 */
-	list_for_each_entry(path, &w->sources, list_sink)
-		dapm_widget_set_peer_power(path->source, power, path->connect);
-
-	/* Supplies can't affect their outputs, only their inputs */
-	if (!w->is_supply) {
-		list_for_each_entry(path, &w->sinks, list_source)
-			dapm_widget_set_peer_power(path->sink, power,
+	list_for_each_entry(path, &w->sources, list_sink) {
+		if (path->source) {
+			dapm_widget_set_peer_power(path->source, power,
 						   path->connect);
+		}
+	}
+	switch (w->id) {
+	case snd_soc_dapm_supply:
+	case snd_soc_dapm_regulator_supply:
+	case snd_soc_dapm_clock_supply:
+	case snd_soc_dapm_kcontrol:
+		/* Supplies can't affect their outputs, only their inputs */
+		break;
+	default:
+		list_for_each_entry(path, &w->sinks, list_source) {
+			if (path->sink) {
+				dapm_widget_set_peer_power(path->sink, power,
+							   path->connect);
+			}
+		}
+		break;
 	}
 
 	if (power)
@@ -1624,22 +1683,6 @@
 	}
 }
 
-static bool dapm_idle_bias_off(struct snd_soc_dapm_context *dapm)
-{
-	if (dapm->idle_bias_off)
-		return true;
-
-	switch (snd_power_get_state(dapm->card->snd_card)) {
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		return dapm->suspend_bias_off;
-	default:
-		break;
-	}
-
-	return false;
-}
-
 /*
  * Scan each dapm widget for complete audio path.
  * A complete path is a route that has valid endpoints i.e.:-
@@ -1663,7 +1706,7 @@
 	trace_snd_soc_dapm_start(card);
 
 	list_for_each_entry(d, &card->dapm_list, list) {
-		if (dapm_idle_bias_off(d))
+		if (d->idle_bias_off)
 			d->target_bias_level = SND_SOC_BIAS_OFF;
 		else
 			d->target_bias_level = SND_SOC_BIAS_STANDBY;
@@ -1729,7 +1772,7 @@
 		if (d->target_bias_level > bias)
 			bias = d->target_bias_level;
 	list_for_each_entry(d, &card->dapm_list, list)
-		if (!dapm_idle_bias_off(d))
+		if (!d->idle_bias_off)
 			d->target_bias_level = bias;
 
 	trace_snd_soc_dapm_walk_done(card);
@@ -1800,14 +1843,10 @@
 	if (!buf)
 		return -ENOMEM;
 
-	/* Supply widgets are not handled by is_connected_{input,output}_ep() */
-	if (w->is_supply) {
-		in = 0;
-		out = 0;
-	} else {
-		in = is_connected_input_ep(w, NULL);
-		out = is_connected_output_ep(w, NULL);
-	}
+	in = is_connected_input_ep(w, NULL);
+	dapm_clear_walk_input(w->dapm, &w->sources);
+	out = is_connected_output_ep(w, NULL);
+	dapm_clear_walk_output(w->dapm, &w->sinks);
 
 	ret = snprintf(buf, PAGE_SIZE, "%s: %s%s  in %d out %d",
 		       w->name, w->power ? "On" : "Off",
@@ -1952,45 +1991,32 @@
 
 #endif
 
-/*
- * soc_dapm_connect_path() - Connects or disconnects a path
- * @path: The path to update
- * @connect: The new connect state of the path. True if the path is connected,
- *  false if it is disconneted.
- * @reason: The reason why the path changed (for debugging only)
- */
-static void soc_dapm_connect_path(struct snd_soc_dapm_path *path,
-	bool connect, const char *reason)
-{
-	if (path->connect == connect)
-		return;
-
-	path->connect = connect;
-	dapm_mark_dirty(path->source, reason);
-	dapm_mark_dirty(path->sink, reason);
-	dapm_path_invalidate(path);
-}
-
 /* test and update the power status of a mux widget */
 static int soc_dapm_mux_update_power(struct snd_soc_card *card,
 				 struct snd_kcontrol *kcontrol, int mux, struct soc_enum *e)
 {
 	struct snd_soc_dapm_path *path;
 	int found = 0;
-	bool connect;
 
 	lockdep_assert_held(&card->dapm_mutex);
 
 	/* find dapm widget path assoc with kcontrol */
 	dapm_kcontrol_for_each_path(path, kcontrol) {
+		if (!path->name || !e->texts[mux])
+			continue;
+
 		found = 1;
 		/* we now need to match the string in the enum to the path */
-		if (!(strcmp(path->name, e->texts[mux])))
-			connect = true;
-		else
-			connect = false;
-
-		soc_dapm_connect_path(path, connect, "mux update");
+		if (!(strcmp(path->name, e->texts[mux]))) {
+			path->connect = 1; /* new connection */
+			dapm_mark_dirty(path->source, "mux connection");
+		} else {
+			if (path->connect)
+				dapm_mark_dirty(path->source,
+						"mux disconnection");
+			path->connect = 0; /* old connection must be powered down */
+		}
+		dapm_mark_dirty(path->sink, "mux change");
 	}
 
 	if (found)
@@ -2029,7 +2055,9 @@
 	/* find dapm widget path assoc with kcontrol */
 	dapm_kcontrol_for_each_path(path, kcontrol) {
 		found = 1;
-		soc_dapm_connect_path(path, connect, "mixer update");
+		path->connect = connect;
+		dapm_mark_dirty(path->source, "mixer connection");
+		dapm_mark_dirty(path->sink, "mixer update");
 	}
 
 	if (found)
@@ -2207,11 +2235,8 @@
 		return -EINVAL;
 	}
 
-	if (w->connected != status) {
+	if (w->connected != status)
 		dapm_mark_dirty(w, "pin configuration");
-		dapm_widget_invalidate_input_paths(w);
-		dapm_widget_invalidate_output_paths(w);
-	}
 
 	w->connected = status;
 	if (status == 0)
@@ -2264,53 +2289,6 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_dapm_sync);
 
-/*
- * dapm_update_widget_flags() - Re-compute widget sink and source flags
- * @w: The widget for which to update the flags
- *
- * Some widgets have a dynamic category which depends on which neighbors they
- * are connected to. This function update the category for these widgets.
- *
- * This function must be called whenever a path is added or removed to a widget.
- */
-static void dapm_update_widget_flags(struct snd_soc_dapm_widget *w)
-{
-	struct snd_soc_dapm_path *p;
-
-	switch (w->id) {
-	case snd_soc_dapm_input:
-		w->is_source = 1;
-		list_for_each_entry(p, &w->sources, list_sink) {
-			if (p->source->id == snd_soc_dapm_micbias ||
-				p->source->id == snd_soc_dapm_mic ||
-				p->source->id == snd_soc_dapm_line ||
-				p->source->id == snd_soc_dapm_output) {
-					w->is_source = 0;
-					break;
-			}
-		}
-		break;
-	case snd_soc_dapm_output:
-		w->is_sink = 1;
-		list_for_each_entry(p, &w->sinks, list_source) {
-			if (p->sink->id == snd_soc_dapm_spk ||
-				p->sink->id == snd_soc_dapm_hp ||
-				p->sink->id == snd_soc_dapm_line ||
-				p->sink->id == snd_soc_dapm_input) {
-					w->is_sink = 0;
-					break;
-			}
-		}
-		break;
-	case snd_soc_dapm_line:
-		w->is_sink = !list_empty(&w->sources);
-		w->is_source = !list_empty(&w->sinks);
-		break;
-	default:
-		break;
-	}
-}
-
 static int snd_soc_dapm_add_path(struct snd_soc_dapm_context *dapm,
 	struct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,
 	const char *control,
@@ -2320,27 +2298,6 @@
 	struct snd_soc_dapm_path *path;
 	int ret;
 
-	if (wsink->is_supply && !wsource->is_supply) {
-		dev_err(dapm->dev,
-			"Connecting non-supply widget to supply widget is not supported (%s -> %s)\n",
-			wsource->name, wsink->name);
-		return -EINVAL;
-	}
-
-	if (connected && !wsource->is_supply) {
-		dev_err(dapm->dev,
-			"connected() callback only supported for supply widgets (%s -> %s)\n",
-			wsource->name, wsink->name);
-		return -EINVAL;
-	}
-
-	if (wsource->is_supply && control) {
-		dev_err(dapm->dev,
-			"Conditional paths are not supported for supply widgets (%s -> [%s] -> %s)\n",
-			wsource->name, control, wsink->name);
-		return -EINVAL;
-	}
-
 	path = kzalloc(sizeof(struct snd_soc_dapm_path), GFP_KERNEL);
 	if (!path)
 		return -ENOMEM;
@@ -2353,48 +2310,84 @@
 	INIT_LIST_HEAD(&path->list_source);
 	INIT_LIST_HEAD(&path->list_sink);
 
-	if (wsource->is_supply || wsink->is_supply)
-		path->is_supply = 1;
+	/* check for external widgets */
+	if (wsink->id == snd_soc_dapm_input) {
+		if (wsource->id == snd_soc_dapm_micbias ||
+			wsource->id == snd_soc_dapm_mic ||
+			wsource->id == snd_soc_dapm_line ||
+			wsource->id == snd_soc_dapm_output)
+			wsink->ext = 1;
+	}
+	if (wsource->id == snd_soc_dapm_output) {
+		if (wsink->id == snd_soc_dapm_spk ||
+			wsink->id == snd_soc_dapm_hp ||
+			wsink->id == snd_soc_dapm_line ||
+			wsink->id == snd_soc_dapm_input)
+			wsource->ext = 1;
+	}
+
+	dapm_mark_dirty(wsource, "Route added");
+	dapm_mark_dirty(wsink, "Route added");
 
 	/* connect static paths */
 	if (control == NULL) {
+		list_add(&path->list, &dapm->card->paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
 		path->connect = 1;
-	} else {
-		/* connect dynamic paths */
-		switch (wsink->id) {
-		case snd_soc_dapm_mux:
-			ret = dapm_connect_mux(dapm, path, control);
-			if (ret != 0)
-				goto err;
-			break;
-		case snd_soc_dapm_switch:
-		case snd_soc_dapm_mixer:
-		case snd_soc_dapm_mixer_named_ctl:
-			ret = dapm_connect_mixer(dapm, path, control);
-			if (ret != 0)
-				goto err;
-			break;
-		default:
-			dev_err(dapm->dev,
-				"Control not supported for path %s -> [%s] -> %s\n",
-				wsource->name, control, wsink->name);
-			ret = -EINVAL;
-			goto err;
-		}
+		return 0;
 	}
 
-	list_add(&path->list, &dapm->card->paths);
-	list_add(&path->list_sink, &wsink->sources);
-	list_add(&path->list_source, &wsource->sinks);
-
-	dapm_update_widget_flags(wsource);
-	dapm_update_widget_flags(wsink);
-
-	dapm_mark_dirty(wsource, "Route added");
-	dapm_mark_dirty(wsink, "Route added");
-
-	if (dapm->card->instantiated && path->connect)
-		dapm_path_invalidate(path);
+	/* connect dynamic paths */
+	switch (wsink->id) {
+	case snd_soc_dapm_adc:
+	case snd_soc_dapm_dac:
+	case snd_soc_dapm_pga:
+	case snd_soc_dapm_out_drv:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_siggen:
+	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_vmid:
+	case snd_soc_dapm_pre:
+	case snd_soc_dapm_post:
+	case snd_soc_dapm_supply:
+	case snd_soc_dapm_regulator_supply:
+	case snd_soc_dapm_clock_supply:
+	case snd_soc_dapm_aif_in:
+	case snd_soc_dapm_aif_out:
+	case snd_soc_dapm_dai_in:
+	case snd_soc_dapm_dai_out:
+	case snd_soc_dapm_dai_link:
+	case snd_soc_dapm_kcontrol:
+		list_add(&path->list, &dapm->card->paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 1;
+		return 0;
+	case snd_soc_dapm_mux:
+		ret = dapm_connect_mux(dapm, wsource, wsink, path, control,
+			&wsink->kcontrol_news[0]);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer:
+	case snd_soc_dapm_mixer_named_ctl:
+		ret = dapm_connect_mixer(dapm, wsource, wsink, path, control);
+		if (ret != 0)
+			goto err;
+		break;
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_line:
+	case snd_soc_dapm_spk:
+		list_add(&path->list, &dapm->card->paths);
+		list_add(&path->list_sink, &wsink->sources);
+		list_add(&path->list_source, &wsource->sinks);
+		path->connect = 0;
+		return 0;
+	}
 
 	return 0;
 err:
@@ -2476,7 +2469,6 @@
 static int snd_soc_dapm_del_route(struct snd_soc_dapm_context *dapm,
 				  const struct snd_soc_dapm_route *route)
 {
-	struct snd_soc_dapm_widget *wsource, *wsink;
 	struct snd_soc_dapm_path *path, *p;
 	const char *sink;
 	const char *source;
@@ -2514,19 +2506,10 @@
 	}
 
 	if (path) {
-		wsource = path->source;
-		wsink = path->sink;
-
-		dapm_mark_dirty(wsource, "Route removed");
-		dapm_mark_dirty(wsink, "Route removed");
-		if (path->connect)
-			dapm_path_invalidate(path);
+		dapm_mark_dirty(path->source, "Route removed");
+		dapm_mark_dirty(path->sink, "Route removed");
 
 		dapm_free_path(path);
-
-		/* Update any path related flags */
-		dapm_update_widget_flags(wsource);
-		dapm_update_widget_flags(wsink);
 	} else {
 		dev_warn(dapm->dev, "ASoC: Route %s->%s does not exist\n",
 			 source, sink);
@@ -2877,14 +2860,12 @@
 	struct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned int reg_val, val;
+	int ret = 0;
 
-	if (e->reg != SND_SOC_NOPM) {
-		int ret = soc_dapm_read(dapm, e->reg, &reg_val);
-		if (ret)
-			return ret;
-	} else {
+	if (e->reg != SND_SOC_NOPM)
+		ret = soc_dapm_read(dapm, e->reg, &reg_val);
+	else
 		reg_val = dapm_kcontrol_get_value(kcontrol);
-	}
 
 	val = (reg_val >> e->shift_l) & e->mask;
 	ucontrol->value.enumerated.item[0] = snd_soc_enum_val_to_item(e, val);
@@ -2894,7 +2875,7 @@
 		ucontrol->value.enumerated.item[1] = val;
 	}
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dapm_get_enum_double);
 
@@ -3084,44 +3065,40 @@
 	}
 
 	switch (w->id) {
-	case snd_soc_dapm_mic:
-	case snd_soc_dapm_input:
-		w->is_source = 1;
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mixer:
+	case snd_soc_dapm_mixer_named_ctl:
 		w->power_check = dapm_generic_check_power;
 		break;
-	case snd_soc_dapm_spk:
-	case snd_soc_dapm_hp:
-	case snd_soc_dapm_output:
-		w->is_sink = 1;
+	case snd_soc_dapm_mux:
 		w->power_check = dapm_generic_check_power;
 		break;
-	case snd_soc_dapm_vmid:
-	case snd_soc_dapm_siggen:
-		w->is_source = 1;
-		w->power_check = dapm_always_on_check_power;
+	case snd_soc_dapm_dai_out:
+		w->power_check = dapm_adc_check_power;
+		break;
+	case snd_soc_dapm_dai_in:
+		w->power_check = dapm_dac_check_power;
 		break;
-	case snd_soc_dapm_mux:
-	case snd_soc_dapm_switch:
-	case snd_soc_dapm_mixer:
-	case snd_soc_dapm_mixer_named_ctl:
 	case snd_soc_dapm_adc:
 	case snd_soc_dapm_aif_out:
 	case snd_soc_dapm_dac:
 	case snd_soc_dapm_aif_in:
 	case snd_soc_dapm_pga:
 	case snd_soc_dapm_out_drv:
+	case snd_soc_dapm_input:
+	case snd_soc_dapm_output:
 	case snd_soc_dapm_micbias:
+	case snd_soc_dapm_spk:
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
 	case snd_soc_dapm_line:
 	case snd_soc_dapm_dai_link:
-	case snd_soc_dapm_dai_out:
-	case snd_soc_dapm_dai_in:
 		w->power_check = dapm_generic_check_power;
 		break;
 	case snd_soc_dapm_supply:
 	case snd_soc_dapm_regulator_supply:
 	case snd_soc_dapm_clock_supply:
 	case snd_soc_dapm_kcontrol:
-		w->is_supply = 1;
 		w->power_check = dapm_supply_check_power;
 		break;
 	default:
@@ -3130,17 +3107,13 @@
 	}
 
 	w->dapm = dapm;
-	if (dapm->component)
-		w->codec = dapm->component->codec;
+	w->codec = dapm->codec;
 	INIT_LIST_HEAD(&w->sources);
 	INIT_LIST_HEAD(&w->sinks);
 	INIT_LIST_HEAD(&w->list);
 	INIT_LIST_HEAD(&w->dirty);
 	list_add(&w->list, &dapm->card->widgets);
 
-	w->inputs = -1;
-	w->outputs = -1;
-
 	/* machine layer set ups unconnected pins and insertions */
 	w->connected = 1;
 	return w;
@@ -3488,14 +3461,6 @@
 		case SND_SOC_DAPM_STREAM_PAUSE_RELEASE:
 			break;
 		}
-
-		if (w->id == snd_soc_dapm_dai_in) {
-			w->is_source = w->active;
-			dapm_widget_invalidate_input_paths(w);
-		} else {
-			w->is_sink = w->active;
-			dapm_widget_invalidate_output_paths(w);
-		}
 	}
 }
 
@@ -3622,15 +3587,7 @@
 	}
 
 	dev_dbg(w->dapm->dev, "ASoC: force enable pin %s\n", pin);
-	if (!w->connected) {
-		/*
-		 * w->force does not affect the number of input or output paths,
-		 * so we only have to recheck if w->connected is changed
-		 */
-		dapm_widget_invalidate_input_paths(w);
-		dapm_widget_invalidate_output_paths(w);
-		w->connected = 1;
-	}
+	w->connected = 1;
 	w->force = 1;
 	dapm_mark_dirty(w, "force enable");
 
@@ -3808,54 +3765,35 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_dapm_ignore_suspend);
 
-/**
- * dapm_is_external_path() - Checks if a path is a external path
- * @card: The card the path belongs to
- * @path: The path to check
- *
- * Returns true if the path is either between two different DAPM contexts or
- * between two external pins of the same DAPM context. Otherwise returns
- * false.
- */
-static bool dapm_is_external_path(struct snd_soc_card *card,
-	struct snd_soc_dapm_path *path)
-{
-	dev_dbg(card->dev,
-		"... Path %s(id:%d dapm:%p) - %s(id:%d dapm:%p)\n",
-		path->source->name, path->source->id, path->source->dapm,
-		path->sink->name, path->sink->id, path->sink->dapm);
-
-	/* Connection between two different DAPM contexts */
-	if (path->source->dapm != path->sink->dapm)
-		return true;
-
-	/* Loopback connection from external pin to external pin */
-	if (path->sink->id == snd_soc_dapm_input) {
-		switch (path->source->id) {
-		case snd_soc_dapm_output:
-		case snd_soc_dapm_micbias:
-			return true;
-		default:
-			break;
-		}
-	}
-
-	return false;
-}
-
 static bool snd_soc_dapm_widget_in_card_paths(struct snd_soc_card *card,
 					      struct snd_soc_dapm_widget *w)
 {
 	struct snd_soc_dapm_path *p;
 
-	list_for_each_entry(p, &w->sources, list_sink) {
-		if (dapm_is_external_path(card, p))
-			return true;
-	}
-
-	list_for_each_entry(p, &w->sinks, list_source) {
-		if (dapm_is_external_path(card, p))
-			return true;
+	list_for_each_entry(p, &card->paths, list) {
+		if ((p->source == w) || (p->sink == w)) {
+			dev_dbg(card->dev,
+			    "... Path %s(id:%d dapm:%p) - %s(id:%d dapm:%p)\n",
+			    p->source->name, p->source->id, p->source->dapm,
+			    p->sink->name, p->sink->id, p->sink->dapm);
+
+			/* Connected to something other than the codec */
+			if (p->source->dapm != p->sink->dapm)
+				return true;
+			/*
+			 * Loopback connection from codec external pin to
+			 * codec external pin
+			 */
+			if (p->sink->id == snd_soc_dapm_input) {
+				switch (p->source->id) {
+				case snd_soc_dapm_output:
+				case snd_soc_dapm_micbias:
+					return true;
+				default:
+					break;
+				}
+			}
+		}
 	}
 
 	return false;
diff -Naur linux-3.19.old/sound/soc/soc-generic-dmaengine-pcm.c linux-3.19/sound/soc/soc-generic-dmaengine-pcm.c
--- linux-3.19.old/sound/soc/soc-generic-dmaengine-pcm.c	2015-03-24 17:38:14.659843602 -0800
+++ linux-3.19/sound/soc/soc-generic-dmaengine-pcm.c	2015-03-24 18:36:44.528028363 -0800
@@ -336,12 +336,10 @@
 };
 
 static const struct snd_soc_platform_driver dmaengine_pcm_platform = {
-	.component_driver = {
-		.probe_order = SND_SOC_COMP_ORDER_LATE,
-	},
 	.ops		= &dmaengine_pcm_ops,
 	.pcm_new	= dmaengine_pcm_new,
 	.pcm_free	= dmaengine_pcm_free,
+	.probe_order	= SND_SOC_COMP_ORDER_LATE,
 };
 
 static const char * const dmaengine_pcm_dma_channel_names[] = {
diff -Naur linux-3.19.old/sound/soc/soc-io.c linux-3.19/sound/soc/soc-io.c
--- linux-3.19.old/sound/soc/soc-io.c	2015-03-24 17:38:14.659843602 -0800
+++ linux-3.19/sound/soc/soc-io.c	2015-03-24 18:36:44.528028363 -0800
@@ -271,3 +271,31 @@
 	return snd_soc_component_write(&platform->component, reg, val);
 }
 EXPORT_SYMBOL_GPL(snd_soc_platform_write);
+
+/**
+ * snd_soc_component_init_io() - Initialize regmap IO
+ *
+ * @component: component to initialize
+ * @regmap: regmap instance to use for IO operations
+ *
+ * Return: 0 on success, a negative error code otherwise
+ */
+int snd_soc_component_init_io(struct snd_soc_component *component,
+	struct regmap *regmap)
+{
+	int ret;
+
+	if (!regmap)
+		return -EINVAL;
+
+	ret = regmap_get_val_bytes(regmap);
+	/* Errors are legitimate for non-integer byte
+	 * multiples */
+	if (ret > 0)
+		component->val_bytes = ret;
+
+	component->regmap = regmap;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_component_init_io);
diff -Naur linux-3.19.old/sound/soc/soc-jack.c linux-3.19/sound/soc/soc-jack.c
--- linux-3.19.old/sound/soc/soc-jack.c	2015-03-24 17:38:14.659843602 -0800
+++ linux-3.19/sound/soc/soc-jack.c	2015-03-24 18:36:44.528028363 -0800
@@ -116,7 +116,7 @@
  *
  * @jack:  ASoC jack
  * @count: Number of zones
- * @zones:  Array of zones
+ * @zone:  Array of zones
  *
  * After this function has been called the zones specified in the
  * array will be associated with the jack.
@@ -235,7 +235,7 @@
 
 #ifdef CONFIG_GPIOLIB
 /* gpio detect */
-static void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio)
+void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio)
 {
 	struct snd_soc_jack *jack = gpio->jack;
 	int enable;
@@ -255,6 +255,7 @@
 
 	snd_soc_jack_report(jack, report, gpio->report);
 }
+EXPORT_SYMBOL(snd_soc_jack_gpio_detect);
 
 /* irq handler for gpio pin */
 static irqreturn_t gpio_handler(int irq, void *data)
@@ -309,7 +310,7 @@
 			/* GPIO descriptor */
 			gpios[i].desc = gpiod_get_index(gpios[i].gpiod_dev,
 							gpios[i].name,
-							gpios[i].idx, GPIOD_IN);
+							gpios[i].idx);
 			if (IS_ERR(gpios[i].desc)) {
 				ret = PTR_ERR(gpios[i].desc);
 				dev_err(gpios[i].gpiod_dev,
@@ -327,14 +328,17 @@
 				goto undo;
 			}
 
-			ret = gpio_request_one(gpios[i].gpio, GPIOF_IN,
-					       gpios[i].name);
+			ret = gpio_request(gpios[i].gpio, gpios[i].name);
 			if (ret)
 				goto undo;
 
 			gpios[i].desc = gpio_to_desc(gpios[i].gpio);
 		}
 
+		ret = gpiod_direction_input(gpios[i].desc);
+		if (ret)
+			goto err;
+
 		INIT_DELAYED_WORK(&gpios[i].work, gpio_work);
 		gpios[i].jack = jack;
 
diff -Naur linux-3.19.old/sound/soc/soc-ops.c linux-3.19/sound/soc/soc-ops.c
--- linux-3.19.old/sound/soc/soc-ops.c	2015-03-24 17:38:14.663176936 -0800
+++ linux-3.19/sound/soc/soc-ops.c	1969-12-31 14:00:00.000000000 -1000
@@ -1,952 +0,0 @@
-/*
- * soc-ops.c  --  Generic ASoC operations
- *
- * Copyright 2005 Wolfson Microelectronics PLC.
- * Copyright 2005 Openedhand Ltd.
- * Copyright (C) 2010 Slimlogic Ltd.
- * Copyright (C) 2010 Texas Instruments Inc.
- *
- * Author: Liam Girdwood <lrg@slimlogic.co.uk>
- *         with code, comments and ideas from :-
- *         Richard Purdie <richard@openedhand.com>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/bitops.h>
-#include <linux/ctype.h>
-#include <linux/slab.h>
-#include <sound/core.h>
-#include <sound/jack.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dpcm.h>
-#include <sound/initval.h>
-
-/**
- * snd_soc_info_enum_double - enumerated double mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a double enumerated
- * mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-
-	return snd_ctl_enum_info(uinfo, e->shift_l == e->shift_r ? 1 : 2,
-				 e->items, e->texts);
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_enum_double);
-
-/**
- * snd_soc_get_enum_double - enumerated double mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a double enumerated mixer.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int val, item;
-	unsigned int reg_val;
-	int ret;
-
-	ret = snd_soc_component_read(component, e->reg, &reg_val);
-	if (ret)
-		return ret;
-	val = (reg_val >> e->shift_l) & e->mask;
-	item = snd_soc_enum_val_to_item(e, val);
-	ucontrol->value.enumerated.item[0] = item;
-	if (e->shift_l != e->shift_r) {
-		val = (reg_val >> e->shift_l) & e->mask;
-		item = snd_soc_enum_val_to_item(e, val);
-		ucontrol->value.enumerated.item[1] = item;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_enum_double);
-
-/**
- * snd_soc_put_enum_double - enumerated double mixer put callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value of a double enumerated mixer.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
-	unsigned int *item = ucontrol->value.enumerated.item;
-	unsigned int val;
-	unsigned int mask;
-
-	if (item[0] >= e->items)
-		return -EINVAL;
-	val = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;
-	mask = e->mask << e->shift_l;
-	if (e->shift_l != e->shift_r) {
-		if (item[1] >= e->items)
-			return -EINVAL;
-		val |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_r;
-		mask |= e->mask << e->shift_r;
-	}
-
-	return snd_soc_component_update_bits(component, e->reg, mask, val);
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_enum_double);
-
-/**
- * snd_soc_read_signed - Read a codec register and interprete as signed value
- * @component: component
- * @reg: Register to read
- * @mask: Mask to use after shifting the register value
- * @shift: Right shift of register value
- * @sign_bit: Bit that describes if a number is negative or not.
- * @signed_val: Pointer to where the read value should be stored
- *
- * This functions reads a codec register. The register value is shifted right
- * by 'shift' bits and masked with the given 'mask'. Afterwards it translates
- * the given registervalue into a signed integer if sign_bit is non-zero.
- *
- * Returns 0 on sucess, otherwise an error value
- */
-static int snd_soc_read_signed(struct snd_soc_component *component,
-	unsigned int reg, unsigned int mask, unsigned int shift,
-	unsigned int sign_bit, int *signed_val)
-{
-	int ret;
-	unsigned int val;
-
-	ret = snd_soc_component_read(component, reg, &val);
-	if (ret < 0)
-		return ret;
-
-	val = (val >> shift) & mask;
-
-	if (!sign_bit) {
-		*signed_val = val;
-		return 0;
-	}
-
-	/* non-negative number */
-	if (!(val & BIT(sign_bit))) {
-		*signed_val = val;
-		return 0;
-	}
-
-	ret = val;
-
-	/*
-	 * The register most probably does not contain a full-sized int.
-	 * Instead we have an arbitrary number of bits in a signed
-	 * representation which has to be translated into a full-sized int.
-	 * This is done by filling up all bits above the sign-bit.
-	 */
-	ret |= ~((int)(BIT(sign_bit) - 1));
-
-	*signed_val = ret;
-
-	return 0;
-}
-
-/**
- * snd_soc_info_volsw - single mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a single mixer control, or a double
- * mixer control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int platform_max;
-
-	if (!mc->platform_max)
-		mc->platform_max = mc->max;
-	platform_max = mc->platform_max;
-
-	if (platform_max == 1 && !strstr(kcontrol->id.name, " Volume"))
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	else
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-
-	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = platform_max - mc->min;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
-
-/**
- * snd_soc_get_volsw - single mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a single mixer control, or a double mixer
- * control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	int min = mc->min;
-	int sign_bit = mc->sign_bit;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	int val;
-	int ret;
-
-	if (sign_bit)
-		mask = BIT(sign_bit + 1) - 1;
-
-	ret = snd_soc_read_signed(component, reg, mask, shift, sign_bit, &val);
-	if (ret)
-		return ret;
-
-	ucontrol->value.integer.value[0] = val - min;
-	if (invert)
-		ucontrol->value.integer.value[0] =
-			max - ucontrol->value.integer.value[0];
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		if (reg == reg2)
-			ret = snd_soc_read_signed(component, reg, mask, rshift,
-				sign_bit, &val);
-		else
-			ret = snd_soc_read_signed(component, reg2, mask, shift,
-				sign_bit, &val);
-		if (ret)
-			return ret;
-
-		ucontrol->value.integer.value[1] = val - min;
-		if (invert)
-			ucontrol->value.integer.value[1] =
-				max - ucontrol->value.integer.value[1];
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
-
-/**
- * snd_soc_put_volsw - single mixer put callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value of a single mixer control, or a double mixer
- * control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	int min = mc->min;
-	unsigned int sign_bit = mc->sign_bit;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	int err;
-	bool type_2r = false;
-	unsigned int val2 = 0;
-	unsigned int val, val_mask;
-
-	if (sign_bit)
-		mask = BIT(sign_bit + 1) - 1;
-
-	val = ((ucontrol->value.integer.value[0] + min) & mask);
-	if (invert)
-		val = max - val;
-	val_mask = mask << shift;
-	val = val << shift;
-	if (snd_soc_volsw_is_stereo(mc)) {
-		val2 = ((ucontrol->value.integer.value[1] + min) & mask);
-		if (invert)
-			val2 = max - val2;
-		if (reg == reg2) {
-			val_mask |= mask << rshift;
-			val |= val2 << rshift;
-		} else {
-			val2 = val2 << shift;
-			type_2r = true;
-		}
-	}
-	err = snd_soc_component_update_bits(component, reg, val_mask, val);
-	if (err < 0)
-		return err;
-
-	if (type_2r)
-		err = snd_soc_component_update_bits(component, reg2, val_mask,
-			val2);
-
-	return err;
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
-
-/**
- * snd_soc_get_volsw_sx - single mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a single mixer control, or a double mixer
- * control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_volsw_sx(struct snd_kcontrol *kcontrol,
-		      struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-	    (struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	int min = mc->min;
-	int mask = (1 << (fls(min + max) - 1)) - 1;
-	unsigned int val;
-	int ret;
-
-	ret = snd_soc_component_read(component, reg, &val);
-	if (ret < 0)
-		return ret;
-
-	ucontrol->value.integer.value[0] = ((val >> shift) - min) & mask;
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		ret = snd_soc_component_read(component, reg2, &val);
-		if (ret < 0)
-			return ret;
-
-		val = ((val >> rshift) - min) & mask;
-		ucontrol->value.integer.value[1] = val;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_volsw_sx);
-
-/**
- * snd_soc_put_volsw_sx - double mixer set callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to set the value of a double mixer control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_volsw_sx(struct snd_kcontrol *kcontrol,
-			 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-	    (struct soc_mixer_control *)kcontrol->private_value;
-
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	int min = mc->min;
-	int mask = (1 << (fls(min + max) - 1)) - 1;
-	int err = 0;
-	unsigned int val, val_mask, val2 = 0;
-
-	val_mask = mask << shift;
-	val = (ucontrol->value.integer.value[0] + min) & mask;
-	val = val << shift;
-
-	err = snd_soc_component_update_bits(component, reg, val_mask, val);
-	if (err < 0)
-		return err;
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		val_mask = mask << rshift;
-		val2 = (ucontrol->value.integer.value[1] + min) & mask;
-		val2 = val2 << rshift;
-
-		err = snd_soc_component_update_bits(component, reg2, val_mask,
-			val2);
-	}
-	return err;
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw_sx);
-
-/**
- * snd_soc_info_volsw_range - single mixer info callback with range.
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information, within a range, about a single
- * mixer control.
- *
- * returns 0 for success.
- */
-int snd_soc_info_volsw_range(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int platform_max;
-	int min = mc->min;
-
-	if (!mc->platform_max)
-		mc->platform_max = mc->max;
-	platform_max = mc->platform_max;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = platform_max - min;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_volsw_range);
-
-/**
- * snd_soc_put_volsw_range - single mixer put value callback with range.
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value, within a range, for a single mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_volsw_range(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	unsigned int rreg = mc->rreg;
-	unsigned int shift = mc->shift;
-	int min = mc->min;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	unsigned int val, val_mask;
-	int ret;
-
-	if (invert)
-		val = (max - ucontrol->value.integer.value[0]) & mask;
-	else
-		val = ((ucontrol->value.integer.value[0] + min) & mask);
-	val_mask = mask << shift;
-	val = val << shift;
-
-	ret = snd_soc_component_update_bits(component, reg, val_mask, val);
-	if (ret < 0)
-		return ret;
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		if (invert)
-			val = (max - ucontrol->value.integer.value[1]) & mask;
-		else
-			val = ((ucontrol->value.integer.value[1] + min) & mask);
-		val_mask = mask << shift;
-		val = val << shift;
-
-		ret = snd_soc_component_update_bits(component, rreg, val_mask,
-			val);
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_volsw_range);
-
-/**
- * snd_soc_get_volsw_range - single mixer get callback with range
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value, within a range, of a single mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_volsw_range(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int rreg = mc->rreg;
-	unsigned int shift = mc->shift;
-	int min = mc->min;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	unsigned int val;
-	int ret;
-
-	ret = snd_soc_component_read(component, reg, &val);
-	if (ret)
-		return ret;
-
-	ucontrol->value.integer.value[0] = (val >> shift) & mask;
-	if (invert)
-		ucontrol->value.integer.value[0] =
-			max - ucontrol->value.integer.value[0];
-	else
-		ucontrol->value.integer.value[0] =
-			ucontrol->value.integer.value[0] - min;
-
-	if (snd_soc_volsw_is_stereo(mc)) {
-		ret = snd_soc_component_read(component, rreg, &val);
-		if (ret)
-			return ret;
-
-		ucontrol->value.integer.value[1] = (val >> shift) & mask;
-		if (invert)
-			ucontrol->value.integer.value[1] =
-				max - ucontrol->value.integer.value[1];
-		else
-			ucontrol->value.integer.value[1] =
-				ucontrol->value.integer.value[1] - min;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_volsw_range);
-
-/**
- * snd_soc_limit_volume - Set new limit to an existing volume control.
- *
- * @codec: where to look for the control
- * @name: Name of the control
- * @max: new maximum limit
- *
- * Return 0 for success, else error.
- */
-int snd_soc_limit_volume(struct snd_soc_codec *codec,
-	const char *name, int max)
-{
-	struct snd_card *card = codec->component.card->snd_card;
-	struct snd_kcontrol *kctl;
-	struct soc_mixer_control *mc;
-	int found = 0;
-	int ret = -EINVAL;
-
-	/* Sanity check for name and max */
-	if (unlikely(!name || max <= 0))
-		return -EINVAL;
-
-	list_for_each_entry(kctl, &card->controls, list) {
-		if (!strncmp(kctl->id.name, name, sizeof(kctl->id.name))) {
-			found = 1;
-			break;
-		}
-	}
-	if (found) {
-		mc = (struct soc_mixer_control *)kctl->private_value;
-		if (max <= mc->max) {
-			mc->platform_max = max;
-			ret = 0;
-		}
-	}
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_limit_volume);
-
-int snd_soc_bytes_info(struct snd_kcontrol *kcontrol,
-		       struct snd_ctl_elem_info *uinfo)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_bytes *params = (void *)kcontrol->private_value;
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	uinfo->count = params->num_regs * component->val_bytes;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_info);
-
-int snd_soc_bytes_get(struct snd_kcontrol *kcontrol,
-		      struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_bytes *params = (void *)kcontrol->private_value;
-	int ret;
-
-	if (component->regmap)
-		ret = regmap_raw_read(component->regmap, params->base,
-				      ucontrol->value.bytes.data,
-				      params->num_regs * component->val_bytes);
-	else
-		ret = -EINVAL;
-
-	/* Hide any masked bytes to ensure consistent data reporting */
-	if (ret == 0 && params->mask) {
-		switch (component->val_bytes) {
-		case 1:
-			ucontrol->value.bytes.data[0] &= ~params->mask;
-			break;
-		case 2:
-			((u16 *)(&ucontrol->value.bytes.data))[0]
-				&= cpu_to_be16(~params->mask);
-			break;
-		case 4:
-			((u32 *)(&ucontrol->value.bytes.data))[0]
-				&= cpu_to_be32(~params->mask);
-			break;
-		default:
-			return -EINVAL;
-		}
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_get);
-
-int snd_soc_bytes_put(struct snd_kcontrol *kcontrol,
-		      struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_bytes *params = (void *)kcontrol->private_value;
-	int ret, len;
-	unsigned int val, mask;
-	void *data;
-
-	if (!component->regmap || !params->num_regs)
-		return -EINVAL;
-
-	len = params->num_regs * component->val_bytes;
-
-	data = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);
-	if (!data)
-		return -ENOMEM;
-
-	/*
-	 * If we've got a mask then we need to preserve the register
-	 * bits.  We shouldn't modify the incoming data so take a
-	 * copy.
-	 */
-	if (params->mask) {
-		ret = regmap_read(component->regmap, params->base, &val);
-		if (ret != 0)
-			goto out;
-
-		val &= params->mask;
-
-		switch (component->val_bytes) {
-		case 1:
-			((u8 *)data)[0] &= ~params->mask;
-			((u8 *)data)[0] |= val;
-			break;
-		case 2:
-			mask = ~params->mask;
-			ret = regmap_parse_val(component->regmap,
-							&mask, &mask);
-			if (ret != 0)
-				goto out;
-
-			((u16 *)data)[0] &= mask;
-
-			ret = regmap_parse_val(component->regmap,
-							&val, &val);
-			if (ret != 0)
-				goto out;
-
-			((u16 *)data)[0] |= val;
-			break;
-		case 4:
-			mask = ~params->mask;
-			ret = regmap_parse_val(component->regmap,
-							&mask, &mask);
-			if (ret != 0)
-				goto out;
-
-			((u32 *)data)[0] &= mask;
-
-			ret = regmap_parse_val(component->regmap,
-							&val, &val);
-			if (ret != 0)
-				goto out;
-
-			((u32 *)data)[0] |= val;
-			break;
-		default:
-			ret = -EINVAL;
-			goto out;
-		}
-	}
-
-	ret = regmap_raw_write(component->regmap, params->base,
-			       data, len);
-
-out:
-	kfree(data);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_put);
-
-int snd_soc_bytes_info_ext(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_info *ucontrol)
-{
-	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
-
-	ucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	ucontrol->count = params->max;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_info_ext);
-
-int snd_soc_bytes_tlv_callback(struct snd_kcontrol *kcontrol, int op_flag,
-				unsigned int size, unsigned int __user *tlv)
-{
-	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
-	unsigned int count = size < params->max ? size : params->max;
-	int ret = -ENXIO;
-
-	switch (op_flag) {
-	case SNDRV_CTL_TLV_OP_READ:
-		if (params->get)
-			ret = params->get(tlv, count);
-		break;
-	case SNDRV_CTL_TLV_OP_WRITE:
-		if (params->put)
-			ret = params->put(tlv, count);
-		break;
-	}
-	return ret;
-}
-EXPORT_SYMBOL_GPL(snd_soc_bytes_tlv_callback);
-
-/**
- * snd_soc_info_xr_sx - signed multi register info callback
- * @kcontrol: mreg control
- * @uinfo: control element information
- *
- * Callback to provide information of a control that can
- * span multiple codec registers which together
- * forms a single signed value in a MSB/LSB manner.
- *
- * Returns 0 for success.
- */
-int snd_soc_info_xr_sx(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *uinfo)
-{
-	struct soc_mreg_control *mc =
-		(struct soc_mreg_control *)kcontrol->private_value;
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = mc->min;
-	uinfo->value.integer.max = mc->max;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_xr_sx);
-
-/**
- * snd_soc_get_xr_sx - signed multi register get callback
- * @kcontrol: mreg control
- * @ucontrol: control element information
- *
- * Callback to get the value of a control that can span
- * multiple codec registers which together forms a single
- * signed value in a MSB/LSB manner. The control supports
- * specifying total no of bits used to allow for bitfields
- * across the multiple codec registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_xr_sx(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mreg_control *mc =
-		(struct soc_mreg_control *)kcontrol->private_value;
-	unsigned int regbase = mc->regbase;
-	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
-	unsigned int regwmask = (1<<regwshift)-1;
-	unsigned int invert = mc->invert;
-	unsigned long mask = (1UL<<mc->nbits)-1;
-	long min = mc->min;
-	long max = mc->max;
-	long val = 0;
-	unsigned int regval;
-	unsigned int i;
-	int ret;
-
-	for (i = 0; i < regcount; i++) {
-		ret = snd_soc_component_read(component, regbase+i, &regval);
-		if (ret)
-			return ret;
-		val |= (regval & regwmask) << (regwshift*(regcount-i-1));
-	}
-	val &= mask;
-	if (min < 0 && val > max)
-		val |= ~mask;
-	if (invert)
-		val = max - val;
-	ucontrol->value.integer.value[0] = val;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_xr_sx);
-
-/**
- * snd_soc_put_xr_sx - signed multi register get callback
- * @kcontrol: mreg control
- * @ucontrol: control element information
- *
- * Callback to set the value of a control that can span
- * multiple codec registers which together forms a single
- * signed value in a MSB/LSB manner. The control supports
- * specifying total no of bits used to allow for bitfields
- * across the multiple codec registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_put_xr_sx(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mreg_control *mc =
-		(struct soc_mreg_control *)kcontrol->private_value;
-	unsigned int regbase = mc->regbase;
-	unsigned int regcount = mc->regcount;
-	unsigned int regwshift = component->val_bytes * BITS_PER_BYTE;
-	unsigned int regwmask = (1<<regwshift)-1;
-	unsigned int invert = mc->invert;
-	unsigned long mask = (1UL<<mc->nbits)-1;
-	long max = mc->max;
-	long val = ucontrol->value.integer.value[0];
-	unsigned int i, regval, regmask;
-	int err;
-
-	if (invert)
-		val = max - val;
-	val &= mask;
-	for (i = 0; i < regcount; i++) {
-		regval = (val >> (regwshift*(regcount-i-1))) & regwmask;
-		regmask = (mask >> (regwshift*(regcount-i-1))) & regwmask;
-		err = snd_soc_component_update_bits(component, regbase+i,
-				regmask, regval);
-		if (err < 0)
-			return err;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_xr_sx);
-
-/**
- * snd_soc_get_strobe - strobe get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback get the value of a strobe mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_get_strobe(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int mask = 1 << shift;
-	unsigned int invert = mc->invert != 0;
-	unsigned int val;
-	int ret;
-
-	ret = snd_soc_component_read(component, reg, &val);
-	if (ret)
-		return ret;
-
-	val &= mask;
-
-	if (shift != 0 && val != 0)
-		val = val >> shift;
-	ucontrol->value.enumerated.item[0] = val ^ invert;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_get_strobe);
-
-/**
- * snd_soc_put_strobe - strobe put callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback strobe a register bit to high then low (or the inverse)
- * in one pass of a single mixer enum control.
- *
- * Returns 1 for success.
- */
-int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int mask = 1 << shift;
-	unsigned int invert = mc->invert != 0;
-	unsigned int strobe = ucontrol->value.enumerated.item[0] != 0;
-	unsigned int val1 = (strobe ^ invert) ? mask : 0;
-	unsigned int val2 = (strobe ^ invert) ? 0 : mask;
-	int err;
-
-	err = snd_soc_component_update_bits(component, reg, mask, val1);
-	if (err < 0)
-		return err;
-
-	return snd_soc_component_update_bits(component, reg, mask, val2);
-}
-EXPORT_SYMBOL_GPL(snd_soc_put_strobe);
diff -Naur linux-3.19.old/sound/soc/soc-pcm.c linux-3.19/sound/soc/soc-pcm.c
--- linux-3.19.old/sound/soc/soc-pcm.c	2015-03-24 17:38:14.669843603 -0800
+++ linux-3.19/sound/soc/soc-pcm.c	2015-03-24 18:36:44.531361696 -0800
@@ -352,7 +352,7 @@
 	} else {
 		for (i = 0; i < rtd->num_codecs; i++) {
 			codec_dai = rtd->codec_dais[i];
-			if (codec_dai->driver->capture.sig_bits == 0) {
+			if (codec_dai->driver->playback.sig_bits == 0) {
 				bits = 0;
 				break;
 			}
@@ -654,8 +654,6 @@
 			codec_dai->rate = 0;
 	}
 
-	snd_soc_dai_digital_mute(cpu_dai, 1, substream->stream);
-
 	if (cpu_dai->driver->ops->shutdown)
 		cpu_dai->driver->ops->shutdown(substream, cpu_dai);
 
@@ -774,7 +772,6 @@
 	for (i = 0; i < rtd->num_codecs; i++)
 		snd_soc_dai_digital_mute(rtd->codec_dais[i], 0,
 					 substream->stream);
-	snd_soc_dai_digital_mute(cpu_dai, 0, substream->stream);
 
 out:
 	mutex_unlock(&rtd->pcm_mutex);
@@ -1525,36 +1522,13 @@
 		dpcm_init_runtime_hw(runtime, &cpu_dai_drv->capture);
 }
 
-static int dpcm_fe_dai_do_trigger(struct snd_pcm_substream *substream, int cmd);
-
-/* Set FE's runtime_update state; the state is protected via PCM stream lock
- * for avoiding the race with trigger callback.
- * If the state is unset and a trigger is pending while the previous operation,
- * process the pending trigger action here.
- */
-static void dpcm_set_fe_update_state(struct snd_soc_pcm_runtime *fe,
-				     int stream, enum snd_soc_dpcm_update state)
-{
-	struct snd_pcm_substream *substream =
-		snd_soc_dpcm_get_substream(fe, stream);
-
-	snd_pcm_stream_lock_irq(substream);
-	if (state == SND_SOC_DPCM_UPDATE_NO && fe->dpcm[stream].trigger_pending) {
-		dpcm_fe_dai_do_trigger(substream,
-				       fe->dpcm[stream].trigger_pending - 1);
-		fe->dpcm[stream].trigger_pending = 0;
-	}
-	fe->dpcm[stream].runtime_update = state;
-	snd_pcm_stream_unlock_irq(substream);
-}
-
 static int dpcm_fe_dai_startup(struct snd_pcm_substream *fe_substream)
 {
 	struct snd_soc_pcm_runtime *fe = fe_substream->private_data;
 	struct snd_pcm_runtime *runtime = fe_substream->runtime;
 	int stream = fe_substream->stream, ret = 0;
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	ret = dpcm_be_dai_startup(fe, fe_substream->stream);
 	if (ret < 0) {
@@ -1576,13 +1550,13 @@
 	dpcm_set_fe_runtime(fe_substream);
 	snd_pcm_limit_hw_rates(runtime);
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	return 0;
 
 unwind:
 	dpcm_be_dai_startup_unwind(fe, fe_substream->stream);
 be_err:
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	return ret;
 }
 
@@ -1629,7 +1603,7 @@
 	struct snd_soc_pcm_runtime *fe = substream->private_data;
 	int stream = substream->stream;
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	/* shutdown the BEs */
 	dpcm_be_dai_shutdown(fe, substream->stream);
@@ -1643,7 +1617,7 @@
 	dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
 
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	return 0;
 }
 
@@ -1667,10 +1641,6 @@
 		if (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))
 				continue;
 
-		/* do not free hw if this BE is used by other FE */
-		if (be->dpcm[stream].users > 1)
-			continue;
-
 		if ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&
@@ -1695,7 +1665,7 @@
 	int err, stream = substream->stream;
 
 	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	dev_dbg(fe->dev, "ASoC: hw_free FE %s\n", fe->dai_link->name);
 
@@ -1710,7 +1680,7 @@
 	err = dpcm_be_dai_hw_free(fe, stream);
 
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_FREE;
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 
 	mutex_unlock(&fe->card->mutex);
 	return 0;
@@ -1803,7 +1773,7 @@
 	int ret, stream = substream->stream;
 
 	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	memcpy(&fe->dpcm[substream->stream].hw_params, params,
 			sizeof(struct snd_pcm_hw_params));
@@ -1826,7 +1796,7 @@
 		fe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;
 
 out:
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	mutex_unlock(&fe->card->mutex);
 	return ret;
 }
@@ -1940,7 +1910,7 @@
 }
 EXPORT_SYMBOL_GPL(dpcm_be_dai_trigger);
 
-static int dpcm_fe_dai_do_trigger(struct snd_pcm_substream *substream, int cmd)
+static int dpcm_fe_dai_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_soc_pcm_runtime *fe = substream->private_data;
 	int stream = substream->stream, ret;
@@ -2014,23 +1984,6 @@
 	return ret;
 }
 
-static int dpcm_fe_dai_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-	struct snd_soc_pcm_runtime *fe = substream->private_data;
-	int stream = substream->stream;
-
-	/* if FE's runtime_update is already set, we're in race;
-	 * process this trigger later at exit
-	 */
-	if (fe->dpcm[stream].runtime_update != SND_SOC_DPCM_UPDATE_NO) {
-		fe->dpcm[stream].trigger_pending = cmd + 1;
-		return 0; /* delayed, assuming it's successful */
-	}
-
-	/* we're alone, let's trigger */
-	return dpcm_fe_dai_do_trigger(substream, cmd);
-}
-
 int dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream)
 {
 	struct snd_soc_dpcm *dpcm;
@@ -2074,7 +2027,7 @@
 
 	dev_dbg(fe->dev, "ASoC: prepare FE %s\n", fe->dai_link->name);
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	/* there is no point preparing this FE if there are no BEs */
 	if (list_empty(&fe->dpcm[stream].be_clients)) {
@@ -2101,7 +2054,7 @@
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;
 
 out:
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	mutex_unlock(&fe->card->mutex);
 
 	return ret;
@@ -2248,11 +2201,11 @@
 {
 	int ret;
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_BE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;
 	ret = dpcm_run_update_startup(fe, stream);
 	if (ret < 0)
 		dev_err(fe->dev, "ASoC: failed to startup some BEs\n");
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 
 	return ret;
 }
@@ -2261,11 +2214,11 @@
 {
 	int ret;
 
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_BE);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;
 	ret = dpcm_run_update_shutdown(fe, stream);
 	if (ret < 0)
 		dev_err(fe->dev, "ASoC: failed to shutdown some BEs\n");
-	dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);
+	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 
 	return ret;
 }
@@ -2295,13 +2248,7 @@
 			fe->dai_link->name);
 
 		/* skip if FE doesn't have playback capability */
-		if (!fe->cpu_dai->driver->playback.channels_min
-		    || !fe->codec_dai->driver->playback.channels_min)
-			goto capture;
-
-		/* skip if FE isn't currently playing */
-		if (!fe->cpu_dai->playback_active
-		    || !fe->codec_dai->playback_active)
+		if (!fe->cpu_dai->driver->playback.channels_min)
 			goto capture;
 
 		paths = dpcm_path_get(fe, SNDRV_PCM_STREAM_PLAYBACK, &list);
@@ -2331,13 +2278,7 @@
 		dpcm_path_put(&list);
 capture:
 		/* skip if FE doesn't have capture capability */
-		if (!fe->cpu_dai->driver->capture.channels_min
-		    || !fe->codec_dai->driver->capture.channels_min)
-			continue;
-
-		/* skip if FE isn't currently capturing */
-		if (!fe->cpu_dai->capture_active
-		    || !fe->codec_dai->capture_active)
+		if (!fe->cpu_dai->driver->capture.channels_min)
 			continue;
 
 		paths = dpcm_path_get(fe, SNDRV_PCM_STREAM_CAPTURE, &list);
@@ -2411,11 +2352,7 @@
 	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
 	fe->dpcm[stream].runtime = fe_substream->runtime;
 
-	ret = dpcm_path_get(fe, stream, &list);
-	if (ret < 0) {
-		mutex_unlock(&fe->card->mutex);
-		return ret;
-	} else if (ret == 0) {
+	if (dpcm_path_get(fe, stream, &list) <= 0) {
 		dev_dbg(fe->dev, "ASoC: %s no valid %s route\n",
 			fe->dai_link->name, stream ? "capture" : "playback");
 	}
diff -Naur linux-3.19.old/sound/soc/soc-utils.c linux-3.19/sound/soc/soc-utils.c
--- linux-3.19.old/sound/soc/soc-utils.c	2015-03-24 17:38:14.669843603 -0800
+++ linux-3.19/sound/soc/soc-utils.c	2015-03-24 18:36:44.531361696 -0800
@@ -154,6 +154,7 @@
 static struct platform_driver soc_dummy_driver = {
 	.driver = {
 		.name = "snd-soc-dummy",
+		.owner = THIS_MODULE,
 	},
 	.probe = snd_soc_dummy_probe,
 	.remove = snd_soc_dummy_remove,

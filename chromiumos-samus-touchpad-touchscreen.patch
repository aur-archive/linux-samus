diff -Naur linux-3.19.old/drivers/input/input.c linux-3.19/drivers/input/input.c
--- linux-3.19.old/drivers/input/input.c	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/drivers/input/input.c	2015-03-23 21:38:21.290390044 -0800
@@ -367,6 +367,13 @@
 {
 	int disposition;
 
+	/*
+	 * When inhibited, skip all events. For devices that do not implement
+	 * inhibit() themselves.
+	 */
+	if (dev->inhibited)
+		return;
+
 	disposition = input_get_disposition(dev, type, code, &value);
 
 	if ((disposition & INPUT_PASS_TO_DEVICE) && dev->event)
@@ -498,8 +505,7 @@
 	absinfo->fuzz = fuzz;
 	absinfo->flat = flat;
 
-	__set_bit(EV_ABS, dev->evbit);
-	__set_bit(axis, dev->absbit);
+	dev->absbit[BIT_WORD(axis)] |= BIT_MASK(axis);
 }
 EXPORT_SYMBOL(input_set_abs_params);
 
@@ -1381,12 +1387,50 @@
 }
 static DEVICE_ATTR(properties, S_IRUGO, input_dev_show_properties, NULL);
 
+static int input_inhibit(struct input_dev *dev);
+static int input_uninhibit(struct input_dev *dev);
+
+static ssize_t input_dev_show_inhibited(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct input_dev *input_dev = to_input_dev(dev);
+	return scnprintf(buf, PAGE_SIZE, "%d\n", input_dev->inhibited);
+}
+
+static ssize_t input_dev_store_inhibited(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t len)
+{
+	struct input_dev *input_dev = to_input_dev(dev);
+	ssize_t rv;
+	bool inhibited;
+
+	if (strtobool(buf, &inhibited))
+		return -EINVAL;
+
+	if (inhibited)
+		rv = input_inhibit(input_dev);
+	else
+		rv = input_uninhibit(input_dev);
+
+	if (rv != 0)
+		return rv;
+
+	return len;
+}
+
+static DEVICE_ATTR(inhibited, S_IWUSR | S_IRUGO, input_dev_show_inhibited,
+		   input_dev_store_inhibited);
+
 static struct attribute *input_dev_attrs[] = {
 	&dev_attr_name.attr,
 	&dev_attr_phys.attr,
 	&dev_attr_uniq.attr,
 	&dev_attr_modalias.attr,
 	&dev_attr_properties.attr,
+	&dev_attr_inhibited.attr,
 	NULL
 };
 
@@ -1669,6 +1713,57 @@
 }
 EXPORT_SYMBOL(input_reset_device);
 
+static int input_inhibit(struct input_dev *dev)
+{
+	int rv = 0;
+
+	mutex_lock(&dev->mutex);
+
+	if (dev->inhibited)
+		goto out;
+
+	if (dev->inhibit) {
+		rv = dev->inhibit(dev);
+		if (rv != 0)
+			goto out;
+	}
+
+	input_dev_release_keys(dev);
+	input_dev_toggle(dev, false);
+
+	dev->inhibited = true;
+
+out:
+	mutex_unlock(&dev->mutex);
+	return rv;
+}
+
+static int input_uninhibit(struct input_dev *dev)
+{
+	int rv = 0;
+
+	mutex_lock(&dev->mutex);
+
+	if (!dev->inhibited)
+		goto out;
+
+	input_dev_toggle(dev, true);
+
+	if (dev->uninhibit) {
+		rv = dev->uninhibit(dev);
+		if (rv != 0) {
+			input_dev_toggle(dev, false);
+			goto out;
+		}
+	}
+
+	dev->inhibited = false;
+
+out:
+	mutex_unlock(&dev->mutex);
+	return rv;
+}
+
 #ifdef CONFIG_PM_SLEEP
 static int input_dev_suspend(struct device *dev)
 {
@@ -1775,7 +1870,7 @@
  */
 struct input_dev *input_allocate_device(void)
 {
-	static atomic_t input_no = ATOMIC_INIT(-1);
+	static atomic_t input_no = ATOMIC_INIT(0);
 	struct input_dev *dev;
 
 	dev = kzalloc(sizeof(struct input_dev), GFP_KERNEL);
@@ -1789,8 +1884,8 @@
 		INIT_LIST_HEAD(&dev->h_list);
 		INIT_LIST_HEAD(&dev->node);
 
-		dev_set_name(&dev->dev, "input%lu",
-			     (unsigned long)atomic_inc_return(&input_no));
+		dev_set_name(&dev->dev, "input%ld",
+			     (unsigned long) atomic_inc_return(&input_no) - 1);
 
 		__module_get(THIS_MODULE);
 	}
@@ -1974,22 +2069,18 @@
 
 	events = mt_slots + 1; /* count SYN_MT_REPORT and SYN_REPORT */
 
-	if (test_bit(EV_ABS, dev->evbit)) {
-		for (i = 0; i < ABS_CNT; i++) {
-			if (test_bit(i, dev->absbit)) {
-				if (input_is_mt_axis(i))
-					events += mt_slots;
-				else
-					events++;
-			}
+	for (i = 0; i < ABS_CNT; i++) {
+		if (test_bit(i, dev->absbit)) {
+			if (input_is_mt_axis(i))
+				events += mt_slots;
+			else
+				events++;
 		}
 	}
 
-	if (test_bit(EV_REL, dev->evbit)) {
-		for (i = 0; i < REL_CNT; i++)
-			if (test_bit(i, dev->relbit))
-				events++;
-	}
+	for (i = 0; i < REL_CNT; i++)
+		if (test_bit(i, dev->relbit))
+			events++;
 
 	/* Make room for KEY and MSC events */
 	events += 7;
diff -Naur linux-3.19.old/drivers/input/touchscreen/atmel_mxt_ts.c linux-3.19/drivers/input/touchscreen/atmel_mxt_ts.c
--- linux-3.19.old/drivers/input/touchscreen/atmel_mxt_ts.c	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/drivers/input/touchscreen/atmel_mxt_ts.c	2015-03-23 22:34:02.827050727 -0800
@@ -2,9 +2,6 @@
  * Atmel maXTouch Touchscreen driver
  *
  * Copyright (C) 2010 Samsung Electronics Co.Ltd
- * Copyright (C) 2011-2014 Atmel Corporation
- * Copyright (C) 2012 Google, Inc.
- *
  * Author: Joonyoung Shim <jy0922.shim@samsung.com>
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -15,26 +12,33 @@
  */
 
 #include <linux/module.h>
-#include <linux/init.h>
+#include <linux/acpi.h>
 #include <linux/completion.h>
+#include <linux/debugfs.h>
 #include <linux/delay.h>
 #include <linux/firmware.h>
+#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/i2c/atmel_mxt_ts.h>
 #include <linux/input/mt.h>
 #include <linux/interrupt.h>
-#include <linux/of.h>
+#include <linux/regulator/consumer.h>
 #include <linux/slab.h>
+#include <linux/uaccess.h>
 
 /* Version */
 #define MXT_VER_20		20
 #define MXT_VER_21		21
 #define MXT_VER_22		22
 
-/* Firmware files */
+/* Firmware */
 #define MXT_FW_NAME		"maxtouch.fw"
-#define MXT_CFG_NAME		"maxtouch.cfg"
-#define MXT_CFG_MAGIC		"OBP_RAW V1"
+
+/* Config file */
+#define MXT_CONFIG_NAME		"maxtouch.cfg"
+
+/* Configuration Data */
+#define MXT_CONFIG_VERSION	"OBP_RAW V1"
 
 /* Registers */
 #define MXT_INFO		0x00
@@ -48,8 +52,6 @@
 #define MXT_OBJECT_START	0x07
 
 #define MXT_OBJECT_SIZE		6
-#define MXT_INFO_CHECKSUM_SIZE	3
-#define MXT_MAX_BLOCK_WRITE	256
 
 /* Object types */
 #define MXT_DEBUG_DIAGNOSTIC_T37	37
@@ -58,10 +60,6 @@
 #define MXT_GEN_POWER_T7		7
 #define MXT_GEN_ACQUIRE_T8		8
 #define MXT_GEN_DATASOURCE_T53		53
-#define MXT_TOUCH_MULTI_T9		9
-#define MXT_TOUCH_KEYARRAY_T15		15
-#define MXT_TOUCH_PROXIMITY_T23		23
-#define MXT_TOUCH_PROXKEY_T52		52
 #define MXT_PROCI_GRIPFACE_T20		20
 #define MXT_PROCG_NOISE_T22		22
 #define MXT_PROCI_ONETOUCH_T24		24
@@ -71,6 +69,21 @@
 #define MXT_PROCI_TOUCHSUPPRESSION_T42	42
 #define MXT_PROCI_STYLUS_T47		47
 #define MXT_PROCG_NOISESUPPRESSION_T48	48
+#define MXT_PROCI_ADAPTIVETHRESHOLD_T55 55
+#define MXT_PROCI_SHIELDLESS_T56	56
+#define MXT_PROCI_EXTRATOUCHSCREENDATA_T57	57
+#define MXT_PROCG_NOISESUPPRESSION_T62	62
+#define MXT_PROCI_LENSBENDING_T65	65
+#define MXT_PROCG_NOISESUPPRESSION_T72	72
+#define MXT_PROCI_GLOVEDETECTION_T78	78
+#define MXT_PROCI_RETRANSMISSIONCOMPANSATION_T80	80
+#define MXT_PROCG_NOISESUPACTIVESTYLUS_T86	86
+#define MXT_PROCI_SYMBOLGESTUREPROCESSOR_T92	92
+#define MXT_PROCI_TOUCHSEQUENCELOGGER_T93	93
+#define MXT_PROCG_PTCNOISESUPPRESSION_T98	98
+#define MXT_PROCI_ACTIVESTYLUS_T107	107
+#define MXT_PROCG_NOISESUPSELFCAP_T108	108
+#define MXT_PROCI_SELFCAPGRIPSUPPRESSION_T112	112
 #define MXT_SPT_COMMSCONFIG_T18		18
 #define MXT_SPT_GPIOPWM_T19		19
 #define MXT_SPT_SELFTEST_T25		25
@@ -79,9 +92,28 @@
 #define MXT_SPT_DIGITIZER_T43		43
 #define MXT_SPT_MESSAGECOUNT_T44	44
 #define MXT_SPT_CTECONFIG_T46		46
-
-/* MXT_GEN_MESSAGE_T5 object */
-#define MXT_RPTID_NOMSG		0xff
+#define MXT_SPT_TIMER_T61		61
+#define MXT_SPT_GOLDENREFERENCES_T66	66
+#define MXT_SPT_SERIALDATACOMMAND_T68	68
+#define MXT_SPT_DYNAMICCONFIGURATIONCONTROLLER_T70	70
+#define MXT_SPT_DYNAMICCONFIGURATIONCONTAINER_T71	71
+#define MXT_SPT_CTESCANCONFIG_T77	77
+#define MXT_SPT_TOUCHEVENTTRIGGER_T79	79
+#define MXT_SPT_PTCCONFIG_T95		95
+#define MXT_SPT_PTCTUNINGPARAMS_T96	96
+#define MXT_SPT_TOUCHSCREENHOVER_T101	101
+#define MXT_SPT_AUXTOUCHCONFIG_T104	104
+#define MXT_SPT_SELFCAPGLOBALCONFIG_T109	109
+#define MXT_SPT_SELFCAPTUNINGPARAMS_T110	110
+#define MXT_SPT_SELFCAPCONFIG_T111	111
+#define MXT_SPT_SELFCAPMEASURECONFIG_T113	113
+#define MXT_SPT_ACTIVESTYLUSMEASCONFIG_T114	114
+#define MXT_TOUCH_MULTI_T9		9
+#define MXT_TOUCH_KEYARRAY_T15		15
+#define MXT_TOUCH_PROXIMITY_T23		23
+#define MXT_TOUCH_PROXKEY_T52		52
+#define MXT_TOUCH_PTCKEYS_T97		97
+#define MXT_TOUCH_MULTITOUCHSCREEN_T100 100
 
 /* MXT_GEN_COMMAND_T6 field */
 #define MXT_COMMAND_RESET	0
@@ -90,13 +122,14 @@
 #define MXT_COMMAND_REPORTALL	3
 #define MXT_COMMAND_DIAGNOSTIC	5
 
-/* Define for T6 status byte */
-#define MXT_T6_STATUS_RESET	(1 << 7)
-#define MXT_T6_STATUS_OFL	(1 << 6)
-#define MXT_T6_STATUS_SIGERR	(1 << 5)
-#define MXT_T6_STATUS_CAL	(1 << 4)
-#define MXT_T6_STATUS_CFGERR	(1 << 3)
-#define MXT_T6_STATUS_COMSERR	(1 << 2)
+#define MXT_T6_CMD_PAGE_UP		0x01
+#define MXT_T6_CMD_PAGE_DOWN		0x02
+#define MXT_T6_CMD_DELTAS		0x10
+#define MXT_T6_CMD_REFS			0x11
+#define MXT_T6_CMD_DEVICE_ID		0x80
+#define MXT_T6_CMD_TOUCH_THRESH		0xF4
+#define MXT_T6_CMD_SELF_DELTAS		0xF7
+#define MXT_T6_CMD_SELF_REFS		0xF8
 
 /* MXT_GEN_POWER_T7 field */
 #define MXT_POWER_IDLEACQINT	0
@@ -114,26 +147,72 @@
 
 /* MXT_TOUCH_MULTI_T9 field */
 #define MXT_TOUCH_CTRL		0
-#define MXT_T9_ORIENT		9
-#define MXT_T9_RANGE		18
-
-/* MXT_TOUCH_MULTI_T9 status */
-#define MXT_T9_UNGRIP		(1 << 0)
-#define MXT_T9_SUPPRESS		(1 << 1)
-#define MXT_T9_AMP		(1 << 2)
-#define MXT_T9_VECTOR		(1 << 3)
-#define MXT_T9_MOVE		(1 << 4)
-#define MXT_T9_RELEASE		(1 << 5)
-#define MXT_T9_PRESS		(1 << 6)
-#define MXT_T9_DETECT		(1 << 7)
-
-struct t9_range {
-	u16 x;
-	u16 y;
-} __packed;
-
-/* MXT_TOUCH_MULTI_T9 orient */
-#define MXT_T9_ORIENT_SWITCH	(1 << 0)
+#define MXT_TOUCH_XORIGIN	1
+#define MXT_TOUCH_YORIGIN	2
+#define MXT_TOUCH_XSIZE		3
+#define MXT_TOUCH_YSIZE		4
+#define MXT_TOUCH_BLEN		6
+#define MXT_TOUCH_TCHTHR	7
+#define MXT_TOUCH_TCHDI		8
+#define MXT_TOUCH_ORIENT	9
+#define MXT_TOUCH_MOVHYSTI	11
+#define MXT_TOUCH_MOVHYSTN	12
+#define MXT_TOUCH_NUMTOUCH	14
+#define MXT_TOUCH_MRGHYST	15
+#define MXT_TOUCH_MRGTHR	16
+#define MXT_TOUCH_AMPHYST	17
+#define MXT_TOUCH_XRANGE_LSB	18
+#define MXT_TOUCH_XRANGE_MSB	19
+#define MXT_TOUCH_YRANGE_LSB	20
+#define MXT_TOUCH_YRANGE_MSB	21
+#define MXT_TOUCH_XLOCLIP	22
+#define MXT_TOUCH_XHICLIP	23
+#define MXT_TOUCH_YLOCLIP	24
+#define MXT_TOUCH_YHICLIP	25
+#define MXT_TOUCH_XEDGECTRL	26
+#define MXT_TOUCH_XEDGEDIST	27
+#define MXT_TOUCH_YEDGECTRL	28
+#define MXT_TOUCH_YEDGEDIST	29
+#define MXT_TOUCH_JUMPLIMIT	30
+
+/* T100 Multiple Touch Touchscreen */
+#define MXT_T100_CTRL      0
+#define MXT_T100_CFG1      1
+#define MXT_T100_SCRAUX    2
+#define MXT_T100_TCHAUX    3
+#define MXT_T100_XRANGE    13
+#define MXT_T100_YRANGE    24
+#define MXT_T100_XSIZE     9
+#define MXT_T100_YSIZE     20
+
+#define MXT_T100_CFG_SWITCHXY	(1 << 5)
+
+#define MXT_T100_SRCAUX_NUMRPTTCH	(1 << 0)
+#define MXT_T100_SRCAUX_TCHAREA		(1 << 1)
+#define MXT_T100_SRCAUX_ATCHAREA	(1 << 2)
+#define MXT_T100_SRCAUX_INTTHRAREA	(1 << 3)
+
+#define MXT_T100_TCHAUX_VECT	(1 << 0)
+#define MXT_T100_TCHAUX_AMPL	(1 << 1)
+#define MXT_T100_TCHAUX_AREA	(1 << 2)
+#define MXT_T100_TCHAUX_PEAK	(1 << 4)
+
+
+/* MXT_TOUCH_CTRL bits */
+#define MXT_TOUCH_CTRL_ENABLE	(1 << 0)
+#define MXT_TOUCH_CTRL_RPTEN	(1 << 1)
+#define MXT_TOUCH_CTRL_DISAMP	(1 << 2)
+#define MXT_TOUCH_CTRL_DISVECT	(1 << 3)
+#define MXT_TOUCH_CTRL_DISMOVE	(1 << 4)
+#define MXT_TOUCH_CTRL_DISREL	(1 << 5)
+#define MXT_TOUCH_CTRL_DISPRESS	(1 << 6)
+#define MXT_TOUCH_CTRL_SCANEN	(1 << 7)
+#define MXT_TOUCH_CTRL_OPERATIONAL	(MXT_TOUCH_CTRL_ENABLE | \
+					 MXT_TOUCH_CTRL_SCANEN | \
+					 MXT_TOUCH_CTRL_RPTEN)
+#define MXT_TOUCH_CTRL_SCANNING		(MXT_TOUCH_CTRL_ENABLE | \
+					 MXT_TOUCH_CTRL_SCANEN)
+#define MXT_TOUCH_CTRL_OFF		0x0
 
 /* MXT_PROCI_GRIPFACE_T20 field */
 #define MXT_GRIPFACE_CTRL	0
@@ -182,16 +261,23 @@
 
 /* Define for MXT_GEN_COMMAND_T6 */
 #define MXT_BOOT_VALUE		0xa5
-#define MXT_RESET_VALUE		0x01
 #define MXT_BACKUP_VALUE	0x55
-
-/* Delay times */
 #define MXT_BACKUP_TIME		50	/* msec */
 #define MXT_RESET_TIME		200	/* msec */
-#define MXT_RESET_TIMEOUT	3000	/* msec */
-#define MXT_CRC_TIMEOUT		1000	/* msec */
-#define MXT_FW_RESET_TIME	3000	/* msec */
-#define MXT_FW_CHG_TIMEOUT	300	/* msec */
+#define MXT_CAL_TIME		25	/* msec */
+
+#define MXT_FWRESET_TIME	500	/* msec */
+
+#define MXT_POWERON_DELAY	250	/* msec */
+
+/* Default value for acquisition interval when in suspend mode*/
+#define MXT_SUSPEND_ACQINT_VALUE 32      /* msec */
+
+/* MXT_SPT_GPIOPWM_T19 field */
+#define MXT_GPIO0_MASK		0x04
+#define MXT_GPIO1_MASK		0x08
+#define MXT_GPIO2_MASK		0x10
+#define MXT_GPIO3_MASK		0x20
 
 /* Command to unlock bootloader */
 #define MXT_UNLOCK_CMD_MSB	0xaa
@@ -205,14 +291,69 @@
 #define MXT_FRAME_CRC_PASS	0x04
 #define MXT_APP_CRC_FAIL	0x40	/* valid 7 8 bit only */
 #define MXT_BOOT_STATUS_MASK	0x3f
-#define MXT_BOOT_EXTENDED_ID	(1 << 5)
-#define MXT_BOOT_ID_MASK	0x1f
+
+/* Touch status */
+#define MXT_UNGRIP		(1 << 0)
+#define MXT_SUPPRESS		(1 << 1)
+#define MXT_AMP			(1 << 2)
+#define MXT_VECTOR		(1 << 3)
+#define MXT_MOVE		(1 << 4)
+#define MXT_RELEASE		(1 << 5)
+#define MXT_PRESS		(1 << 6)
+#define MXT_DETECT		(1 << 7)
+
+/* Touch orient bits */
+#define MXT_XY_SWITCH		(1 << 0)
+#define MXT_X_INVERT		(1 << 1)
+#define MXT_Y_INVERT		(1 << 2)
 
 /* Touchscreen absolute values */
 #define MXT_MAX_AREA		0xff
 
+/* Fallback T7 values to restore functionality in the event of i2c problems */
+#define FALLBACK_MXT_POWER_IDLEACQINT	0xff
+#define FALLBACK_MXT_POWER_ACTVACQINT	0xff
+#define FALLBACK_MXT_POWER_ACTV2IDLETO	0x20
+
+/* For CMT (must match XRANGE/YRANGE as defined in board config */
 #define MXT_PIXELS_PER_MM	20
 
+/* Define for TOUCH_MOUTITOUCHSCREEN_T100 Touch Status */
+#define TOUCH_STATUS_DETECT			0x80
+#define TOUCH_STATUS_EVENT_MOVE		0x01
+#define TOUCH_STATUS_EVENT_UNSUP	0x02
+#define TOUCH_STATUS_EVENT_SUP		0x03
+#define TOUCH_STATUS_EVENT_DOWN		0x04
+#define TOUCH_STATUS_EVENT_UP		0x05
+#define TOUCH_STATUS_EVENT_UNSUPSUP	0x06
+#define TOUCH_STATUS_EVENT_UNSUPUP	0x07
+#define TOUCH_STATUS_EVENT_DOWNSUP	0x08
+#define TOUCH_STATUS_EVENT_DOWNUP	0x09
+
+/* MXT touch types */
+#define TOUCH_STATUS_TYPE_RESERVED	0
+#define TOUCH_STATUS_TYPE_FINGER	1
+#define TOUCH_STATUS_TYPE_STYLUS	2
+#define TOUCH_STATUS_TYPE_HOVERING	4
+#define TOUCH_STATUS_TYPE_GLOVE		5
+#define TOUCH_STATUS_TYPE_LARGE_TOUCH	6
+
+#define DISTANCE_ACTIVE_TOUCH		0
+#define DISTANCE_HOVERING		1
+
+struct mxt_cfg_file_hdr {
+	bool valid;
+	u32 info_crc;
+	u32 cfg_crc;
+};
+
+struct mxt_cfg_file_line {
+	struct list_head list;
+	u16 addr;
+	u8 size;
+	u8 *content;
+};
+
 struct mxt_info {
 	u8 family_id;
 	u8 variant_id;
@@ -226,63 +367,175 @@
 struct mxt_object {
 	u8 type;
 	u16 start_address;
-	u8 size_minus_one;
-	u8 instances_minus_one;
+	u8 size;		/* Size of each instance - 1 */
+	u8 instances;		/* Number of instances - 1 */
 	u8 num_report_ids;
 } __packed;
 
 /* Each client has this additional data */
 struct mxt_data {
 	struct i2c_client *client;
+	struct regulator *vdd;
+	struct regulator *avdd;
 	struct input_dev *input_dev;
 	char phys[64];		/* device physical location */
 	const struct mxt_platform_data *pdata;
 	struct mxt_object *object_table;
 	struct mxt_info info;
+	bool is_tp;
+
+	struct gpio_desc *reset_gpio;
+
 	unsigned int irq;
+
 	unsigned int max_x;
 	unsigned int max_y;
-	bool in_bootloader;
-	u16 mem_size;
-	u8 max_reportid;
-	u32 config_crc;
-	u32 info_crc;
-	u8 bootloader_addr;
-	u8 *msg_buf;
-	u8 t6_status;
-	bool update_input;
-	u8 last_message_count;
-	u8 num_touchids;
+
+	/* max touchscreen area in terms of pixels and channels */
+	unsigned int max_area_pixels;
+	unsigned int max_area_channels;
+
+	unsigned int num_touchids;
+
+	u32 info_csum;
+	u32 config_csum;
+
+	bool has_T9;
+	bool has_T100;
 
 	/* Cached parameters from object table */
 	u16 T5_address;
-	u8 T5_msg_size;
 	u8 T6_reportid;
-	u16 T6_address;
-	u16 T7_address;
 	u8 T9_reportid_min;
 	u8 T9_reportid_max;
 	u8 T19_reportid;
 	u16 T44_address;
+	u8 T100_reportid_min;
+	u8 T100_reportid_max;
+	u8 message_length;
+
+	/* T100 Configuration.  Which calculations are enabled*/
+	bool T100_enabled_num_reportable_touches;
+	bool T100_enabled_touch_area;
+	bool T100_enabled_antitouch_area;
+	bool T100_enabled_internal_tracking_area;
+	bool T100_enabled_vector;
+	bool T100_enabled_amplitude;
+	bool T100_enabled_area;
+	bool T100_enabled_peak;
 
 	/* for fw update in bootloader */
 	struct completion bl_completion;
 
-	/* for reset handling */
-	struct completion reset_completion;
+	/* per-instance debugfs root */
+	struct dentry *dentry_dev;
+	struct dentry *dentry_deltas;
+	struct dentry *dentry_refs;
+	struct dentry *dentry_object;
+	/* for self-capacitance information */
+	struct dentry *dentry_self_deltas;
+	struct dentry *dentry_self_refs;
+
+	/* Protect access to the T37 object buffer, used by debugfs */
+	struct mutex T37_buf_mutex;
+	u8 *T37_buf;
+	size_t T37_buf_size;
+
+	/* Saved T7 configuration
+	 * [0] = IDLEACQINT
+	 * [1] = ACTVACQINT
+	 * [2] = ACTV2IDLETO
+	 */
+	u8 T7_config[3];
+	bool T7_config_valid;
+
+	/* T7 IDLEACQINT & ACTVACQINT setting when in suspend mode*/
+	u8 suspend_acq_interval;
+
+	/* Saved T9 Ctrl field */
+	u8 T9_ctrl;
+	bool T9_ctrl_valid;
+
+	u8 T100_ctrl;
+	bool T100_ctrl_valid;
+
+	u8 T101_ctrl;
+	bool T101_ctrl_valid;
+
+	bool irq_wake;  /* irq wake is enabled */
+	/* Saved T42 Touch Suppression field */
+	u8 T42_ctrl;
+	bool T42_ctrl_valid;
+
+	/* Saved T19 GPIO config */
+	u8 T19_ctrl;
+	bool T19_ctrl_valid;
+
+	/* Protect access to the object register buffer */
+	struct mutex object_str_mutex;
+	char *object_str;
+	size_t object_str_size;
 
-	/* for config update handling */
-	struct completion crc_completion;
+	/* for auto-calibration in suspend */
+	struct completion auto_cal_completion;
+
+	/*
+	 * Protects from concurrent firmware/config updates and
+	 * suspending/resuming.
+	 */
+	struct mutex fw_mutex;
+
+	/* firmware file name */
+	char *fw_file;
+
+	/* config file name */
+	char *config_file;
+
+	/* map for the tracking id currently being used */
+	bool *current_id;
+
+	/* Cleanup flags */
+	bool sysfs_group_created;
+	bool power_sysfs_group_merged;
+	bool debugfs_initialized;
 };
 
-static size_t mxt_obj_size(const struct mxt_object *obj)
+/* global root node of the atmel_mxt_ts debugfs directory. */
+static struct dentry *mxt_debugfs_root;
+
+static int mxt_calc_resolution_T9(struct mxt_data *data);
+static int mxt_calc_resolution_T100(struct mxt_data *data);
+static int mxt_check_device_present(struct mxt_data *data,
+				    bool probe_alternate);
+static void mxt_free_object_table(struct mxt_data *data);
+static int mxt_initialize(struct mxt_data *data);
+static int mxt_input_dev_create(struct mxt_data *data);
+static int get_touch_major_pixels(struct mxt_data *data, int touch_channels);
+
+static inline bool is_mxt_33x_t(struct mxt_data *data)
+{
+	struct mxt_info *info = &data->info;
+	/* vairant_id: 336t(5), 337t(17) */
+	return ((info->family_id == 164) &&
+		((info->variant_id == 5) || (info->variant_id == 17)));
+}
+
+static inline bool is_hovering_supported(struct mxt_data *data)
+{
+	struct mxt_info *info = &data->info;
+	/* vairant_id: 337t(164.17), 2954t2(164.13) */
+	return ((info->family_id == 164) &&
+		((info->variant_id == 13) || (info->variant_id == 17)));
+}
+
+static inline size_t mxt_obj_size(const struct mxt_object *obj)
 {
-	return obj->size_minus_one + 1;
+	return obj->size + 1;
 }
 
-static size_t mxt_obj_instances(const struct mxt_object *obj)
+static inline size_t mxt_obj_instances(const struct mxt_object *obj)
 {
-	return obj->instances_minus_one + 1;
+	return obj->instances + 1;
 }
 
 static bool mxt_object_readable(unsigned int type)
@@ -292,10 +545,70 @@
 	case MXT_GEN_POWER_T7:
 	case MXT_GEN_ACQUIRE_T8:
 	case MXT_GEN_DATASOURCE_T53:
+	case MXT_PROCI_GRIPFACE_T20:
+	case MXT_PROCG_NOISE_T22:
+	case MXT_PROCI_ONETOUCH_T24:
+	case MXT_PROCI_TWOTOUCH_T27:
+	case MXT_PROCI_GRIP_T40:
+	case MXT_PROCI_PALM_T41:
+	case MXT_PROCI_TOUCHSUPPRESSION_T42:
+	case MXT_PROCI_STYLUS_T47:
+	case MXT_PROCG_NOISESUPPRESSION_T48:
+	case MXT_PROCI_ADAPTIVETHRESHOLD_T55:
+	case MXT_PROCI_SHIELDLESS_T56:
+	case MXT_PROCI_EXTRATOUCHSCREENDATA_T57:
+	case MXT_PROCG_NOISESUPPRESSION_T62:
+	case MXT_PROCI_LENSBENDING_T65:
+	case MXT_PROCG_NOISESUPPRESSION_T72:
+	case MXT_PROCI_GLOVEDETECTION_T78:
+	case MXT_PROCI_RETRANSMISSIONCOMPANSATION_T80:
+	case MXT_PROCG_NOISESUPACTIVESTYLUS_T86:
+	case MXT_PROCI_SYMBOLGESTUREPROCESSOR_T92:
+	case MXT_PROCI_TOUCHSEQUENCELOGGER_T93:
+	case MXT_PROCG_PTCNOISESUPPRESSION_T98:
+	case MXT_PROCI_ACTIVESTYLUS_T107:
+	case MXT_PROCG_NOISESUPSELFCAP_T108:
+	case MXT_PROCI_SELFCAPGRIPSUPPRESSION_T112:
+	case MXT_SPT_COMMSCONFIG_T18:
+	case MXT_SPT_GPIOPWM_T19:
+	case MXT_SPT_SELFTEST_T25:
+	case MXT_SPT_CTECONFIG_T28:
+	case MXT_SPT_USERDATA_T38:
+	case MXT_SPT_DIGITIZER_T43:
+	case MXT_SPT_CTECONFIG_T46:
+	case MXT_SPT_TIMER_T61:
+	case MXT_SPT_GOLDENREFERENCES_T66:
+	case MXT_SPT_DYNAMICCONFIGURATIONCONTROLLER_T70:
+	case MXT_SPT_DYNAMICCONFIGURATIONCONTAINER_T71:
+	case MXT_SPT_CTESCANCONFIG_T77:
+	case MXT_SPT_TOUCHEVENTTRIGGER_T79:
+	case MXT_SPT_PTCCONFIG_T95:
+	case MXT_SPT_PTCTUNINGPARAMS_T96:
+	case MXT_SPT_TOUCHSCREENHOVER_T101:
+	case MXT_SPT_AUXTOUCHCONFIG_T104:
+	case MXT_SPT_SELFCAPGLOBALCONFIG_T109:
+	case MXT_SPT_SELFCAPTUNINGPARAMS_T110:
+	case MXT_SPT_SELFCAPCONFIG_T111:
+	case MXT_SPT_SELFCAPMEASURECONFIG_T113:
+	case MXT_SPT_ACTIVESTYLUSMEASCONFIG_T114:
 	case MXT_TOUCH_MULTI_T9:
 	case MXT_TOUCH_KEYARRAY_T15:
 	case MXT_TOUCH_PROXIMITY_T23:
 	case MXT_TOUCH_PROXKEY_T52:
+	case MXT_TOUCH_PTCKEYS_T97:
+	case MXT_TOUCH_MULTITOUCHSCREEN_T100:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool mxt_object_writable(unsigned int type)
+{
+	switch (type) {
+	case MXT_GEN_COMMAND_T6:
+	case MXT_GEN_POWER_T7:
+	case MXT_GEN_ACQUIRE_T8:
 	case MXT_PROCI_GRIPFACE_T20:
 	case MXT_PROCG_NOISE_T22:
 	case MXT_PROCI_ONETOUCH_T24:
@@ -305,6 +618,21 @@
 	case MXT_PROCI_TOUCHSUPPRESSION_T42:
 	case MXT_PROCI_STYLUS_T47:
 	case MXT_PROCG_NOISESUPPRESSION_T48:
+	case MXT_PROCI_ADAPTIVETHRESHOLD_T55:
+	case MXT_PROCI_SHIELDLESS_T56:
+	case MXT_PROCI_EXTRATOUCHSCREENDATA_T57:
+	case MXT_PROCG_NOISESUPPRESSION_T62:
+	case MXT_PROCI_LENSBENDING_T65:
+	case MXT_PROCG_NOISESUPPRESSION_T72:
+	case MXT_PROCI_GLOVEDETECTION_T78:
+	case MXT_PROCI_RETRANSMISSIONCOMPANSATION_T80:
+	case MXT_PROCG_NOISESUPACTIVESTYLUS_T86:
+	case MXT_PROCI_SYMBOLGESTUREPROCESSOR_T92:
+	case MXT_PROCI_TOUCHSEQUENCELOGGER_T93:
+	case MXT_PROCG_PTCNOISESUPPRESSION_T98:
+	case MXT_PROCI_ACTIVESTYLUS_T107:
+	case MXT_PROCG_NOISESUPSELFCAP_T108:
+	case MXT_PROCI_SELFCAPGRIPSUPPRESSION_T112:
 	case MXT_SPT_COMMSCONFIG_T18:
 	case MXT_SPT_GPIOPWM_T19:
 	case MXT_SPT_SELFTEST_T25:
@@ -312,216 +640,254 @@
 	case MXT_SPT_USERDATA_T38:
 	case MXT_SPT_DIGITIZER_T43:
 	case MXT_SPT_CTECONFIG_T46:
+	case MXT_SPT_TIMER_T61:
+	case MXT_SPT_GOLDENREFERENCES_T66:
+	case MXT_SPT_SERIALDATACOMMAND_T68:
+	case MXT_SPT_DYNAMICCONFIGURATIONCONTROLLER_T70:
+	case MXT_SPT_DYNAMICCONFIGURATIONCONTAINER_T71:
+	case MXT_SPT_CTESCANCONFIG_T77:
+	case MXT_SPT_TOUCHEVENTTRIGGER_T79:
+	case MXT_SPT_PTCCONFIG_T95:
+	case MXT_SPT_PTCTUNINGPARAMS_T96:
+	case MXT_SPT_TOUCHSCREENHOVER_T101:
+	case MXT_SPT_AUXTOUCHCONFIG_T104:
+	case MXT_SPT_SELFCAPGLOBALCONFIG_T109:
+	case MXT_SPT_SELFCAPTUNINGPARAMS_T110:
+	case MXT_SPT_SELFCAPCONFIG_T111:
+	case MXT_SPT_SELFCAPMEASURECONFIG_T113:
+	case MXT_SPT_ACTIVESTYLUSMEASCONFIG_T114:
+	case MXT_TOUCH_MULTI_T9:
+	case MXT_TOUCH_KEYARRAY_T15:
+	case MXT_TOUCH_PROXIMITY_T23:
+	case MXT_TOUCH_PROXKEY_T52:
+	case MXT_TOUCH_PTCKEYS_T97:
+	case MXT_TOUCH_MULTITOUCHSCREEN_T100:
 		return true;
 	default:
 		return false;
 	}
 }
 
-static void mxt_dump_message(struct mxt_data *data, u8 *message)
+static void mxt_dump_message(struct device *dev, u8 *message)
 {
-	dev_dbg(&data->client->dev, "message: %*ph\n",
-		data->T5_msg_size, message);
+	dev_dbg(dev, "reportid: %u\tmessage: %*ph\n",
+		message[0], 7, &message[1]);
 }
 
-static int mxt_wait_for_completion(struct mxt_data *data,
-				   struct completion *comp,
-				   unsigned int timeout_ms)
+/*
+ * Release all the fingers that are being tracked. To avoid unwanted gestures,
+ * move all the fingers to (0,0) with largest PRESSURE and TOUCH_MAJOR.
+ * Userspace apps can use these info to filter out these events and/or cancel
+ * existing gestures.
+ */
+static void __maybe_unused mxt_release_all_fingers(struct mxt_data *data)
 {
 	struct device *dev = &data->client->dev;
-	unsigned long timeout = msecs_to_jiffies(timeout_ms);
-	long ret;
+	struct input_dev *input_dev = data->input_dev;
+	int id;
+	int max_area_channels = min(255U, data->max_area_channels);
+	int max_touch_major = get_touch_major_pixels(data, max_area_channels);
+	bool need_update = false;
+	for (id = 0; id < data->num_touchids; id++) {
+		if (data->current_id[id]) {
+			dev_warn(dev, "Move touch %d to (0,0)\n", id);
+			input_mt_slot(input_dev, id);
+			input_mt_report_slot_state(input_dev, MT_TOOL_FINGER,
+						   true);
+			input_report_abs(input_dev, ABS_MT_POSITION_X, 0);
+			input_report_abs(input_dev, ABS_MT_POSITION_Y, 0);
+			input_report_abs(input_dev, ABS_MT_PRESSURE, 255);
+			input_report_abs(input_dev, ABS_MT_DISTANCE,
+					 DISTANCE_ACTIVE_TOUCH);
+			input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR,
+					 max_touch_major);
+			need_update = true;
+		}
+	}
+	if (need_update)
+		input_sync(data->input_dev);
 
-	ret = wait_for_completion_interruptible_timeout(comp, timeout);
-	if (ret < 0) {
-		return ret;
-	} else if (ret == 0) {
-		dev_err(dev, "Wait for completion timed out.\n");
-		return -ETIMEDOUT;
+	for (id = 0; id < data->num_touchids; id++) {
+		if (data->current_id[id]) {
+			dev_warn(dev, "Release touch contact %d\n", id);
+			input_mt_slot(input_dev, id);
+			input_mt_report_slot_state(input_dev, MT_TOOL_FINGER,
+						   false);
+			data->current_id[id] = false;
+		}
 	}
-	return 0;
+	if (need_update)
+		input_sync(data->input_dev);
 }
 
-static int mxt_bootloader_read(struct mxt_data *data,
-			       u8 *val, unsigned int count)
+static bool mxt_in_bootloader(struct mxt_data *data)
 {
-	int ret;
-	struct i2c_msg msg;
+	struct i2c_client *client = data->client;
+	return (client->addr == 0x25 ||
+		client->addr == 0x26 ||
+		client->addr == 0x27);
+}
+
+static bool mxt_in_appmode(struct mxt_data *data)
+{
+	struct i2c_client *client = data->client;
+	return (client->addr == 0x4a || client->addr == 0x4b);
+}
 
-	msg.addr = data->bootloader_addr;
-	msg.flags = data->client->flags & I2C_M_TEN;
-	msg.flags |= I2C_M_RD;
-	msg.len = count;
-	msg.buf = val;
+static int mxt_i2c_recv(struct i2c_client *client, u8 *buf, size_t count)
+{
+	int ret;
 
-	ret = i2c_transfer(data->client->adapter, &msg, 1);
-	if (ret == 1) {
+	ret = i2c_master_recv(client, buf, count);
+	if (ret == count) {
 		ret = 0;
-	} else {
-		ret = ret < 0 ? ret : -EIO;
-		dev_err(&data->client->dev, "%s: i2c recv failed (%d)\n",
-			__func__, ret);
+	} else if (ret != count) {
+		ret = (ret < 0) ? ret : -EIO;
+		dev_err(&client->dev, "i2c recv failed (%d)\n", ret);
 	}
 
 	return ret;
 }
 
-static int mxt_bootloader_write(struct mxt_data *data,
-				const u8 * const val, unsigned int count)
+static int mxt_i2c_send(struct i2c_client *client, const u8 *buf, size_t count)
 {
 	int ret;
-	struct i2c_msg msg;
-
-	msg.addr = data->bootloader_addr;
-	msg.flags = data->client->flags & I2C_M_TEN;
-	msg.len = count;
-	msg.buf = (u8 *)val;
 
-	ret = i2c_transfer(data->client->adapter, &msg, 1);
-	if (ret == 1) {
+	ret = i2c_master_send(client, buf, count);
+	if (ret == count) {
 		ret = 0;
-	} else {
-		ret = ret < 0 ? ret : -EIO;
-		dev_err(&data->client->dev, "%s: i2c send failed (%d)\n",
-			__func__, ret);
+	} else if (ret != count) {
+		ret = (ret < 0) ? ret : -EIO;
+		dev_err(&client->dev, "i2c send failed (%d)\n", ret);
 	}
 
 	return ret;
 }
 
-static int mxt_lookup_bootloader_address(struct mxt_data *data, bool retry)
+static int mxt_i2c_transfer(struct i2c_client *client, struct i2c_msg *msgs,
+		size_t count)
 {
-	u8 appmode = data->client->addr;
-	u8 bootloader;
-
-	switch (appmode) {
-	case 0x4a:
-	case 0x4b:
-		/* Chips after 1664S use different scheme */
-		if (retry || data->info.family_id >= 0xa2) {
-			bootloader = appmode - 0x24;
-			break;
-		}
-		/* Fall through for normal case */
-	case 0x4c:
-	case 0x4d:
-	case 0x5a:
-	case 0x5b:
-		bootloader = appmode - 0x26;
-		break;
+	int ret;
 
-	default:
-		dev_err(&data->client->dev,
-			"Appmode i2c address 0x%02x not found\n",
-			appmode);
-		return -EINVAL;
+	ret = i2c_transfer(client->adapter, msgs, count);
+	if (ret == count) {
+		ret = 0;
+	} else {
+		ret = (ret < 0) ? ret : -EIO;
+		dev_err(&client->dev, "i2c transfer failed (%d)\n", ret);
 	}
 
-	data->bootloader_addr = bootloader;
-	return 0;
+	return ret;
 }
 
-static int mxt_probe_bootloader(struct mxt_data *data, bool alt_address)
+static int mxt_wait_for_chg(struct mxt_data *data, unsigned int timeout_ms)
 {
 	struct device *dev = &data->client->dev;
-	int error;
-	u8 val;
-	bool crc_failure;
-
-	error = mxt_lookup_bootloader_address(data, alt_address);
-	if (error)
-		return error;
-
-	error = mxt_bootloader_read(data, &val, 1);
-	if (error)
-		return error;
-
-	/* Check app crc fail mode */
-	crc_failure = (val & ~MXT_BOOT_STATUS_MASK) == MXT_APP_CRC_FAIL;
-
-	dev_err(dev, "Detected bootloader, status:%02X%s\n",
-			val, crc_failure ? ", APP_CRC_FAIL" : "");
+	struct completion *comp = &data->bl_completion;
+	unsigned long timeout = msecs_to_jiffies(timeout_ms);
+	long ret;
 
+	ret = wait_for_completion_interruptible_timeout(comp, timeout);
+	if (ret < 0) {
+		dev_err(dev, "Wait for completion interrupted.\n");
+		/*
+		 * TODO: handle -EINTR better by terminating fw update process
+		 * before returning to userspace by writing length 0x000 to
+		 * device (iff we are in WAITING_FRAME_DATA state).
+		 */
+		return -EINTR;
+	} else if (ret == 0) {
+		dev_err(dev, "Wait for completion timed out.\n");
+		return -ETIMEDOUT;
+	}
 	return 0;
 }
 
-static u8 mxt_get_bootloader_version(struct mxt_data *data, u8 val)
+
+static int mxt_lookup_bootloader_address(struct mxt_data *data)
 {
-	struct device *dev = &data->client->dev;
-	u8 buf[3];
+	u8 addr = data->client->addr;
+	u8 family_id = data->info.family_id;
+	u8 bootloader = 0;
+
+	if (mxt_in_bootloader(data))
+		return addr;
+
+	if (addr == 0x4a) {
+		bootloader = 0x26;
+	} else if (addr == 0x4b) {
+		bootloader = family_id >= 0xa2 ? 0x27 : 0x25;
+	} else {
+		dev_err(&data->client->dev,
+			"Appmode i2c address 0x%02x not found\n", addr);
+	}
+	return bootloader;
+}
 
-	if (val & MXT_BOOT_EXTENDED_ID) {
-		if (mxt_bootloader_read(data, &buf[0], 3) != 0) {
-			dev_err(dev, "%s: i2c failure\n", __func__);
-			return val;
-		}
+static int mxt_lookup_appmode_address(struct mxt_data *data)
+{
+	u8 addr = data->client->addr;
+	u8 appmode = 0;
 
-		dev_dbg(dev, "Bootloader ID:%d Version:%d\n", buf[1], buf[2]);
+	if (mxt_in_appmode(data))
+		return addr;
 
-		return buf[0];
+	if (addr == 0x26)
+		appmode = 0x4a;
+	else if (addr == 0x25 || addr == 0x27) {
+		appmode = 0x4b;
 	} else {
-		dev_dbg(dev, "Bootloader ID:%d\n", val & MXT_BOOT_ID_MASK);
-
-		return val;
+		dev_err(&data->client->dev,
+			"Bootloader mode i2c address 0x%02x not found\n", addr);
 	}
+	return appmode;
 }
 
-static int mxt_check_bootloader(struct mxt_data *data, unsigned int state,
-				bool wait)
+
+static int mxt_check_bootloader(struct mxt_data *data, unsigned int state)
 {
-	struct device *dev = &data->client->dev;
+	struct i2c_client *client = data->client;
 	u8 val;
 	int ret;
 
 recheck:
-	if (wait) {
+	if (state != MXT_WAITING_BOOTLOAD_CMD) {
 		/*
 		 * In application update mode, the interrupt
 		 * line signals state transitions. We must wait for the
 		 * CHG assertion before reading the status byte.
 		 * Once the status byte has been read, the line is deasserted.
 		 */
-		ret = mxt_wait_for_completion(data, &data->bl_completion,
-					      MXT_FW_CHG_TIMEOUT);
+		int ret = mxt_wait_for_chg(data, 300);
 		if (ret) {
-			/*
-			 * TODO: handle -ERESTARTSYS better by terminating
-			 * fw update process before returning to userspace
-			 * by writing length 0x000 to device (iff we are in
-			 * WAITING_FRAME_DATA state).
-			 */
-			dev_err(dev, "Update wait error %d\n", ret);
+			dev_err(&client->dev,
+				"Update wait error %d, state %d\n", ret, state);
 			return ret;
 		}
 	}
 
-	ret = mxt_bootloader_read(data, &val, 1);
+	ret = mxt_i2c_recv(client, &val, 1);
 	if (ret)
 		return ret;
 
-	if (state == MXT_WAITING_BOOTLOAD_CMD)
-		val = mxt_get_bootloader_version(data, val);
-
 	switch (state) {
 	case MXT_WAITING_BOOTLOAD_CMD:
+		dev_info(&client->dev, "bootloader version: %d\n",
+			 val & MXT_BOOT_STATUS_MASK);
 	case MXT_WAITING_FRAME_DATA:
-	case MXT_APP_CRC_FAIL:
 		val &= ~MXT_BOOT_STATUS_MASK;
 		break;
 	case MXT_FRAME_CRC_PASS:
-		if (val == MXT_FRAME_CRC_CHECK) {
+		if (val == MXT_FRAME_CRC_CHECK)
 			goto recheck;
-		} else if (val == MXT_FRAME_CRC_FAIL) {
-			dev_err(dev, "Bootloader CRC fail\n");
-			return -EINVAL;
-		}
 		break;
 	default:
 		return -EINVAL;
 	}
 
 	if (val != state) {
-		dev_err(dev, "Invalid bootloader state %02X != %02X\n",
+		dev_err(&client->dev, "Unvalid bootloader mode state\n");
+		dev_err(&client->dev, "Invalid bootloader mode state %d, %d\n",
 			val, state);
 		return -EINVAL;
 	}
@@ -529,26 +895,49 @@
 	return 0;
 }
 
-static int mxt_send_bootloader_cmd(struct mxt_data *data, bool unlock)
+static int mxt_unlock_bootloader(struct i2c_client *client)
 {
-	int ret;
 	u8 buf[2];
 
-	if (unlock) {
-		buf[0] = MXT_UNLOCK_CMD_LSB;
-		buf[1] = MXT_UNLOCK_CMD_MSB;
-	} else {
-		buf[0] = 0x01;
-		buf[1] = 0x01;
-	}
+	buf[0] = MXT_UNLOCK_CMD_LSB;
+	buf[1] = MXT_UNLOCK_CMD_MSB;
 
-	ret = mxt_bootloader_write(data, buf, 2);
-	if (ret)
-		return ret;
+	return mxt_i2c_send(client, buf, 2);
+}
 
-	return 0;
+static int mxt_fw_write(struct i2c_client *client,
+			     const u8 *data, unsigned int frame_size)
+{
+	return mxt_i2c_send(client, data, frame_size);
 }
 
+#ifdef DEBUG
+#define DUMP_LEN	16
+static void mxt_dump_xfer(struct device *dev, const char *func, u16 reg,
+			  u16 len, const u8 *val)
+{
+	/* Rough guess for string size */
+	char str[DUMP_LEN * 3 + 2];
+	int i;
+	size_t n;
+
+	for (i = 0, n = 0; i < len; i++) {
+		n += snprintf(&str[n], sizeof(str) - n, "%02x ", val[i]);
+		if ((i + 1) % DUMP_LEN == 0 || (i + 1) == len) {
+			dev_dbg(dev,
+				"%s(reg: %d len: %d offset: 0x%02x): %s\n",
+				func, reg, len, (i / DUMP_LEN) * DUMP_LEN,
+				str);
+			n = 0;
+		}
+	}
+}
+#undef DUMP_LEN
+#else
+static void mxt_dump_xfer(struct device *dev, const char *func, u16 reg,
+			  u16 len, const u8 *val) { }
+#endif
+
 static int __mxt_read_reg(struct i2c_client *client,
 			       u16 reg, u16 len, void *val)
 {
@@ -571,15 +960,9 @@
 	xfer[1].len = len;
 	xfer[1].buf = val;
 
-	ret = i2c_transfer(client->adapter, xfer, 2);
-	if (ret == 2) {
-		ret = 0;
-	} else {
-		if (ret >= 0)
-			ret = -EIO;
-		dev_err(&client->dev, "%s: i2c transfer failed (%d)\n",
-			__func__, ret);
-	}
+	ret = mxt_i2c_transfer(client, xfer, 2);
+	if (ret == 0)
+		mxt_dump_xfer(&client->dev, __func__, reg, len, val);
 
 	return ret;
 }
@@ -600,16 +983,8 @@
 	buf[1] = (reg >> 8) & 0xff;
 	memcpy(&buf[2], val, len);
 
-	ret = i2c_master_send(client, buf, count);
-	if (ret == count) {
-		ret = 0;
-	} else {
-		if (ret >= 0)
-			ret = -EIO;
-		dev_err(&client->dev, "%s: i2c send failed (%d)\n",
-			__func__, ret);
-	}
-
+	mxt_dump_xfer(&client->dev, __func__, reg, len, val);
+	ret = mxt_i2c_send(client, buf, count);
 	kfree(buf);
 	return ret;
 }
@@ -631,1583 +1006,3054 @@
 			return object;
 	}
 
-	dev_warn(&data->client->dev, "Invalid object type T%u\n", type);
+	dev_err(&data->client->dev, "Invalid object type %d\n", type);
 	return NULL;
 }
 
-static void mxt_proc_t6_messages(struct mxt_data *data, u8 *msg)
+static int mxt_read_num_messages(struct mxt_data *data, u8 *count)
 {
-	struct device *dev = &data->client->dev;
-	u8 status = msg[1];
-	u32 crc = msg[2] | (msg[3] << 8) | (msg[4] << 16);
-
-	complete(&data->crc_completion);
-
-	if (crc != data->config_crc) {
-		data->config_crc = crc;
-		dev_dbg(dev, "T6 Config Checksum: 0x%06X\n", crc);
-	}
-
-	/* Detect reset */
-	if (status & MXT_T6_STATUS_RESET)
-		complete(&data->reset_completion);
-
-	/* Output debug if status has changed */
-	if (status != data->t6_status)
-		dev_dbg(dev, "T6 Status 0x%02X%s%s%s%s%s%s%s\n",
-			status,
-			status == 0 ? " OK" : "",
-			status & MXT_T6_STATUS_RESET ? " RESET" : "",
-			status & MXT_T6_STATUS_OFL ? " OFL" : "",
-			status & MXT_T6_STATUS_SIGERR ? " SIGERR" : "",
-			status & MXT_T6_STATUS_CAL ? " CAL" : "",
-			status & MXT_T6_STATUS_CFGERR ? " CFGERR" : "",
-			status & MXT_T6_STATUS_COMSERR ? " COMSERR" : "");
+	/* TODO: Optimization: read first message along with message count */
+	return __mxt_read_reg(data->client, data->T44_address, 1, count);
+}
 
-	/* Save current status */
-	data->t6_status = status;
+static int mxt_read_messages(struct mxt_data *data, u8 count, u8 *buf)
+{
+	return __mxt_read_reg(data->client, data->T5_address,
+			data->message_length * count, buf);
 }
 
-static int mxt_write_object(struct mxt_data *data,
-				 u8 type, u8 offset, u8 val)
+static int mxt_write_obj_instance(struct mxt_data *data, u8 type, u8 instance,
+		u8 offset, u8 val)
 {
 	struct mxt_object *object;
 	u16 reg;
 
 	object = mxt_get_object(data, type);
-	if (!object || offset >= mxt_obj_size(object))
+	if (!object || offset >= mxt_obj_size(object) ||
+	    instance >= mxt_obj_instances(object))
 		return -EINVAL;
 
-	reg = object->start_address;
-	return mxt_write_reg(data->client, reg + offset, val);
+	reg = object->start_address + instance * mxt_obj_size(object) + offset;
+	return mxt_write_reg(data->client, reg, val);
+}
+
+static int mxt_write_object(struct mxt_data *data, u8 type, u8 offset, u8 val)
+{
+	return mxt_write_obj_instance(data, type, 0, offset, val);
+}
+
+static int mxt_recalibrate(struct mxt_data *data)
+{
+	struct device *dev = &data->client->dev;
+	int error;
+
+	dev_dbg(dev, "Recalibration ...\n");
+	error = mxt_write_object(data, MXT_GEN_COMMAND_T6,
+				 MXT_COMMAND_CALIBRATE, 1);
+	if (error)
+		dev_err(dev, "Recalibration failed %d\n", error);
+	else
+		msleep(MXT_CAL_TIME);
+	return error;
 }
 
 static void mxt_input_button(struct mxt_data *data, u8 *message)
 {
+	struct device *dev = &data->client->dev;
 	struct input_dev *input = data->input_dev;
-	const struct mxt_platform_data *pdata = data->pdata;
+	u8 *payload = &message[1];
 	bool button;
 	int i;
 
+	dev_dbg(dev, "GPIO Event :%X\n", payload[0]);
+	if (!data->pdata) {
+		/* Active-low switch */
+		if (data->has_T100) {
+			/* mXT336T GPIO bitmask is different */
+			if (is_mxt_33x_t(data))
+				button = !(payload[0] & (MXT_GPIO3_MASK >> 2));
+			else
+				button = !(payload[0] & MXT_GPIO2_MASK);
+		} else {
+			button = !(payload[0] & MXT_GPIO3_MASK);
+		}
+		input_report_key(input, BTN_LEFT, button);
+		dev_dbg(dev, "Button state: %d\n", button);
+		return;
+	}
+
 	/* Active-low switch */
-	for (i = 0; i < pdata->t19_num_keys; i++) {
-		if (pdata->t19_keymap[i] == KEY_RESERVED)
+	for (i = 0; i < MXT_NUM_GPIO; i++) {
+		if (data->pdata->key_map[i] == KEY_RESERVED)
 			continue;
-		button = !(message[1] & (1 << i));
-		input_report_key(input, pdata->t19_keymap[i], button);
+		button = !(payload[0] & MXT_GPIO0_MASK << i);
+		input_report_key(input, data->pdata->key_map[i], button);
+		dev_dbg(dev, "Button state: %d\n", button);
 	}
 }
 
-static void mxt_input_sync(struct mxt_data *data)
+/*
+ * Assume a circle touch contact and use the diameter as the touch major.
+ * touch_pixels = touch_channels * (max_area_pixels / max_area_channels)
+ * touch_pixels = pi * (touch_major / 2) ^ 2;
+ */
+static int get_touch_major_pixels(struct mxt_data *data, int touch_channels)
+{
+	int touch_pixels;
+
+	if (data->max_area_channels == 0)
+		return 0;
+
+	touch_pixels = DIV_ROUND_CLOSEST(touch_channels * data->max_area_pixels,
+					 data->max_area_channels);
+	return int_sqrt(DIV_ROUND_CLOSEST(touch_pixels * 100, 314)) * 2;
+}
+
+static void mxt_handle_screen_status_report(struct mxt_data *data, u8 *message)
 {
-	input_mt_report_pointer_emulation(data->input_dev,
-					  data->pdata->t19_num_keys);
-	input_sync(data->input_dev);
+	struct device *dev = &data->client->dev;
+	u8 *payload = &message[1];
+	u8 status = payload[0];
+	u8 num_reportable_touches = 0;
+	int touch_area = 0;
+	int antitouch_area = 0;
+	int internal_tracking_area = 0;
+	int next_index = 1;
+
+	/* Process the values according to the internal sequence */
+	if (data->T100_enabled_num_reportable_touches) {
+		num_reportable_touches = payload[next_index];
+		next_index += 1;
+	}
+
+	if (data->T100_enabled_touch_area) {
+		touch_area = payload[next_index + 1] << 8 |
+				payload[next_index];
+		next_index += 2;
+	}
+
+	if (data->T100_enabled_antitouch_area) {
+		antitouch_area = payload[next_index + 1] << 8 |
+					payload[next_index];
+		next_index += 2;
+	}
+
+	if (data->T100_enabled_internal_tracking_area) {
+		internal_tracking_area = payload[next_index + 1] << 8 |
+						payload[next_index];
+		next_index += 2;
+	}
+
+	dev_dbg(dev,
+		"Screen Status Report : status = %X, N=%X, T=%d, A=%d, I=%d\n",
+		status, num_reportable_touches, touch_area, antitouch_area,
+		internal_tracking_area);
 }
 
-static void mxt_proc_t9_message(struct mxt_data *data, u8 *message)
+
+static void mxt_input_touchevent(struct mxt_data *data, u8 *message, int id)
 {
 	struct device *dev = &data->client->dev;
+	u8 *payload = &message[1];
+	u8 status = payload[0];
 	struct input_dev *input_dev = data->input_dev;
-	int id;
-	u8 status;
 	int x;
 	int y;
 	int area;
-	int amplitude;
+	int pressure;
+	int touch_major;
+	int vector1, vector2;
 
-	id = message[0] - data->T9_reportid_min;
-	status = message[1];
-	x = (message[2] << 4) | ((message[4] >> 4) & 0xf);
-	y = (message[3] << 4) | ((message[4] & 0xf));
-
-	/* Handle 10/12 bit switching */
+	x = (payload[1] << 4) | ((payload[3] >> 4) & 0xf);
+	y = (payload[2] << 4) | ((payload[3] & 0xf));
 	if (data->max_x < 1024)
-		x >>= 2;
+		x = x >> 2;
 	if (data->max_y < 1024)
-		y >>= 2;
+		y = y >> 2;
 
-	area = message[5];
-	amplitude = message[6];
+	area = payload[4];
+	touch_major = get_touch_major_pixels(data, area);
+	pressure = payload[5];
+
+	/* The two vector components are 4-bit signed ints (2s complement) */
+	vector1 = (signed)((signed char)payload[6]) >> 4;
+	vector2 = (signed)((signed char)(payload[6] << 4)) >> 4;
 
 	dev_dbg(dev,
-		"[%u] %c%c%c%c%c%c%c%c x: %5u y: %5u area: %3u amp: %3u\n",
+		"[%u] %c%c%c%c%c%c%c%c x: %5u y: %5u area: %3u amp: %3u vector: [%d,%d]\n",
 		id,
-		(status & MXT_T9_DETECT) ? 'D' : '.',
-		(status & MXT_T9_PRESS) ? 'P' : '.',
-		(status & MXT_T9_RELEASE) ? 'R' : '.',
-		(status & MXT_T9_MOVE) ? 'M' : '.',
-		(status & MXT_T9_VECTOR) ? 'V' : '.',
-		(status & MXT_T9_AMP) ? 'A' : '.',
-		(status & MXT_T9_SUPPRESS) ? 'S' : '.',
-		(status & MXT_T9_UNGRIP) ? 'U' : '.',
-		x, y, area, amplitude);
+		(status & MXT_DETECT) ? 'D' : '.',
+		(status & MXT_PRESS) ? 'P' : '.',
+		(status & MXT_RELEASE) ? 'R' : '.',
+		(status & MXT_MOVE) ? 'M' : '.',
+		(status & MXT_VECTOR) ? 'V' : '.',
+		(status & MXT_AMP) ? 'A' : '.',
+		(status & MXT_SUPPRESS) ? 'S' : '.',
+		(status & MXT_UNGRIP) ? 'U' : '.',
+		x, y, area, pressure, vector1, vector2);
 
 	input_mt_slot(input_dev, id);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER,
+				   status & MXT_DETECT);
+	data->current_id[id] = status & MXT_DETECT;
 
-	if (status & MXT_T9_DETECT) {
-		/*
-		 * Multiple bits may be set if the host is slow to read
-		 * the status messages, indicating all the events that
-		 * have happened.
-		 */
-		if (status & MXT_T9_RELEASE) {
-			input_mt_report_slot_state(input_dev,
-						   MT_TOOL_FINGER, 0);
-			mxt_input_sync(data);
-		}
-
-		/* Touch active */
-		input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, 1);
+	if (status & MXT_DETECT) {
 		input_report_abs(input_dev, ABS_MT_POSITION_X, x);
 		input_report_abs(input_dev, ABS_MT_POSITION_Y, y);
-		input_report_abs(input_dev, ABS_MT_PRESSURE, amplitude);
-		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, area);
-	} else {
-		/* Touch no longer active, close out slot */
-		input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, 0);
+		input_report_abs(input_dev, ABS_MT_PRESSURE, pressure);
+		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, touch_major);
+		/* TODO: Use vector to report ORIENTATION & TOUCH_MINOR */
 	}
-
-	data->update_input = true;
 }
 
-static int mxt_proc_message(struct mxt_data *data, u8 *message)
+static void mxt_input_touchevent_T100(struct mxt_data *data, u8 *message)
 {
-	u8 report_id = message[0];
-
-	if (report_id == MXT_RPTID_NOMSG)
-		return 0;
+	struct device *dev = &data->client->dev;
+	struct input_dev *input_dev = data->input_dev;
+	u8 reportid = message[0];
+	u8 *payload = &message[1];
+	u8 status = payload[0];
+	u8 event = status & 0x0F;
+	int id;
+	int x, y;
+	int area = 0;
+	int pressure = 0;
+	int touch_major = 0;
+	int touch_peak = 0;
+	int next_index = 1;
+	int vector1 = 0, vector2 = 0;
+	int touch_type;
+	int distance;
+
+	id = reportid - data->T100_reportid_min - 2;
+
+	x = (payload[next_index+1] << 8) | payload[next_index];
+	next_index += 2;
+	y = (payload[next_index+1] << 8) | payload[next_index];
+	next_index += 2;
+
+	/* Keep the process sequence */
+	if (data->T100_enabled_vector) {
+		/* The two vector components are 4-bit signed ints */
+		u8 values = payload[next_index];
+		vector1 = (signed)((signed char)values) >> 4;
+		vector2 = (signed)((signed char)(values << 4)) >> 4;
+		next_index += 1;
+	}
+
+	if (data->T100_enabled_amplitude) {
+		pressure = payload[next_index];
+		next_index += 1;
+	}
+
+	if (data->T100_enabled_area) {
+		area = payload[next_index];
+		touch_major = get_touch_major_pixels(data, area);
+		next_index += 1;
+	}
+
+	if (data->T100_enabled_peak) {
+		touch_peak = payload[next_index];
+		next_index += 1;
+	}
 
-	if (report_id == data->T6_reportid) {
-		mxt_proc_t6_messages(data, message);
-	} else if (!data->input_dev) {
-		/*
-		 * Do not report events if input device
-		 * is not yet registered.
-		 */
-		mxt_dump_message(data, message);
-	} else if (report_id >= data->T9_reportid_min
-	    && report_id <= data->T9_reportid_max) {
-		mxt_proc_t9_message(data, message);
-	} else if (report_id == data->T19_reportid) {
-		mxt_input_button(data, message);
-		data->update_input = true;
+	/*
+	 * Currently there is no distance information for hovering,
+	 * however, this can be used as hovering indication in user space.
+	 */
+	touch_type = ((payload[0] & 0x70) >> 4);
+	if (touch_type == TOUCH_STATUS_TYPE_HOVERING) {
+		distance = DISTANCE_HOVERING;
+		pressure = 0;
 	} else {
-		mxt_dump_message(data, message);
+		distance = DISTANCE_ACTIVE_TOUCH;
+		if (pressure == 0 && is_hovering_supported(data))
+			pressure = 1;
 	}
 
-	return 1;
-}
-
-static int mxt_read_and_process_messages(struct mxt_data *data, u8 count)
-{
-	struct device *dev = &data->client->dev;
-	int ret;
-	int i;
-	u8 num_valid = 0;
-
-	/* Safety check for msg_buf */
-	if (count > data->max_reportid)
-		return -EINVAL;
-
-	/* Process remaining messages if necessary */
-	ret = __mxt_read_reg(data->client, data->T5_address,
-				data->T5_msg_size * count, data->msg_buf);
-	if (ret) {
-		dev_err(dev, "Failed to read %u messages (%d)\n", count, ret);
-		return ret;
+	dev_dbg(dev,
+		"[%u] T%d%c%c%c%c%c%c%c%c%c%c x: %5u y: %5u a: %5u p: %5u m: %d v: [%d,%d]\n",
+		id,
+		touch_type,
+		(status & TOUCH_STATUS_DETECT) ? 'D' : '.',
+		(status & TOUCH_STATUS_EVENT_MOVE) ? 'M' : '.',
+		(status & TOUCH_STATUS_EVENT_UNSUP) ? 'U' : '.',
+		(status & TOUCH_STATUS_EVENT_SUP) ? 'S' : '.',
+		(status & TOUCH_STATUS_EVENT_DOWN) ? 'D' : '.',
+		(status & TOUCH_STATUS_EVENT_UP) ? 'U' : '.',
+		(status & TOUCH_STATUS_EVENT_UNSUPSUP) ? 'U' : '.',
+		(status & TOUCH_STATUS_EVENT_UNSUPUP) ? 'U' : '.',
+		(status & TOUCH_STATUS_EVENT_DOWNSUP) ? 'D' : '.',
+		(status & TOUCH_STATUS_EVENT_DOWNUP) ? 'D' : '.',
+		x, y, area, pressure, touch_major, vector1, vector2);
+
+
+	data->current_id[id] = status & TOUCH_STATUS_DETECT;
+	if (touch_type != TOUCH_STATUS_TYPE_STYLUS) {
+		if (status & TOUCH_STATUS_DETECT) {
+			if (event & TOUCH_STATUS_EVENT_MOVE ||
+					event & TOUCH_STATUS_EVENT_DOWN ||
+					event & TOUCH_STATUS_EVENT_UNSUP ||
+					event == 0x00) {
+				input_mt_slot(input_dev, id);
+				input_mt_report_slot_state(
+					input_dev, MT_TOOL_FINGER, true);
+				input_report_abs(input_dev,
+						 ABS_MT_POSITION_X, x);
+				input_report_abs(input_dev,
+						 ABS_MT_POSITION_Y, y);
+				input_report_abs(input_dev,
+						 ABS_MT_PRESSURE, pressure);
+				input_report_abs(input_dev,
+						 ABS_MT_DISTANCE, distance);
+				input_report_abs(input_dev,
+						 ABS_MT_TOUCH_MAJOR,
+						 touch_major);
+			}
+		} else {
+			if (event & TOUCH_STATUS_EVENT_UP ||
+					event & TOUCH_STATUS_EVENT_SUP) {
+				input_mt_slot(input_dev, id);
+				input_mt_report_slot_state(input_dev,
+							   MT_TOOL_FINGER,
+							   false);
+			}
+		}
+	} else {
+		input_mt_slot(input_dev, id);
+		input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, false);
 	}
+}
 
-	for (i = 0;  i < count; i++) {
-		ret = mxt_proc_message(data,
-			data->msg_buf + data->T5_msg_size * i);
+static unsigned mxt_extract_T6_csum(const u8 *csum)
+{
+	return csum[0] | (csum[1] << 8) | (csum[2] << 16);
+}
 
-		if (ret == 1)
-			num_valid++;
-	}
+static bool mxt_is_T9_message(struct mxt_data *data, u8 reportid)
+{
+	return (reportid >= data->T9_reportid_min &&
+			reportid <= data->T9_reportid_max);
+}
 
-	/* return number of messages read */
-	return num_valid;
+static bool mxt_is_T100_message(struct mxt_data *data, u8 reportid)
+{
+	return (reportid >= data->T100_reportid_min &&
+			reportid <= data->T100_reportid_max);
 }
 
-static irqreturn_t mxt_process_messages_t44(struct mxt_data *data)
+static int mxt_proc_messages(struct mxt_data *data, u8 count, bool report)
 {
 	struct device *dev = &data->client->dev;
+	bool update_input = false;
+	u8 *message_buffer;
 	int ret;
-	u8 count, num_left;
+	u8 i;
+
+	message_buffer = kcalloc(count, data->message_length, GFP_KERNEL);
+	if (!message_buffer)
+		return -ENOMEM;
 
-	/* Read T44 and T5 together */
-	ret = __mxt_read_reg(data->client, data->T44_address,
-		data->T5_msg_size + 1, data->msg_buf);
+	ret = mxt_read_messages(data, count, message_buffer);
 	if (ret) {
-		dev_err(dev, "Failed to read T44 and T5 (%d)\n", ret);
-		return IRQ_NONE;
+		dev_err(dev, "Failed to read %u messages (%d).\n", count, ret);
+		goto out;
 	}
+	if (!report)
+		goto out;
 
-	count = data->msg_buf[0];
+	/* There could be a race condition for entering BL mode,
+	 * it is a sanity check.
+	 */
+	if (!data->input_dev)
+		return 0;
 
-	if (count == 0) {
-		/*
-		 * This condition is caused by the CHG line being configured
-		 * in Mode 0. It results in unnecessary I2C operations but it
-		 * is benign.
-		 */
-		dev_dbg(dev, "Interrupt triggered but zero messages\n");
-		return IRQ_NONE;
-	} else if (count > data->max_reportid) {
-		dev_err(dev, "T44 count %d exceeded max report id\n", count);
-		count = data->max_reportid;
+	for (i = 0; i < count; i++) {
+		u8 *msg = &message_buffer[i * data->message_length];
+		u8 reportid = msg[0];
+		mxt_dump_message(dev, msg);
+
+		if (reportid == data->T6_reportid) {
+			const u8 *payload = &msg[1];
+			u8 status = payload[0];
+			data->config_csum = mxt_extract_T6_csum(&payload[1]);
+			dev_info(dev, "Status: %02x Config Checksum: %06x\n",
+				 status, data->config_csum);
+			if (status == 0x00)
+				complete(&data->auto_cal_completion);
+		} else if (mxt_is_T9_message(data, reportid)) {
+			int id = reportid - data->T9_reportid_min;
+			mxt_input_touchevent(data, msg, id);
+			update_input = true;
+		} else if (reportid == data->T19_reportid) {
+			mxt_input_button(data, msg);
+			update_input = true;
+		} else if (mxt_is_T100_message(data, reportid)) {
+			/* check SCRSTATUS */
+			if (reportid == data->T100_reportid_min) {
+				/* Screen Status Report */
+				mxt_handle_screen_status_report(data, msg);
+			} else if (reportid == (data->T100_reportid_min + 1)) {
+				/* skip reserved report id */
+				continue;
+			} else {
+				mxt_input_touchevent_T100(data, msg);
+				update_input = true;
+			}
+		}
 	}
 
-	/* Process first message */
-	ret = mxt_proc_message(data, data->msg_buf + 1);
-	if (ret < 0) {
-		dev_warn(dev, "Unexpected invalid message\n");
-		return IRQ_NONE;
+	if (update_input) {
+		input_mt_report_pointer_emulation(data->input_dev,
+						  data->is_tp);
+		input_sync(data->input_dev);
 	}
 
-	num_left = count - 1;
+out:
+	kfree(message_buffer);
+	return ret;
+}
 
-	/* Process remaining messages if necessary */
-	if (num_left) {
-		ret = mxt_read_and_process_messages(data, num_left);
-		if (ret < 0)
-			goto end;
-		else if (ret != num_left)
-			dev_warn(dev, "Unexpected invalid message\n");
-	}
+static int mxt_handle_messages(struct mxt_data *data, bool report)
+{
+	struct device *dev = &data->client->dev;
+	int ret;
+	u8 count;
 
-end:
-	if (data->update_input) {
-		mxt_input_sync(data);
-		data->update_input = false;
+	ret = mxt_read_num_messages(data, &count);
+	if (ret) {
+		dev_err(dev, "Failed to read message count (%d).\n", ret);
+		return ret;
 	}
 
-	return IRQ_HANDLED;
+	if (count > 0)
+		ret = mxt_proc_messages(data, count, report);
+
+	return ret;
 }
 
-static int mxt_process_messages_until_invalid(struct mxt_data *data)
+static int mxt_enter_bl(struct mxt_data *data)
 {
-	struct device *dev = &data->client->dev;
-	int count, read;
-	u8 tries = 2;
+	struct i2c_client *client = data->client;
+	struct device *dev = &client->dev;
+	int ret;
 
-	count = data->max_reportid;
+	disable_irq(data->irq);
 
-	/* Read messages until we force an invalid */
-	do {
-		read = mxt_read_and_process_messages(data, count);
-		if (read < count)
-			return 0;
-	} while (--tries);
+	if (data->input_dev) {
+		input_unregister_device(data->input_dev);
+		data->input_dev = NULL;
+	}
+
+	/* Change to the bootloader mode */
+	ret = mxt_write_object(data, MXT_GEN_COMMAND_T6,
+			       MXT_COMMAND_RESET, MXT_BOOT_VALUE);
+	if (ret) {
+		dev_err(dev, "Failed to change to bootloader mode %d.\n", ret);
+		enable_irq(data->irq);
+		goto err_enter_bl;
+	}
+
+	/* Wait for bootloader mode ready */
+	msleep(MXT_RESET_TIME);
+
+	/* Change to slave address of bootloader */
+	client->addr = mxt_lookup_bootloader_address(data);
 
-	if (data->update_input) {
-		mxt_input_sync(data);
-		data->update_input = false;
+	ret = mxt_check_device_present(data, false);
+	if (ret) {
+		dev_err(dev, "Failed to check device in BL mode %d.\n", ret);
+		goto err_enter_bl;
+	}
+
+	init_completion(&data->bl_completion);
+	enable_irq(data->irq);
+
+	/* Wait for CHG assert to indicate successful reset into bootloader */
+	ret = mxt_wait_for_chg(data, MXT_RESET_TIME);
+	if (ret) {
+		dev_err(dev, "Failed waiting for reset to bootloader %d.\n",
+			ret);
+		goto err_enter_bl;
 	}
+	return 0;
 
-	dev_err(dev, "CHG pin isn't cleared\n");
-	return -EBUSY;
+err_enter_bl:
+	client->addr = mxt_lookup_appmode_address(data);
+	return ret;
 }
 
-static irqreturn_t mxt_process_messages(struct mxt_data *data)
+static void mxt_exit_bl(struct mxt_data *data)
 {
-	int total_handled, num_handled;
-	u8 count = data->last_message_count;
-
-	if (count < 1 || count > data->max_reportid)
-		count = 1;
+	struct i2c_client *client = data->client;
+	struct device *dev = &client->dev;
+	int error;
 
-	/* include final invalid message */
-	total_handled = mxt_read_and_process_messages(data, count + 1);
-	if (total_handled < 0)
-		return IRQ_NONE;
-	/* if there were invalid messages, then we are done */
-	else if (total_handled <= count)
-		goto update_count;
+	init_completion(&data->bl_completion);
 
-	/* keep reading two msgs until one is invalid or reportid limit */
-	do {
-		num_handled = mxt_read_and_process_messages(data, 2);
-		if (num_handled < 0)
-			return IRQ_NONE;
+	/* Wait for reset */
+	mxt_wait_for_chg(data, MXT_FWRESET_TIME);
 
-		total_handled += num_handled;
+	disable_irq(data->irq);
+	client->addr = mxt_lookup_appmode_address(data);
 
-		if (num_handled < 2)
-			break;
-	} while (total_handled < data->num_touchids);
+	mxt_free_object_table(data);
 
-update_count:
-	data->last_message_count = total_handled;
+	error = mxt_initialize(data);
+	if (error) {
+		dev_err(dev, "Failed to initialize on exit bl. error = %d\n",
+			error);
+		return;
+	}
 
-	if (data->update_input) {
-		mxt_input_sync(data);
-		data->update_input = false;
+	error = mxt_input_dev_create(data);
+	if (error) {
+		dev_err(dev, "Create input dev failed after init. error = %d\n",
+			error);
+		return;
 	}
 
-	return IRQ_HANDLED;
+	error = mxt_handle_messages(data, false);
+	if (error)
+		dev_err(dev, "Failed to clear CHG after init. error = %d\n",
+			error);
+	enable_irq(data->irq);
 }
 
 static irqreturn_t mxt_interrupt(int irq, void *dev_id)
 {
 	struct mxt_data *data = dev_id;
+	struct device *dev = &data->client->dev;
+	char *envp[] = {"ERROR=1", NULL};
+	int ret;
 
-	if (data->in_bootloader) {
+	if (mxt_in_bootloader(data)) {
 		/* bootloader state transition completion */
 		complete(&data->bl_completion);
-		return IRQ_HANDLED;
-	}
-
-	if (!data->object_table)
-		return IRQ_HANDLED;
-
-	if (data->T44_address) {
-		return mxt_process_messages_t44(data);
 	} else {
-		return mxt_process_messages(data);
+		ret = mxt_handle_messages(data, true);
+		if (ret) {
+			dev_err(dev, "Handling message fails in IRQ, %d.\n",
+				ret);
+			kobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);
+		}
 	}
+	return IRQ_HANDLED;
 }
 
-static int mxt_t6_command(struct mxt_data *data, u16 cmd_offset,
-			  u8 value, bool wait)
+static int mxt_apply_pdata_config(struct mxt_data *data)
 {
-	u16 reg;
-	u8 command_register;
-	int timeout_counter = 0;
+	const struct mxt_platform_data *pdata = data->pdata;
+	struct mxt_object *object;
+	struct device *dev = &data->client->dev;
+	int index = 0;
+	int i, size;
 	int ret;
 
-	reg = data->T6_address + cmd_offset;
+	if (!pdata->config) {
+		dev_info(dev, "No cfg data defined, skipping reg init\n");
+		return 0;
+	}
+
+	for (i = 0; i < data->info.object_num; i++) {
+		object = data->object_table + i;
 
-	ret = mxt_write_reg(data->client, reg, value);
-	if (ret)
-		return ret;
+		if (!mxt_object_writable(object->type))
+			continue;
 
-	if (!wait)
-		return 0;
+		size = mxt_obj_size(object) * mxt_obj_instances(object);
+		if (index + size > pdata->config_length) {
+			dev_err(dev, "Not enough config data!\n");
+			return -EINVAL;
+		}
 
-	do {
-		msleep(20);
-		ret = __mxt_read_reg(data->client, reg, 1, &command_register);
+		ret = __mxt_write_reg(data->client, object->start_address,
+				size, &pdata->config[index]);
 		if (ret)
 			return ret;
-	} while (command_register != 0 && timeout_counter++ <= 100);
-
-	if (timeout_counter > 100) {
-		dev_err(&data->client->dev, "Command failed!\n");
-		return -EIO;
+		index += size;
 	}
 
 	return 0;
 }
 
-static int mxt_soft_reset(struct mxt_data *data)
+static int mxt_handle_pdata(struct mxt_data *data)
 {
+	const struct mxt_platform_data *pdata = data->pdata;
 	struct device *dev = &data->client->dev;
-	int ret = 0;
-
-	dev_info(dev, "Resetting chip\n");
+	u8 voltage;
+	int ret;
 
-	reinit_completion(&data->reset_completion);
+	if (!pdata) {
+		dev_info(dev, "No platform data provided\n");
+		return 0;
+	}
 
-	ret = mxt_t6_command(data, MXT_COMMAND_RESET, MXT_RESET_VALUE, false);
+	ret = mxt_apply_pdata_config(data);
 	if (ret)
 		return ret;
 
-	ret = mxt_wait_for_completion(data, &data->reset_completion,
-				      MXT_RESET_TIMEOUT);
+	/* Set touchscreen lines */
+	mxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_XSIZE,
+			pdata->x_line);
+	mxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_YSIZE,
+			pdata->y_line);
+
+	/* Set touchscreen orient */
+	mxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_ORIENT,
+			pdata->orient);
+
+	/* Set touchscreen burst length */
+	mxt_write_object(data, MXT_TOUCH_MULTI_T9,
+			MXT_TOUCH_BLEN, pdata->blen);
+
+	/* Set touchscreen threshold */
+	mxt_write_object(data, MXT_TOUCH_MULTI_T9,
+			MXT_TOUCH_TCHTHR, pdata->threshold);
+
+	/* Set touchscreen resolution */
+	mxt_write_object(data, MXT_TOUCH_MULTI_T9,
+			MXT_TOUCH_XRANGE_LSB, (pdata->x_size - 1) & 0xff);
+	mxt_write_object(data, MXT_TOUCH_MULTI_T9,
+			MXT_TOUCH_XRANGE_MSB, (pdata->x_size - 1) >> 8);
+	mxt_write_object(data, MXT_TOUCH_MULTI_T9,
+			MXT_TOUCH_YRANGE_LSB, (pdata->y_size - 1) & 0xff);
+	mxt_write_object(data, MXT_TOUCH_MULTI_T9,
+			MXT_TOUCH_YRANGE_MSB, (pdata->y_size - 1) >> 8);
+
+	/* Set touchscreen voltage */
+	if (pdata->voltage) {
+		if (pdata->voltage < MXT_VOLTAGE_DEFAULT) {
+			voltage = (MXT_VOLTAGE_DEFAULT - pdata->voltage) /
+				MXT_VOLTAGE_STEP;
+			voltage = 0xff - voltage + 1;
+		} else
+			voltage = (pdata->voltage - MXT_VOLTAGE_DEFAULT) /
+				MXT_VOLTAGE_STEP;
+
+		mxt_write_object(data, MXT_SPT_CTECONFIG_T28,
+				MXT_CTE_VOLTAGE, voltage);
+	}
+
+	/* Backup to memory */
+	ret = mxt_write_object(data, MXT_GEN_COMMAND_T6,
+			       MXT_COMMAND_BACKUPNV, MXT_BACKUP_VALUE);
 	if (ret)
 		return ret;
+	msleep(MXT_BACKUP_TIME);
 
 	return 0;
 }
 
-static void mxt_update_crc(struct mxt_data *data, u8 cmd, u8 value)
+/* Update 24-bit CRC with two new bytes of data */
+static u32 crc24_step(u32 crc, u8 byte1, u8 byte2)
 {
-	/*
-	 * On failure, CRC is set to 0 and config will always be
-	 * downloaded.
-	 */
-	data->config_crc = 0;
-	reinit_completion(&data->crc_completion);
+	const u32 crcpoly = 0x80001b;
+	u16 data = byte1 | (byte2 << 8);
+	u32 result = data ^ (crc << 1);
 
-	mxt_t6_command(data, cmd, value, true);
+	/* XOR result with crcpoly if bit 25 is set (overflow occurred) */
+	if (result & 0x01000000)
+		result ^= crcpoly;
 
-	/*
-	 * Wait for crc message. On failure, CRC is set to 0 and config will
-	 * always be downloaded.
-	 */
-	mxt_wait_for_completion(data, &data->crc_completion, MXT_CRC_TIMEOUT);
+	return result & 0x00ffffff;
 }
 
-static void mxt_calc_crc24(u32 *crc, u8 firstbyte, u8 secondbyte)
+static u32 crc24(u32 crc, const u8 *data, size_t len)
 {
-	static const unsigned int crcpoly = 0x80001B;
-	u32 result;
-	u32 data_word;
+	size_t i;
 
-	data_word = (secondbyte << 8) | firstbyte;
-	result = ((*crc << 1) ^ data_word);
+	for (i = 0; i < len - 1; i += 2)
+		crc = crc24_step(crc, data[i], data[i + 1]);
 
-	if (result & 0x1000000)
-		result ^= crcpoly;
+	/* If there were an odd number of bytes pad with 0 */
+	if (i < len)
+		crc = crc24_step(crc, data[i], 0);
 
-	*crc = result;
+	return crc;
 }
 
-static u32 mxt_calculate_crc(u8 *base, off_t start_off, off_t end_off)
+static int mxt_verify_info_block_csum(struct mxt_data *data)
 {
+	struct i2c_client *client = data->client;
+	struct device *dev = &client->dev;
+	size_t object_table_size, info_block_size;
 	u32 crc = 0;
-	u8 *ptr = base + start_off;
-	u8 *last_val = base + end_off - 1;
+	u8 *info_block;
+	int ret = 0;
 
-	if (end_off < start_off)
-		return -EINVAL;
+	object_table_size = data->info.object_num * MXT_OBJECT_SIZE;
+	info_block_size = sizeof(data->info) + object_table_size;
+	info_block = kmalloc(info_block_size, GFP_KERNEL);
+	if (!info_block)
+		return -ENOMEM;
 
-	while (ptr < last_val) {
-		mxt_calc_crc24(&crc, *ptr, *(ptr + 1));
-		ptr += 2;
-	}
+	/*
+	 * Information Block CRC is computed over both ID info and Object Table
+	 * So concat them in a temporary buffer, before computing CRC.
+	 * TODO: refactor how the info block is read from the device such
+	 * that it ends up in a single buffer and this copy is not needed.
+	 */
+	memcpy(info_block, &data->info, sizeof(data->info));
+	memcpy(&info_block[sizeof(data->info)], data->object_table,
+			object_table_size);
 
-	/* if len is odd, fill the last byte with 0 */
-	if (ptr == last_val)
-		mxt_calc_crc24(&crc, *ptr, 0);
+	crc = crc24(crc, info_block, info_block_size);
 
-	/* Mask to 24-bit */
-	crc &= 0x00FFFFFF;
+	if (crc != data->info_csum) {
+		dev_err(dev, "Information Block CRC mismatch: %06x != %06x\n",
+			data->info_csum, crc);
+		ret = -EINVAL;
+	}
 
-	return crc;
+	kfree(info_block);
+	return ret;
 }
 
-static int mxt_prepare_cfg_mem(struct mxt_data *data,
-			       const struct firmware *cfg,
-			       unsigned int data_pos,
-			       unsigned int cfg_start_ofs,
-			       u8 *config_mem,
-			       size_t config_mem_size)
+static int mxt_get_info(struct mxt_data *data)
 {
-	struct device *dev = &data->client->dev;
-	struct mxt_object *object;
-	unsigned int type, instance, size, byte_offset;
-	int offset;
-	int ret;
-	int i;
-	u16 reg;
-	u8 val;
-
-	while (data_pos < cfg->size) {
-		/* Read type, instance, length */
-		ret = sscanf(cfg->data + data_pos, "%x %x %x%n",
-			     &type, &instance, &size, &offset);
-		if (ret == 0) {
-			/* EOF */
-			break;
-		} else if (ret != 3) {
-			dev_err(dev, "Bad format: failed to parse object\n");
-			return -EINVAL;
-		}
-		data_pos += offset;
-
-		object = mxt_get_object(data, type);
-		if (!object) {
-			/* Skip object */
-			for (i = 0; i < size; i++) {
-				ret = sscanf(cfg->data + data_pos, "%hhx%n",
-					     &val, &offset);
-				if (ret != 1) {
-					dev_err(dev, "Bad format in T%d at %d\n",
-						type, i);
-					return -EINVAL;
-				}
-				data_pos += offset;
-			}
-			continue;
-		}
-
-		if (size > mxt_obj_size(object)) {
-			/*
-			 * Either we are in fallback mode due to wrong
-			 * config or config from a later fw version,
-			 * or the file is corrupt or hand-edited.
-			 */
-			dev_warn(dev, "Discarding %zu byte(s) in T%u\n",
-				 size - mxt_obj_size(object), type);
-		} else if (mxt_obj_size(object) > size) {
-			/*
-			 * If firmware is upgraded, new bytes may be added to
-			 * end of objects. It is generally forward compatible
-			 * to zero these bytes - previous behaviour will be
-			 * retained. However this does invalidate the CRC and
-			 * will force fallback mode until the configuration is
-			 * updated. We warn here but do nothing else - the
-			 * malloc has zeroed the entire configuration.
-			 */
-			dev_warn(dev, "Zeroing %zu byte(s) in T%d\n",
-				 mxt_obj_size(object) - size, type);
-		}
-
-		if (instance >= mxt_obj_instances(object)) {
-			dev_err(dev, "Object instances exceeded!\n");
-			return -EINVAL;
-		}
-
-		reg = object->start_address + mxt_obj_size(object) * instance;
-
-		for (i = 0; i < size; i++) {
-			ret = sscanf(cfg->data + data_pos, "%hhx%n",
-				     &val,
-				     &offset);
-			if (ret != 1) {
-				dev_err(dev, "Bad format in T%d at %d\n",
-					type, i);
-				return -EINVAL;
-			}
-			data_pos += offset;
-
-			if (i > mxt_obj_size(object))
-				continue;
-
-			byte_offset = reg + i - cfg_start_ofs;
+	struct i2c_client *client = data->client;
+	struct mxt_info *info = &data->info;
+	int error;
 
-			if (byte_offset >= 0 && byte_offset < config_mem_size) {
-				*(config_mem + byte_offset) = val;
-			} else {
-				dev_err(dev, "Bad object: reg:%d, T%d, ofs=%d\n",
-					reg, object->type, byte_offset);
-				return -EINVAL;
-			}
-		}
-	}
+	/* Read 7-byte info block starting at address 0 */
+	error = __mxt_read_reg(client, MXT_INFO, sizeof(*info), info);
+	if (error)
+		return error;
 
 	return 0;
 }
 
-static int mxt_upload_cfg_mem(struct mxt_data *data, unsigned int cfg_start,
-			      u8 *config_mem, size_t config_mem_size)
+static void mxt_free_object_table(struct mxt_data *data)
 {
-	unsigned int byte_offset = 0;
-	int error;
-
-	/* Write configuration as blocks */
-	while (byte_offset < config_mem_size) {
-		unsigned int size = config_mem_size - byte_offset;
-
-		if (size > MXT_MAX_BLOCK_WRITE)
-			size = MXT_MAX_BLOCK_WRITE;
-
-		error = __mxt_write_reg(data->client,
-					cfg_start + byte_offset,
-					size, config_mem + byte_offset);
-		if (error) {
-			dev_err(&data->client->dev,
-				"Config write error, ret=%d\n", error);
-			return error;
-		}
+	if (data->object_table) {
+		devm_kfree(&data->client->dev, data->object_table);
+		data->object_table = NULL;
+	}
 
-		byte_offset += size;
+	if (data->current_id) {
+		devm_kfree(&data->client->dev, data->current_id);
+		data->current_id = NULL;
 	}
 
-	return 0;
+	data->object_table = NULL;
+	data->T6_reportid = 0;
+	data->T9_reportid_min = 0;
+	data->T9_reportid_max = 0;
+	data->T19_reportid = 0;
+	data->T100_reportid_min = 0;
+	data->T100_reportid_max = 0;
+	data->num_touchids = 0;
 }
 
-/*
- * mxt_update_cfg - download configuration to chip
- *
- * Atmel Raw Config File Format
- *
- * The first four lines of the raw config file contain:
- *  1) Version
- *  2) Chip ID Information (first 7 bytes of device memory)
- *  3) Chip Information Block 24-bit CRC Checksum
- *  4) Chip Configuration 24-bit CRC Checksum
- *
- * The rest of the file consists of one line per object instance:
- *   <TYPE> <INSTANCE> <SIZE> <CONTENTS>
- *
- *   <TYPE> - 2-byte object type as hex
- *   <INSTANCE> - 2-byte object instance number as hex
- *   <SIZE> - 2-byte object size as hex
- *   <CONTENTS> - array of <SIZE> 1-byte hex values
- */
-static int mxt_update_cfg(struct mxt_data *data, const struct firmware *cfg)
+static int mxt_get_object_table(struct mxt_data *data)
 {
+	struct i2c_client *client = data->client;
 	struct device *dev = &data->client->dev;
-	struct mxt_info cfg_info;
-	int ret;
-	int offset;
-	int data_pos;
+	size_t table_size;
+	int error;
 	int i;
-	int cfg_start_ofs;
-	u32 info_crc, config_crc, calculated_crc;
-	u8 *config_mem;
-	size_t config_mem_size;
-
-	mxt_update_crc(data, MXT_COMMAND_REPORTALL, 1);
-
-	if (strncmp(cfg->data, MXT_CFG_MAGIC, strlen(MXT_CFG_MAGIC))) {
-		dev_err(dev, "Unrecognised config file\n");
-		return -EINVAL;
-	}
-
-	data_pos = strlen(MXT_CFG_MAGIC);
-
-	/* Load information block and check */
-	for (i = 0; i < sizeof(struct mxt_info); i++) {
-		ret = sscanf(cfg->data + data_pos, "%hhx%n",
-			     (unsigned char *)&cfg_info + i,
-			     &offset);
-		if (ret != 1) {
-			dev_err(dev, "Bad format\n");
-			return -EINVAL;
-		}
-
-		data_pos += offset;
-	}
+	u8 reportid;
+	u8 csum[3];
 
-	if (cfg_info.family_id != data->info.family_id) {
-		dev_err(dev, "Family ID mismatch!\n");
-		return -EINVAL;
-	}
+	/* Start by zapping old contents, if any. */
+	mxt_free_object_table(data);
 
-	if (cfg_info.variant_id != data->info.variant_id) {
-		dev_err(dev, "Variant ID mismatch!\n");
-		return -EINVAL;
-	}
+	table_size = data->info.object_num * sizeof(struct mxt_object);
 
-	/* Read CRCs */
-	ret = sscanf(cfg->data + data_pos, "%x%n", &info_crc, &offset);
-	if (ret != 1) {
-		dev_err(dev, "Bad format: failed to parse Info CRC\n");
-		return -EINVAL;
+	data->object_table = devm_kzalloc(dev, table_size, GFP_KERNEL);
+	if (!data->object_table) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		return -ENOMEM;
 	}
-	data_pos += offset;
 
-	ret = sscanf(cfg->data + data_pos, "%x%n", &config_crc, &offset);
-	if (ret != 1) {
-		dev_err(dev, "Bad format: failed to parse Config CRC\n");
-		return -EINVAL;
-	}
-	data_pos += offset;
+	error = __mxt_read_reg(client, MXT_OBJECT_START, table_size,
+			data->object_table);
+	if (error)
+		return error;
 
 	/*
-	 * The Info Block CRC is calculated over mxt_info and the object
-	 * table. If it does not match then we are trying to load the
-	 * configuration from a different chip or firmware version, so
-	 * the configuration CRC is invalid anyway.
+	 * Read Information Block checksum from 3 bytes immediately following
+	 * info block
 	 */
-	if (info_crc == data->info_crc) {
-		if (config_crc == 0 || data->config_crc == 0) {
-			dev_info(dev, "CRC zero, attempting to apply config\n");
-		} else if (config_crc == data->config_crc) {
-			dev_dbg(dev, "Config CRC 0x%06X: OK\n",
-				 data->config_crc);
-			return 0;
-		} else {
-			dev_info(dev, "Config CRC 0x%06X: does not match file 0x%06X\n",
-				 data->config_crc, config_crc);
-		}
-	} else {
-		dev_warn(dev,
-			 "Warning: Info CRC error - device=0x%06X file=0x%06X\n",
-			 data->info_crc, info_crc);
-	}
+	error = __mxt_read_reg(client, MXT_OBJECT_START + table_size,
+			sizeof(csum), csum);
+	if (error)
+		return error;
 
-	/* Malloc memory to store configuration */
-	cfg_start_ofs = MXT_OBJECT_START +
-			data->info.object_num * sizeof(struct mxt_object) +
-			MXT_INFO_CHECKSUM_SIZE;
-	config_mem_size = data->mem_size - cfg_start_ofs;
-	config_mem = kzalloc(config_mem_size, GFP_KERNEL);
-	if (!config_mem) {
-		dev_err(dev, "Failed to allocate memory\n");
-		return -ENOMEM;
-	}
+	data->info_csum = csum[0] | (csum[1] << 8) | (csum[2] << 16);
+	dev_info(dev, "Information Block Checksum = %06x\n", data->info_csum);
 
-	ret = mxt_prepare_cfg_mem(data, cfg, data_pos, cfg_start_ofs,
-				  config_mem, config_mem_size);
-	if (ret)
-		goto release_mem;
+	error = mxt_verify_info_block_csum(data);
+	if (error)
+		return error;
 
-	/* Calculate crc of the received configs (not the raw config file) */
-	if (data->T7_address < cfg_start_ofs) {
-		dev_err(dev, "Bad T7 address, T7addr = %x, config offset %x\n",
-			data->T7_address, cfg_start_ofs);
-		ret = 0;
-		goto release_mem;
-	}
+	/* Valid Report IDs start counting from 1 */
+	reportid = 1;
+	for (i = 0; i < data->info.object_num; i++) {
+		struct mxt_object *object = data->object_table + i;
+		u8 min_id, max_id;
 
-	calculated_crc = mxt_calculate_crc(config_mem,
-					   data->T7_address - cfg_start_ofs,
-					   config_mem_size);
+		le16_to_cpus(&object->start_address);
 
-	if (config_crc > 0 && config_crc != calculated_crc)
-		dev_warn(dev, "Config CRC error, calculated=%06X, file=%06X\n",
-			 calculated_crc, config_crc);
+		if (object->num_report_ids) {
+			min_id = reportid;
+			reportid += object->num_report_ids *
+					mxt_obj_instances(object);
+			max_id = reportid - 1;
+		} else {
+			min_id = 0;
+			max_id = 0;
+		}
 
-	ret = mxt_upload_cfg_mem(data, cfg_start_ofs,
-				 config_mem, config_mem_size);
-	if (ret)
-		goto release_mem;
-
-	mxt_update_crc(data, MXT_COMMAND_BACKUPNV, MXT_BACKUP_VALUE);
+		dev_info(&data->client->dev,
+			 "Type %2d Start %3d Size %3zu Instances %2zu ReportIDs %3u : %3u\n",
+			 object->type, object->start_address,
+			 mxt_obj_size(object), mxt_obj_instances(object),
+			 min_id, max_id);
 
-	ret = mxt_soft_reset(data);
-	if (ret)
-		goto release_mem;
+		switch (object->type) {
+		case MXT_GEN_MESSAGE_T5:
+			data->T5_address = object->start_address;
+			data->message_length = mxt_obj_size(object) - 1;
+			break;
+		case MXT_GEN_COMMAND_T6:
+			data->T6_reportid = min_id;
+			break;
+		case MXT_TOUCH_MULTI_T9:
+			data->T9_reportid_min = min_id;
+			data->T9_reportid_max = max_id;
+			data->num_touchids = object->num_report_ids;
+			data->has_T9 = true;
+			break;
+		case MXT_SPT_GPIOPWM_T19:
+			data->T19_reportid = min_id;
+			break;
+		case MXT_SPT_MESSAGECOUNT_T44:
+			data->T44_address = object->start_address;
+			break;
+		case MXT_TOUCH_MULTITOUCHSCREEN_T100:
+			data->T100_reportid_min = min_id;
+			data->T100_reportid_max = max_id;
+			data->num_touchids = object->num_report_ids - 2;
+			data->has_T100 = true;
+			break;
+		}
+	}
 
-	dev_info(dev, "Config successfully updated\n");
+	data->current_id = devm_kcalloc(dev,
+					data->num_touchids,
+					sizeof(*data->current_id),
+					GFP_KERNEL);
+	if (!data->current_id)
+		return -ENOMEM;
 
-release_mem:
-	kfree(config_mem);
-	return ret;
+	return 0;
 }
 
-static int mxt_acquire_irq(struct mxt_data *data)
+static int mxt_initialize(struct mxt_data *data)
 {
+	struct i2c_client *client = data->client;
+	struct mxt_info *info = &data->info;
 	int error;
 
-	enable_irq(data->irq);
+	error = mxt_get_info(data);
+	if (error)
+		return error;
 
-	error = mxt_process_messages_until_invalid(data);
+	/* Get object table information */
+	error = mxt_get_object_table(data);
+	if (error)
+		return error;
+
+	/* Apply config from platform data */
+	error = mxt_handle_pdata(data);
+	if (error)
+		return error;
+
+	/* Soft reset */
+	error = mxt_write_object(data, MXT_GEN_COMMAND_T6,
+				 MXT_COMMAND_RESET, 1);
 	if (error)
 		return error;
 
+	msleep(MXT_RESET_TIME);
+
+	dev_info(&client->dev,
+			"Family ID: %u Variant ID: %u Major.Minor.Build: %u.%u.%02X\n",
+			info->family_id, info->variant_id, info->version >> 4,
+			info->version & 0xf, info->build);
+
+	dev_info(&client->dev,
+			"Matrix X Size: %u Matrix Y Size: %u Object Num: %u\n",
+			info->matrix_xsize, info->matrix_ysize,
+			info->object_num);
+
 	return 0;
 }
 
-static int mxt_get_info(struct mxt_data *data)
+static int mxt_update_setting_T100(struct mxt_data *data)
 {
 	struct i2c_client *client = data->client;
-	struct mxt_info *info = &data->info;
-	int error;
+	struct mxt_object *T100;
+	u8 srcaux, tchaux;
+	int ret;
 
-	/* Read 7-byte info block starting at address 0 */
-	error = __mxt_read_reg(client, MXT_INFO, sizeof(*info), info);
-	if (error)
-		return error;
+	T100 = mxt_get_object(data, MXT_TOUCH_MULTITOUCHSCREEN_T100);
+	if (!T100)
+		return -EINVAL;
+
+	/* Get SRCAUX Setting */
+	ret = __mxt_read_reg(client, T100->start_address + MXT_T100_SCRAUX,
+			1, &srcaux);
+	if (ret)
+		return ret;
+	data->T100_enabled_num_reportable_touches =
+			(srcaux & MXT_T100_SRCAUX_NUMRPTTCH);
+	data->T100_enabled_touch_area = (srcaux & MXT_T100_SRCAUX_TCHAREA);
+	data->T100_enabled_antitouch_area = (srcaux & MXT_T100_SRCAUX_ATCHAREA);
+	data->T100_enabled_internal_tracking_area =
+			(srcaux & MXT_T100_SRCAUX_INTTHRAREA);
+
+	/* Get TCHAUX Setting */
+	ret = __mxt_read_reg(client, T100->start_address + MXT_T100_TCHAUX,
+			 1, &tchaux);
+	if (ret)
+		return ret;
+	data->T100_enabled_vector = (tchaux & MXT_T100_TCHAUX_VECT);
+	data->T100_enabled_amplitude = (tchaux & MXT_T100_TCHAUX_AMPL);
+	data->T100_enabled_area = (tchaux & MXT_T100_TCHAUX_AREA);
+	data->T100_enabled_peak = (tchaux & MXT_T100_TCHAUX_PEAK);
+
+	dev_info(&client->dev, "T100 Config: SCRAUX : %X, TCHAUX : %X",
+		 srcaux, tchaux);
 
 	return 0;
 }
 
-static void mxt_free_input_device(struct mxt_data *data)
+static int mxt_calc_resolution_T100(struct mxt_data *data)
 {
-	if (data->input_dev) {
-		input_unregister_device(data->input_dev);
-		data->input_dev = NULL;
+	struct i2c_client *client = data->client;
+	u8 orient;
+	__le16 xyrange[2];
+	unsigned int max_x, max_y;
+	u8 xylines[2];
+	int ret;
+
+	struct mxt_object *T100 = mxt_get_object(
+		data, MXT_TOUCH_MULTITOUCHSCREEN_T100);
+	if (!T100)
+		return -EINVAL;
+
+	/* Get touchscreen resolution */
+	ret = __mxt_read_reg(client, T100->start_address + MXT_T100_XRANGE,
+			2, &xyrange[0]);
+	if (ret)
+		return ret;
+
+	ret = __mxt_read_reg(client, T100->start_address + MXT_T100_YRANGE,
+			2, &xyrange[1]);
+	if (ret)
+		return ret;
+
+	ret = __mxt_read_reg(client, T100->start_address + MXT_T100_CFG1,
+			1, &orient);
+	if (ret)
+		return ret;
+
+	ret = __mxt_read_reg(client, T100->start_address + MXT_T100_XSIZE,
+			1, &xylines[0]);
+	if (ret)
+		return ret;
+
+	ret = __mxt_read_reg(client, T100->start_address + MXT_T100_YSIZE,
+			1, &xylines[1]);
+	if (ret)
+		return ret;
+
+	/* TODO: Read the TCHAUX field and save the VECT/AMPL/AREA config. */
+
+	max_x = le16_to_cpu(xyrange[0]);
+	max_y = le16_to_cpu(xyrange[1]);
+
+	if (max_x == 0)
+		max_x = 1023;
+
+	if (max_y == 0)
+		max_y = 1023;
+
+	if (orient & MXT_T100_CFG_SWITCHXY) {
+		data->max_x = max_y;
+		data->max_y = max_x;
+	} else {
+		data->max_x = max_x;
+		data->max_y = max_y;
 	}
-}
 
-static void mxt_free_object_table(struct mxt_data *data)
-{
-	kfree(data->object_table);
-	data->object_table = NULL;
-	kfree(data->msg_buf);
-	data->msg_buf = NULL;
-	data->T5_address = 0;
-	data->T5_msg_size = 0;
-	data->T6_reportid = 0;
-	data->T7_address = 0;
-	data->T9_reportid_min = 0;
-	data->T9_reportid_max = 0;
-	data->T19_reportid = 0;
-	data->T44_address = 0;
-	data->max_reportid = 0;
+	data->max_area_pixels = max_x * max_y;
+	data->max_area_channels = xylines[0] * xylines[1];
+
+	dev_info(&client->dev,
+		 "T100 Config: XSIZE %u, YSIZE %u, XLINE %u, YLINE %u",
+		 max_x, max_y, xylines[0], xylines[1]);
+
+	return 0;
 }
 
-static int mxt_get_object_table(struct mxt_data *data)
+static int mxt_calc_resolution_T9(struct mxt_data *data)
 {
 	struct i2c_client *client = data->client;
-	size_t table_size;
-	struct mxt_object *object_table;
-	int error;
-	int i;
-	u8 reportid;
-	u16 end_address;
+	u8 orient;
+	__le16 xyrange[2];
+	unsigned int max_x, max_y;
+	u8 xylines[2];
+	int ret;
 
-	table_size = data->info.object_num * sizeof(struct mxt_object);
-	object_table = kzalloc(table_size, GFP_KERNEL);
-	if (!object_table) {
-		dev_err(&data->client->dev, "Failed to allocate memory\n");
-		return -ENOMEM;
-	}
+	struct mxt_object *T9 = mxt_get_object(data, MXT_TOUCH_MULTI_T9);
+	if (T9 == NULL)
+		return -EINVAL;
 
-	error = __mxt_read_reg(client, MXT_OBJECT_START, table_size,
-			object_table);
-	if (error) {
-		kfree(object_table);
-		return error;
-	}
+	/* Get touchscreen resolution */
+	ret = __mxt_read_reg(client, T9->start_address + MXT_TOUCH_XRANGE_LSB,
+			4, xyrange);
+	if (ret)
+		return ret;
 
-	/* Valid Report IDs start counting from 1 */
-	reportid = 1;
-	data->mem_size = 0;
-	for (i = 0; i < data->info.object_num; i++) {
-		struct mxt_object *object = object_table + i;
-		u8 min_id, max_id;
+	ret = __mxt_read_reg(client, T9->start_address + MXT_TOUCH_ORIENT,
+			1, &orient);
+	if (ret)
+		return ret;
 
-		le16_to_cpus(&object->start_address);
+	ret = __mxt_read_reg(client, T9->start_address + MXT_TOUCH_XSIZE,
+			2, xylines);
+	if (ret)
+		return ret;
 
-		if (object->num_report_ids) {
-			min_id = reportid;
-			reportid += object->num_report_ids *
-					mxt_obj_instances(object);
-			max_id = reportid - 1;
-		} else {
-			min_id = 0;
-			max_id = 0;
-		}
+	max_x = le16_to_cpu(xyrange[0]);
+	max_y = le16_to_cpu(xyrange[1]);
 
-		dev_dbg(&data->client->dev,
-			"T%u Start:%u Size:%zu Instances:%zu Report IDs:%u-%u\n",
-			object->type, object->start_address,
-			mxt_obj_size(object), mxt_obj_instances(object),
-			min_id, max_id);
+	if (orient & MXT_XY_SWITCH) {
+		data->max_x = max_y;
+		data->max_y = max_x;
+	} else {
+		data->max_x = max_x;
+		data->max_y = max_y;
+	}
 
-		switch (object->type) {
-		case MXT_GEN_MESSAGE_T5:
-			if (data->info.family_id == 0x80 &&
-			    data->info.version < 0x20) {
-				/*
-				 * On mXT224 firmware versions prior to V2.0
-				 * read and discard unused CRC byte otherwise
-				 * DMA reads are misaligned.
-				 */
-				data->T5_msg_size = mxt_obj_size(object);
-			} else {
-				/* CRC not enabled, so skip last byte */
-				data->T5_msg_size = mxt_obj_size(object) - 1;
-			}
-			data->T5_address = object->start_address;
-			break;
-		case MXT_GEN_COMMAND_T6:
-			data->T6_reportid = min_id;
-			data->T6_address = object->start_address;
-			break;
-		case MXT_GEN_POWER_T7:
-			data->T7_address = object->start_address;
-			break;
-		case MXT_TOUCH_MULTI_T9:
-			data->T9_reportid_min = min_id;
-			data->T9_reportid_max = max_id;
-			data->num_touchids = object->num_report_ids
-						* mxt_obj_instances(object);
-			break;
-		case MXT_SPT_MESSAGECOUNT_T44:
-			data->T44_address = object->start_address;
-			break;
-		case MXT_SPT_GPIOPWM_T19:
-			data->T19_reportid = min_id;
-			break;
-		}
+	data->max_area_pixels = max_x * max_y;
+	data->max_area_channels = xylines[0] * xylines[1];
+
+	dev_info(&client->dev,
+		 "T9 Config: XSIZE %u, YSIZE %u, XLINE %u, YLINE %u",
+		 max_x, max_y, xylines[0], xylines[1]);
+
+	return 0;
+}
 
-		end_address = object->start_address
-			+ mxt_obj_size(object) * mxt_obj_instances(object) - 1;
+/*
+ * Atmel Raw Config File Format
+ *
+ * The first four lines of the raw config file contain:
+ *  1) Version
+ *  2) Chip ID Information (first 7 bytes of device memory)
+ *  3) Chip Information Block 24-bit CRC Checksum
+ *  4) Chip Configuration 24-bit CRC Checksum
+ *
+ * The rest of the file consists of one line per object instance:
+ *   <TYPE> <INSTANCE> <SIZE> <CONTENTS>
+ *
+ *  <TYPE> - 2-byte object type as hex
+ *  <INSTANCE> - 2-byte object instance number as hex
+ *  <SIZE> - 2-byte object size as hex
+ *  <CONTENTS> - array of <SIZE> 1-byte hex values
+ */
+static int mxt_cfg_verify_hdr(struct mxt_data *data, char **config)
+{
+	struct i2c_client *client = data->client;
+	struct device *dev = &client->dev;
+	struct mxt_info info;
+	char *token;
+	int ret = 0;
+	u32 crc;
 
-		if (end_address >= data->mem_size)
-			data->mem_size = end_address + 1;
+	/* Process the first four lines of the file*/
+	/* 1) Version */
+	token = strsep(config, "\n");
+	dev_info(dev, "Config File: Version = %s\n", token ?: "<null>");
+	if (!token ||
+	    strncmp(token, MXT_CONFIG_VERSION, strlen(MXT_CONFIG_VERSION))) {
+		dev_err(dev, "Invalid config file: Bad Version\n");
+		return -EINVAL;
 	}
 
-	/* Store maximum reportid */
-	data->max_reportid = reportid;
+	/* 2) Chip ID */
+	token = strsep(config, "\n");
+	if (!token) {
+		dev_err(dev, "Invalid config file: No Chip ID\n");
+		return -EINVAL;
+	}
+	ret = sscanf(token, "%hhx %hhx %hhx %hhx %hhx %hhx %hhx",
+		     &info.family_id, &info.variant_id,
+		     &info.version, &info.build, &info.matrix_xsize,
+		     &info.matrix_ysize, &info.object_num);
+	dev_info(dev, "Config File: Chip ID = %02x %02x %02x %02x %02x %02x %02x\n",
+		info.family_id, info.variant_id, info.version, info.build,
+		info.matrix_xsize, info.matrix_ysize, info.object_num);
+	if (ret != 7 ||
+	    info.family_id != data->info.family_id ||
+	    info.variant_id != data->info.variant_id ||
+	    info.version != data->info.version ||
+	    info.build != data->info.build ||
+	    info.object_num != data->info.object_num) {
+		dev_err(dev, "Invalid config file: Chip ID info mismatch\n");
+		dev_err(dev, "Chip Info: %02x %02x %02x %02x %02x %02x %02x\n",
+			data->info.family_id, data->info.variant_id,
+			data->info.version, data->info.build,
+			data->info.matrix_xsize, data->info.matrix_ysize,
+			data->info.object_num);
+		return -EINVAL;
+	}
 
-	/* If T44 exists, T5 position has to be directly after */
-	if (data->T44_address && (data->T5_address != data->T44_address + 1)) {
-		dev_err(&client->dev, "Invalid T44 position\n");
-		error = -EINVAL;
-		goto free_object_table;
+	/* 3) Info Block CRC */
+	token = strsep(config, "\n");
+	if (!token) {
+		dev_err(dev, "Invalid config file: No Info Block CRC\n");
+		return -EINVAL;
 	}
 
-	data->msg_buf = kcalloc(data->max_reportid,
-				data->T5_msg_size, GFP_KERNEL);
-	if (!data->msg_buf) {
-		dev_err(&client->dev, "Failed to allocate message buffer\n");
-		error = -ENOMEM;
-		goto free_object_table;
+	if (info.matrix_xsize != data->info.matrix_xsize ||
+	    info.matrix_ysize != data->info.matrix_ysize) {
+		/*
+		 * Matrix xsize and ysize depend on the state of T46 byte 1
+		 * for the XY Mode. A mismatch is possible due to
+		 * a corrupted register set. The config update should proceed
+		 * to correct the problem. In this condition, the info block
+		 * CRC check should be skipped.
+		 */
+		dev_info(dev, "Matrix Xsize and Ysize mismatch. Updating.\n");
+		dev_info(dev, "Chip Info: %02x %02x %02x %02x %02x %02x %02x\n",
+			 data->info.family_id, data->info.variant_id,
+			 data->info.version, data->info.build,
+			 data->info.matrix_xsize, data->info.matrix_ysize,
+			 data->info.object_num);
+		goto config_crc;
 	}
 
-	data->object_table = object_table;
+	ret = sscanf(token, "%x", &crc);
+	if (ret != 1 || crc != data->info_csum) {
+		dev_err(dev, "Config File: Info Block CRC = %06x, info_csum = %06x\n",
+			 crc, data->info_csum);
+		dev_err(dev, "Invalid config file: Bad Info Block CRC\n");
+		return -EINVAL;
+	}
 
-	return 0;
+config_crc:
+	/* 4) Config CRC */
+	/*
+	 * Parse but don't verify against current config;
+	 * TODO: Verify against CRC of rest of file?
+	 */
+	token = strsep(config, "\n");
+	if (!token) {
+		dev_err(dev, "Invalid config file: No Config CRC\n");
+		return -EINVAL;
+	}
+	ret = sscanf(token, "%x", &crc);
+	dev_info(dev, "Config File: Config CRC = %06x\n", crc);
+	if (ret != 1) {
+		dev_err(dev, "Invalid config file: Bad Config CRC\n");
+		return -EINVAL;
+	}
 
-free_object_table:
-	mxt_free_object_table(data);
-	return error;
+	return 0;
 }
 
-static int mxt_read_t9_resolution(struct mxt_data *data)
+static int mxt_cfg_proc_line(struct mxt_data *data, const char *line,
+			     struct list_head *cfg_list)
 {
 	struct i2c_client *client = data->client;
-	int error;
-	struct t9_range range;
-	unsigned char orient;
+	struct device *dev = &client->dev;
+	int ret;
+	u16 type, instance, size;
+	int len;
+	struct mxt_cfg_file_line *cfg_line;
 	struct mxt_object *object;
+	u8 *content;
+	size_t i;
 
-	object = mxt_get_object(data, MXT_TOUCH_MULTI_T9);
-	if (!object)
+	ret = sscanf(line, "%hx %hx %hx%n", &type, &instance, &size, &len);
+	/* Skip unparseable lines */
+	if (ret < 3)
+		return 0;
+	/* Only support 1-byte types */
+	if (type > 0xff) {
+		dev_err(dev, "Invalid type = %X\n", type);
 		return -EINVAL;
+	}
 
-	error = __mxt_read_reg(client,
-			       object->start_address + MXT_T9_RANGE,
-			       sizeof(range), &range);
-	if (error)
-		return error;
-
-	le16_to_cpus(&range.x);
-	le16_to_cpus(&range.y);
+	/* Supplied object MUST be a valid instance and match object size */
+	object = mxt_get_object(data, type);
+	if (!object) {
+		dev_err(dev, "Can't get object\n");
+		return -EINVAL;
+	}
 
-	error =  __mxt_read_reg(client,
-				object->start_address + MXT_T9_ORIENT,
-				1, &orient);
-	if (error)
-		return error;
+	if (instance > mxt_obj_instances(object)) {
+		dev_err(dev, "Too many instances.  Type=%x (%u > %zu)\n",
+			type, instance, mxt_obj_instances(object));
+		return -EINVAL;
+	}
 
-	/* Handle default values */
-	if (range.x == 0)
-		range.x = 1023;
+	if (size != mxt_obj_size(object)) {
+		dev_err(dev, "Incorrect obect size. Type=%x (%u != %zu)\n",
+			type, size, mxt_obj_size(object));
+		return -EINVAL;
+	}
 
-	if (range.y == 0)
-		range.y = 1023;
+	content = kmalloc(size, GFP_KERNEL);
+	if (!content)
+		return -ENOMEM;
 
-	if (orient & MXT_T9_ORIENT_SWITCH) {
-		data->max_x = range.y;
-		data->max_y = range.x;
-	} else {
-		data->max_x = range.x;
-		data->max_y = range.y;
+	for (i = 0; i < size; i++) {
+		line += len;
+		ret = sscanf(line, "%hhx%n", &content[i], &len);
+		if (ret < 1) {
+			ret = -EINVAL;
+			goto free_content;
+		}
 	}
 
-	dev_dbg(&client->dev,
-		"Touchscreen size X%uY%u\n", data->max_x, data->max_y);
+	cfg_line = kzalloc(sizeof(*cfg_line), GFP_KERNEL);
+	if (!cfg_line) {
+		ret = -ENOMEM;
+		goto free_content;
+	}
+	INIT_LIST_HEAD(&cfg_line->list);
+	cfg_line->addr = object->start_address +
+		instance * mxt_obj_size(object);
+	cfg_line->size = mxt_obj_size(object);
+	cfg_line->content = content;
+	list_add_tail(&cfg_line->list, cfg_list);
 
 	return 0;
+
+free_content:
+	kfree(content);
+	return ret;
 }
 
-static int mxt_input_open(struct input_dev *dev);
-static void mxt_input_close(struct input_dev *dev);
+static int mxt_cfg_proc_data(struct mxt_data *data, char **config)
+{
+	struct i2c_client *client = data->client;
+	struct device *dev = &client->dev;
+	char *line;
+	int ret = 0;
+	struct list_head cfg_lines;
+	struct mxt_cfg_file_line *cfg_line, *cfg_line_tmp;
+
+	INIT_LIST_HEAD(&cfg_lines);
+
+	while ((line = strsep(config, "\n"))) {
+		ret = mxt_cfg_proc_line(data, line, &cfg_lines);
+		if (ret < 0)
+			goto free_objects;
+	}
+
+	list_for_each_entry(cfg_line, &cfg_lines, list) {
+		dev_dbg(dev, "Addr = %u Size = %u\n",
+			cfg_line->addr, cfg_line->size);
+		print_hex_dump(KERN_DEBUG, "atmel_mxt_ts: ", DUMP_PREFIX_OFFSET,
+			       16, 1, cfg_line->content, cfg_line->size, false);
+
+		ret = __mxt_write_reg(client, cfg_line->addr, cfg_line->size,
+				cfg_line->content);
+		if (ret)
+			break;
+	}
+
+free_objects:
+	list_for_each_entry_safe(cfg_line, cfg_line_tmp, &cfg_lines, list) {
+		list_del(&cfg_line->list);
+		kfree(cfg_line->content);
+		kfree(cfg_line);
+	}
+	return ret;
+}
 
-static int mxt_initialize_t9_input_device(struct mxt_data *data)
+static int mxt_load_config(struct mxt_data *data, const struct firmware *fw)
 {
 	struct device *dev = &data->client->dev;
-	const struct mxt_platform_data *pdata = data->pdata;
-	struct input_dev *input_dev;
-	int error;
-	unsigned int num_mt_slots;
-	unsigned int mt_flags = 0;
-	int i;
+	int ret, ret2;
+	char *cfg_copy = NULL;
+	char *running;
+
+	ret = mutex_lock_interruptible(&data->fw_mutex);
+	if (ret)
+		return ret;
+
+	/* Make a mutable, '\0'-terminated copy of the config file */
+	cfg_copy = kmalloc(fw->size + 1, GFP_KERNEL);
+	if (!cfg_copy) {
+		ret = -ENOMEM;
+		goto err_alloc_copy;
+	}
+	memcpy(cfg_copy, fw->data, fw->size);
+	cfg_copy[fw->size] = '\0';
+
+	/* Verify config file header (after which running points to data) */
+	running = cfg_copy;
+	ret = mxt_cfg_verify_hdr(data, &running);
+	if (ret) {
+		dev_err(dev, "Error verifying config header (%d)\n", ret);
+		goto free_cfg_copy;
+	}
+
+	disable_irq(data->irq);
+
+	if (data->input_dev) {
+		input_unregister_device(data->input_dev);
+		data->input_dev = NULL;
+	}
+
+	/* Write configuration */
+	ret = mxt_cfg_proc_data(data, &running);
+	if (ret) {
+		dev_err(dev, "Error writing config file (%d)\n", ret);
+		goto register_input_dev;
+	}
+
+	/* Backup nvram */
+	ret = mxt_write_object(data, MXT_GEN_COMMAND_T6,
+			       MXT_COMMAND_BACKUPNV,
+			       MXT_BACKUP_VALUE);
+	if (ret) {
+		dev_err(dev, "Error backup to nvram (%d)\n", ret);
+		goto register_input_dev;
+	}
+	msleep(MXT_BACKUP_TIME);
+
+	/* Reset device */
+	ret = mxt_write_object(data, MXT_GEN_COMMAND_T6,
+			       MXT_COMMAND_RESET, 1);
+	if (ret) {
+		dev_err(dev, "Error resetting device (%d)\n", ret);
+		goto register_input_dev;
+	}
+	msleep(MXT_RESET_TIME);
+
+register_input_dev:
+	ret2 = mxt_input_dev_create(data);
+	if (ret2) {
+		dev_err(dev, "Error creating input_dev (%d)\n", ret2);
+		ret = ret2;
+	}
+
+	/* Clear message buffer */
+	ret2 = mxt_handle_messages(data, true);
+	if (ret2) {
+		dev_err(dev, "Error clearing msg buffer (%d)\n", ret2);
+		ret = ret2;
+	}
+
+	enable_irq(data->irq);
+free_cfg_copy:
+	kfree(cfg_copy);
+err_alloc_copy:
+	mutex_unlock(&data->fw_mutex);
+	return ret;
+}
+
+/*
+ * Helper function for performing a T6 diagnostic command
+ */
+static int mxt_T6_diag_cmd(struct mxt_data *data, struct mxt_object *T6,
+			   u8 cmd)
+{
+	int ret;
+	u16 addr = T6->start_address + MXT_COMMAND_DIAGNOSTIC;
+
+	ret = mxt_write_reg(data->client, addr, cmd);
+	if (ret)
+		return ret;
+
+	/*
+	 * Poll T6.diag until it returns 0x00, which indicates command has
+	 * completed.
+	 */
+	while (cmd != 0) {
+		ret = __mxt_read_reg(data->client, addr, 1, &cmd);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+/*
+ * SysFS Helper function for reading DELTAS and REFERENCE values for T37 object
+ *
+ * For both modes, a T37_buf is allocated to stores matrix_xsize * matrix_ysize
+ * 2-byte (little-endian) values, which are returned to userspace unmodified.
+ *
+ * It is left to userspace to parse the 2-byte values.
+ * - deltas are signed 2's complement 2-byte little-endian values.
+ *     s32 delta = (b[0] + (b[1] << 8));
+ * - refs are signed 'offset binary' 2-byte little-endian values, with offset
+ *   value 0x4000:
+ *     s32 ref = (b[0] + (b[1] << 8)) - 0x4000;
+ */
+static ssize_t mxt_T37_fetch(struct mxt_data *data, u8 mode)
+{
+	struct mxt_object *T6, *T37;
+	u8 *obuf;
+	ssize_t ret = 0;
+	size_t i;
+	size_t T37_buf_size, num_pages;
+	size_t pos;
+
+	if (!data || !data->object_table)
+		return -ENODEV;
+
+	T6 = mxt_get_object(data, MXT_GEN_COMMAND_T6);
+	T37 = mxt_get_object(data, MXT_DEBUG_DIAGNOSTIC_T37);
+	if (!T6 || mxt_obj_size(T6) < 6 || !T37 || mxt_obj_size(T37) < 3) {
+		dev_err(&data->client->dev, "Invalid T6 or T37 object\n");
+		return -ENODEV;
+	}
+
+	/* Something has gone wrong if T37_buf is already allocated */
+	if (data->T37_buf)
+		return -EINVAL;
+
+	T37_buf_size = data->info.matrix_xsize * data->info.matrix_ysize *
+		       sizeof(__le16);
+	data->T37_buf_size = T37_buf_size;
+	data->T37_buf = kmalloc(data->T37_buf_size, GFP_KERNEL);
+	if (!data->T37_buf)
+		return -ENOMEM;
+
+	/* Temporary buffer used to fetch one T37 page */
+	obuf = kmalloc(mxt_obj_size(T37), GFP_KERNEL);
+	if (!obuf)
+		return -ENOMEM;
+
+	disable_irq(data->irq);
+	num_pages = DIV_ROUND_UP(T37_buf_size, mxt_obj_size(T37) - 2);
+	pos = 0;
+	for (i = 0; i < num_pages; i++) {
+		u8 cmd;
+		size_t chunk_len;
+
+		/* For first page, send mode as cmd, otherwise PageUp */
+		cmd = (i == 0) ? mode : MXT_T6_CMD_PAGE_UP;
+		ret = mxt_T6_diag_cmd(data, T6, cmd);
+		if (ret)
+			goto err_free_T37_buf;
+
+		ret = __mxt_read_reg(data->client, T37->start_address,
+				mxt_obj_size(T37), obuf);
+		if (ret)
+			goto err_free_T37_buf;
+
+		/* Verify first two bytes are current mode and page # */
+		if (obuf[0] != mode) {
+			dev_err(&data->client->dev,
+				"Unexpected mode (%u != %u)\n", obuf[0], mode);
+			ret = -EIO;
+			goto err_free_T37_buf;
+		}
+
+		if (obuf[1] != i) {
+			dev_err(&data->client->dev,
+				"Unexpected page (%u != %zu)\n", obuf[1], i);
+			ret = -EIO;
+			goto err_free_T37_buf;
+		}
+
+		/*
+		 * Copy the data portion of the page, or however many bytes are
+		 * left, whichever is less.
+		 */
+		chunk_len = min(mxt_obj_size(T37) - 2, T37_buf_size - pos);
+		memcpy(&data->T37_buf[pos], &obuf[2], chunk_len);
+		pos += chunk_len;
+	}
+
+	goto out;
+
+err_free_T37_buf:
+	kfree(data->T37_buf);
+	data->T37_buf = NULL;
+	data->T37_buf_size = 0;
+out:
+	kfree(obuf);
+	enable_irq(data->irq);
+	return ret ?: 0;
+}
+
+static int mxt_update_file_name(struct device *dev, char** file_name,
+				const char *buf, size_t count)
+{
+	char *new_file_name;
+
+	/* Simple sanity check */
+	if (count > 64) {
+		dev_warn(dev, "File name too long\n");
+		return -EINVAL;
+	}
+
+	/* FIXME: devm_kmemdup() when available */
+	new_file_name = devm_kmalloc(dev, count + 1, GFP_KERNEL);
+	if (!new_file_name) {
+		dev_warn(dev, "no memory\n");
+		return -ENOMEM;
+	}
+
+	memcpy(new_file_name, buf, count + 1);
+
+	/* Echo into the sysfs entry may append newline at the end of buf */
+	if (new_file_name[count - 1] == '\n')
+		count--;
+
+	new_file_name[count] = '\0';
+
+	if (*file_name)
+		devm_kfree(dev, *file_name);
+
+	*file_name = new_file_name;
+
+	return 0;
+}
+
+static ssize_t mxt_backupnv_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	/* Backup non-volatile memory */
+	ret = mxt_write_object(data, MXT_GEN_COMMAND_T6,
+			       MXT_COMMAND_BACKUPNV, MXT_BACKUP_VALUE);
+	if (ret)
+		return ret;
+	msleep(MXT_BACKUP_TIME);
+
+	return count;
+}
+
+static ssize_t mxt_calibrate_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	disable_irq(data->irq);
+	ret = mxt_recalibrate(data);
+	enable_irq(data->irq);
+	return ret ?: count;
+}
+
+static ssize_t mxt_config_csum_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	return scnprintf(buf, PAGE_SIZE, "%06x\n", data->config_csum);
+}
+
+static ssize_t mxt_config_file_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	return scnprintf(buf, PAGE_SIZE, "%s\n", data->config_file);
+}
+
+static ssize_t mxt_config_file_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	ret = mxt_update_file_name(dev, &data->config_file, buf, count);
+	return ret ? ret : count;
+}
+
+static ssize_t mxt_fw_file_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	return scnprintf(buf, PAGE_SIZE, "%s\n", data->fw_file);
+}
+
+static ssize_t mxt_fw_file_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	ret = mxt_update_file_name(dev, &data->fw_file, buf, count);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+/* Firmware Version is returned as Major.Minor.Build */
+static ssize_t mxt_fw_version_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	struct mxt_info *info = &data->info;
+	return scnprintf(buf, PAGE_SIZE, "%u.%u.%02X\n",
+			 info->version >> 4, info->version & 0xf, info->build);
+}
+
+/* Hardware Version is returned as FamilyID.VariantID */
+static ssize_t mxt_hw_version_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	struct mxt_info *info = &data->info;
+	return scnprintf(buf, PAGE_SIZE, "%u.%u\n",
+			 info->family_id, info->variant_id);
+}
+
+static ssize_t mxt_info_csum_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	return scnprintf(buf, PAGE_SIZE, "%06x\n", data->info_csum);
+}
+
+/* Matrix Size is <MatrixSizeX> <MatrixSizeY> */
+static ssize_t mxt_matrix_size_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	struct mxt_info *info = &data->info;
+	return scnprintf(buf, PAGE_SIZE, "%u %u\n",
+			 info->matrix_xsize, info->matrix_ysize);
+}
+
+static ssize_t mxt_object_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	int ret;
+	u32 param;
+	u8 type, instance, offset, val;
+
+	ret = kstrtou32(buf, 16, &param);
+	if (ret < 0)
+		return -EINVAL;
+
+	/*
+	 * Byte Write Command is encoded in 32-bit word: TTIIOOVV:
+	 * <Type> <Instance> <Offset> <Value>
+	 */
+	type = (param & 0xff000000) >> 24;
+	instance = (param & 0x00ff0000) >> 16;
+	offset = (param & 0x0000ff00) >> 8;
+	val = param & 0x000000ff;
+
+	ret = mxt_write_obj_instance(data, type, instance, offset, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t mxt_update_config_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mxt_data *data = i2c_get_clientdata(client);
+	const struct firmware *fw;
+	int error;
+
+	error = request_firmware(&fw, data->config_file, dev);
+	if (error) {
+		dev_err(dev, "Unable to open config file %s, %d\n",
+			data->config_file, error);
+		return error;
+	}
+
+	dev_info(dev, "Using config file %s (size = %zu)\n",
+		 data->config_file, fw->size);
+
+	error = mxt_load_config(data, fw);
+	if (error)
+		dev_err(dev, "The config update failed (%d)\n", error);
+	else
+		dev_dbg(dev, "The config update succeeded\n");
+
+	release_firmware(fw);
+	return error ?: count;
+}
+
+static int mxt_load_fw(struct mxt_data *data, const struct firmware *fw)
+{
+	struct i2c_client *client = data->client;
+	struct device *dev = &client->dev;
+	unsigned int frame_size;
+	unsigned int pos = 0;
+	int ret;
+
+	ret = mutex_lock_interruptible(&data->fw_mutex);
+	if (ret)
+		return ret;
+
+	if (!mxt_in_bootloader(data)) {
+		ret = mxt_enter_bl(data);
+		if (ret) {
+			dev_err(dev, "Failed to enter bootloader, %d.\n", ret);
+			goto out;
+		}
+	}
+
+	ret = mxt_check_bootloader(data, MXT_WAITING_BOOTLOAD_CMD);
+	if (ret) {
+		dev_err(dev, "Checking WAITING_BOOTLOAD_CMD failed, %d\n", ret);
+		goto out;
+	}
+
+	init_completion(&data->bl_completion);
+
+	/* Unlock bootloader */
+	ret = mxt_unlock_bootloader(client);
+	if (ret) {
+		dev_err(dev, "Unlock bootloader failed, %d\n", ret);
+		goto out;
+	}
+
+	while (pos < fw->size) {
+		ret = mxt_check_bootloader(data, MXT_WAITING_FRAME_DATA);
+		if (ret) {
+			dev_err(dev, "Checking WAITING_FRAME_DATE failed, %d\n",
+				ret);
+			goto out;
+		}
+
+		frame_size = ((*(fw->data + pos) << 8) | *(fw->data + pos + 1));
+
+		/* We should add 2 at frame size as the the firmware data is not
+		 * included the CRC bytes.
+		 */
+		frame_size += 2;
+
+		/* Write one frame to device */
+		ret = mxt_fw_write(client, fw->data + pos, frame_size);
+		if (ret) {
+			dev_err(dev, "Writing frame to device failed, %d\n",
+				ret);
+			goto out;
+		}
+
+		ret = mxt_check_bootloader(data, MXT_FRAME_CRC_PASS);
+		if (ret) {
+			dev_err(dev, "Checking FRAME_CRC_PASS failed, %d\n",
+				ret);
+			goto out;
+		}
+
+		pos += frame_size;
+
+		dev_dbg(dev, "Updated %d bytes / %zd bytes\n", pos, fw->size);
+	}
+
+	/* Device exits bl mode to app mode only if successful */
+	mxt_exit_bl(data);
+
+out:
+	mutex_unlock(&data->fw_mutex);
+	return ret;
+}
+
+static ssize_t mxt_update_fw_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct mxt_data *data = i2c_get_clientdata(client);
+	const struct firmware *fw;
+	char *envp[] = {"ERROR=1", NULL};
+	int error;
+
+	error = request_firmware(&fw, data->fw_file, dev);
+	if (error) {
+		dev_err(dev, "Unable to open firmware %s: %d\n",
+			data->fw_file, error);
+		return error;
+	}
+
+	error = mxt_load_fw(data, fw);
+	if (error) {
+		dev_err(dev, "The firmware update failed(%d)\n", error);
+		kobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);
+	} else {
+		dev_dbg(dev, "The firmware update succeeded\n");
+	}
+
+	release_firmware(fw);
+	return error ?: count;
+}
+
+static ssize_t mxt_suspend_acq_interval_ms_show(struct device *dev,
+						struct device_attribute *attr,
+						char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	u8 interval_reg = data->suspend_acq_interval;
+	u8 interval_ms = (interval_reg == 255) ? 0 : interval_reg;
+	return scnprintf(buf, PAGE_SIZE, "%u\n", interval_ms);
+}
+
+static ssize_t mxt_suspend_acq_interval_ms_store(struct device *dev,
+						 struct device_attribute *attr,
+						 const char *buf, size_t count)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	int ret;
+	u32 param;
+
+	ret = kstrtou32(buf, 10, &param);
+	if (ret < 0)
+		return -EINVAL;
+
+	/* 0 ms inteval means "free run" */
+	if (param == 0)
+		param = 255;
+	/* 254 ms is the largest interval */
+	else if (param > 254)
+		param = 254;
+
+	data->suspend_acq_interval = param;
+	return count;
+}
+
+static DEVICE_ATTR(backupnv, S_IWUSR, NULL, mxt_backupnv_store);
+static DEVICE_ATTR(calibrate, S_IWUSR, NULL, mxt_calibrate_store);
+static DEVICE_ATTR(config_csum, S_IRUGO, mxt_config_csum_show, NULL);
+static DEVICE_ATTR(config_file, S_IRUGO | S_IWUSR, mxt_config_file_show,
+		   mxt_config_file_store);
+static DEVICE_ATTR(fw_file, S_IRUGO | S_IWUSR, mxt_fw_file_show,
+		   mxt_fw_file_store);
+static DEVICE_ATTR(fw_version, S_IRUGO, mxt_fw_version_show, NULL);
+static DEVICE_ATTR(hw_version, S_IRUGO, mxt_hw_version_show, NULL);
+static DEVICE_ATTR(info_csum, S_IRUGO, mxt_info_csum_show, NULL);
+static DEVICE_ATTR(matrix_size, S_IRUGO, mxt_matrix_size_show, NULL);
+static DEVICE_ATTR(object, S_IWUSR, NULL, mxt_object_store);
+static DEVICE_ATTR(update_config, S_IWUSR, NULL, mxt_update_config_store);
+static DEVICE_ATTR(update_fw, S_IWUSR, NULL, mxt_update_fw_store);
+static DEVICE_ATTR(suspend_acq_interval_ms, S_IRUGO | S_IWUSR,
+		   mxt_suspend_acq_interval_ms_show,
+		   mxt_suspend_acq_interval_ms_store);
+
+static struct attribute *mxt_attrs[] = {
+	&dev_attr_backupnv.attr,
+	&dev_attr_calibrate.attr,
+	&dev_attr_config_csum.attr,
+	&dev_attr_config_file.attr,
+	&dev_attr_fw_file.attr,
+	&dev_attr_fw_version.attr,
+	&dev_attr_hw_version.attr,
+	&dev_attr_info_csum.attr,
+	&dev_attr_matrix_size.attr,
+	&dev_attr_object.attr,
+	&dev_attr_update_config.attr,
+	&dev_attr_update_fw.attr,
+	NULL
+};
+
+static const struct attribute_group mxt_attr_group = {
+	.attrs = mxt_attrs,
+};
+
+static struct attribute *mxt_power_attrs[] = {
+	&dev_attr_suspend_acq_interval_ms.attr,
+	NULL
+};
+
+static const struct attribute_group mxt_power_attr_group = {
+	.name = power_group_name,
+	.attrs = mxt_power_attrs,
+};
+
+/*
+ **************************************************************
+ * debugfs helper functions
+ **************************************************************
+*/
+
+/*
+ * Print the formatted string into the end of string |*str| which has size
+ * |*str_size|. Extra space will be allocated to hold the formatted string
+ * and |*str_size| will be updated accordingly.
+ */
+static int mxt_asprintf(char **str, size_t *str_size, const char *fmt, ...)
+{
+	unsigned int len;
+	va_list ap, aq;
+	int ret;
+	char *str_tmp;
+
+	va_start(ap, fmt);
+	va_copy(aq, ap);
+	len = vsnprintf(NULL, 0, fmt, aq);
+	va_end(aq);
+
+	str_tmp = krealloc(*str, *str_size + len + 1, GFP_KERNEL);
+	if (str_tmp == NULL)
+		return -ENOMEM;
+
+	*str = str_tmp;
+
+	ret = vsnprintf(*str + *str_size, len + 1, fmt, ap);
+	va_end(ap);
+
+	if (ret != len)
+		return -EINVAL;
+
+	*str_size += len;
+
+	return 0;
+}
+
+static int mxt_instance_fetch(char **str, size_t *count,
+		struct mxt_object *object, int instance, const u8 *val)
+{
+	int i;
+	int ret;
+
+	if (mxt_obj_instances(object) > 1) {
+		ret = mxt_asprintf(str, count, "Instance: %zu\n", instance);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; i < mxt_obj_size(object); i++) {
+		ret = mxt_asprintf(str, count,
+				"\t[%2zu]: %02x (%d)\n", i, val[i], val[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int mxt_object_fetch(struct mxt_data *data)
+{
+	struct mxt_object *object;
+	size_t count = 0;
+	size_t i, j;
+	int ret = 0;
+	char *str = NULL;
+	u8 *obuf;
+
+	if (data->object_str)
+		return -EINVAL;
+
+	/* Pre-allocate buffer large enough to hold max sized object. */
+	obuf = kmalloc(256, GFP_KERNEL);
+	if (!obuf)
+		return -ENOMEM;
+
+	for (i = 0; i < data->info.object_num; i++) {
+		object = data->object_table + i;
+
+		if (!mxt_object_readable(object->type))
+			continue;
+
+		ret = mxt_asprintf(&str, &count, "\nT%u\n", object->type);
+		if (ret)
+			goto err;
+
+		for (j = 0; j < mxt_obj_instances(object); j++) {
+			u16 size = mxt_obj_size(object);
+			u16 addr = object->start_address + j * size;
+
+			ret = __mxt_read_reg(data->client, addr, size, obuf);
+			if (ret)
+				goto done;
+
+			ret = mxt_instance_fetch(&str, &count, object, j, obuf);
+			if (ret)
+				goto err;
+		}
+	}
+
+	goto done;
+
+err:
+	kfree(str);
+	str = NULL;
+	count = 0;
+done:
+	data->object_str = str;
+	data->object_str_size = count;
+	kfree(obuf);
+	return ret;
+}
+
+/*
+ **************************************************************
+ * debugfs interface
+ **************************************************************
+*/
+static int mxt_debugfs_T37_open(struct inode *inode, struct file *file)
+{
+	struct mxt_data *mxt = inode->i_private;
+	int ret;
+	u8 cmd;
+
+	if (file->f_path.dentry == mxt->dentry_deltas)
+		cmd = MXT_T6_CMD_DELTAS;
+	else if (file->f_path.dentry == mxt->dentry_refs)
+		cmd = MXT_T6_CMD_REFS;
+	else if (file->f_path.dentry == mxt->dentry_self_deltas)
+		cmd = MXT_T6_CMD_SELF_DELTAS;
+	else if (file->f_path.dentry == mxt->dentry_self_refs)
+		cmd = MXT_T6_CMD_SELF_REFS;
+	else
+		return -EINVAL;
+
+	/* Only allow one T37 debugfs file to be opened at a time */
+	ret = mutex_lock_interruptible(&mxt->T37_buf_mutex);
+	if (ret)
+		return ret;
+
+	if (!i2c_use_client(mxt->client)) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	/* Fetch all T37 pages into mxt->T37_buf */
+	ret = mxt_T37_fetch(mxt, cmd);
+	if (ret)
+		goto err_release;
+
+	file->private_data = mxt;
+
+	return 0;
+
+err_release:
+	i2c_release_client(mxt->client);
+err_unlock:
+	mutex_unlock(&mxt->T37_buf_mutex);
+	return ret;
+}
+
+static int mxt_debugfs_T37_release(struct inode *inode, struct file *file)
+{
+	struct mxt_data *mxt = file->private_data;
+
+	file->private_data = NULL;
+
+	kfree(mxt->T37_buf);
+	mxt->T37_buf = NULL;
+	mxt->T37_buf_size = 0;
+
+	i2c_release_client(mxt->client);
+	mutex_unlock(&mxt->T37_buf_mutex);
+
+	return 0;
+}
+
+
+/* Return some bytes from the buffered T37 object, starting from *ppos */
+static ssize_t mxt_debugfs_T37_read(struct file *file, char __user *buffer,
+				    size_t count, loff_t *ppos)
+{
+	struct mxt_data *mxt = file->private_data;
+
+	if (!mxt->T37_buf)
+		return -ENODEV;
+
+	if (*ppos >= mxt->T37_buf_size)
+		return 0;
+
+	if (count + *ppos > mxt->T37_buf_size)
+		count = mxt->T37_buf_size - *ppos;
+
+	if (copy_to_user(buffer, &mxt->T37_buf[*ppos], count))
+		return -EFAULT;
+
+	*ppos += count;
+
+	return count;
+}
+
+static const struct file_operations mxt_debugfs_T37_fops = {
+	.owner = THIS_MODULE,
+	.open = mxt_debugfs_T37_open,
+	.release = mxt_debugfs_T37_release,
+	.read = mxt_debugfs_T37_read
+};
+
+static int mxt_debugfs_object_open(struct inode *inode, struct file *file)
+{
+	struct mxt_data *mxt = inode->i_private;
+	int ret;
+
+	/* Only allow one object debugfs file to be opened at a time */
+	ret = mutex_lock_interruptible(&mxt->object_str_mutex);
+	if (ret)
+		return ret;
+
+	if (!i2c_use_client(mxt->client)) {
+		ret = -ENODEV;
+		goto err_object_unlock;
+	}
+
+	ret = mxt_object_fetch(mxt);
+	if (ret)
+		goto err_object_i2c_release;
+	file->private_data = mxt;
+
+	return 0;
+
+err_object_i2c_release:
+	i2c_release_client(mxt->client);
+err_object_unlock:
+	mutex_unlock(&mxt->object_str_mutex);
+	return ret;
+}
+
+static int mxt_debugfs_object_release(struct inode *inode, struct file *file)
+{
+	struct mxt_data *mxt = file->private_data;
+	file->private_data = NULL;
 
-	error = mxt_read_t9_resolution(data);
-	if (error)
-		dev_warn(dev, "Failed to initialize T9 resolution\n");
+	kfree(mxt->object_str);
+	mxt->object_str = NULL;
+	mxt->object_str_size = 0;
 
-	input_dev = input_allocate_device();
-	if (!input_dev) {
-		dev_err(dev, "Failed to allocate memory\n");
-		return -ENOMEM;
-	}
+	i2c_release_client(mxt->client);
+	mutex_unlock(&mxt->object_str_mutex);
 
-	input_dev->name = "Atmel maXTouch Touchscreen";
-	input_dev->phys = data->phys;
-	input_dev->id.bustype = BUS_I2C;
-	input_dev->dev.parent = dev;
-	input_dev->open = mxt_input_open;
-	input_dev->close = mxt_input_close;
+	return 0;
+}
 
-	__set_bit(EV_ABS, input_dev->evbit);
-	__set_bit(EV_KEY, input_dev->evbit);
-	__set_bit(BTN_TOUCH, input_dev->keybit);
+static ssize_t mxt_debugfs_object_read(struct file *file, char __user* buffer,
+				   size_t count, loff_t *ppos)
+{
+	struct mxt_data *mxt = file->private_data;
+	if (!mxt->object_str)
+		return -ENODEV;
 
-	if (pdata->t19_num_keys) {
-		__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);
+	if (*ppos >= mxt->object_str_size)
+		return 0;
 
-		for (i = 0; i < pdata->t19_num_keys; i++)
-			if (pdata->t19_keymap[i] != KEY_RESERVED)
-				input_set_capability(input_dev, EV_KEY,
-						     pdata->t19_keymap[i]);
+	if (count + *ppos > mxt->object_str_size)
+		count = mxt->object_str_size - *ppos;
 
-		mt_flags |= INPUT_MT_POINTER;
+	if (copy_to_user(buffer, &mxt->object_str[*ppos], count))
+		return -EFAULT;
 
-		input_abs_set_res(input_dev, ABS_X, MXT_PIXELS_PER_MM);
-		input_abs_set_res(input_dev, ABS_Y, MXT_PIXELS_PER_MM);
-		input_abs_set_res(input_dev, ABS_MT_POSITION_X,
-				  MXT_PIXELS_PER_MM);
-		input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
-				  MXT_PIXELS_PER_MM);
+	*ppos += count;
 
-		input_dev->name = "Atmel maXTouch Touchpad";
-	}
+	return count;
+}
 
-	/* For single touch */
-	input_set_abs_params(input_dev, ABS_X,
-			     0, data->max_x, 0, 0);
-	input_set_abs_params(input_dev, ABS_Y,
-			     0, data->max_y, 0, 0);
-	input_set_abs_params(input_dev, ABS_PRESSURE,
-			     0, 255, 0, 0);
+static const struct file_operations mxt_debugfs_object_fops = {
+	.owner = THIS_MODULE,
+	.open = mxt_debugfs_object_open,
+	.release = mxt_debugfs_object_release,
+	.read = mxt_debugfs_object_read,
+};
 
-	/* For multi touch */
-	num_mt_slots = data->T9_reportid_max - data->T9_reportid_min + 1;
-	error = input_mt_init_slots(input_dev, num_mt_slots, mt_flags);
-	if (error) {
-		dev_err(dev, "Error %d initialising slots\n", error);
-		goto err_free_mem;
-	}
+static int mxt_debugfs_init(struct mxt_data *mxt)
+{
+	struct device *dev = &mxt->client->dev;
 
-	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
-			     0, MXT_MAX_AREA, 0, 0);
-	input_set_abs_params(input_dev, ABS_MT_POSITION_X,
-			     0, data->max_x, 0, 0);
-	input_set_abs_params(input_dev, ABS_MT_POSITION_Y,
-			     0, data->max_y, 0, 0);
-	input_set_abs_params(input_dev, ABS_MT_PRESSURE,
-			     0, 255, 0, 0);
+	if (!mxt_debugfs_root)
+		return -ENODEV;
 
-	input_set_drvdata(input_dev, data);
+	mxt->dentry_dev = debugfs_create_dir(kobject_name(&dev->kobj),
+					     mxt_debugfs_root);
+
+	if (!mxt->dentry_dev)
+		return -ENODEV;
+
+	mutex_init(&mxt->T37_buf_mutex);
+
+	mxt->dentry_deltas = debugfs_create_file("deltas", S_IRUSR,
+						 mxt->dentry_dev, mxt,
+						 &mxt_debugfs_T37_fops);
+	mxt->dentry_refs = debugfs_create_file("refs", S_IRUSR,
+					       mxt->dentry_dev, mxt,
+					       &mxt_debugfs_T37_fops);
+	if (is_hovering_supported(mxt)) {
+		mxt->dentry_self_deltas =
+			debugfs_create_file("self_deltas", S_IRUSR,
+					    mxt->dentry_dev, mxt,
+					    &mxt_debugfs_T37_fops);
+		mxt->dentry_self_refs =
+			debugfs_create_file("self_refs", S_IRUSR,
+					    mxt->dentry_dev, mxt,
+					    &mxt_debugfs_T37_fops);
+	}
+	mutex_init(&mxt->object_str_mutex);
+
+	mxt->dentry_object = debugfs_create_file("object", S_IRUGO,
+						 mxt->dentry_dev, mxt,
+						 &mxt_debugfs_object_fops);
+	return 0;
+}
 
-	error = input_register_device(input_dev);
-	if (error) {
-		dev_err(dev, "Error %d registering input device\n", error);
-		goto err_free_mem;
+static void mxt_debugfs_remove(struct mxt_data *mxt)
+{
+	if (mxt->dentry_dev) {
+		debugfs_remove_recursive(mxt->dentry_dev);
+		mutex_destroy(&mxt->object_str_mutex);
+		kfree(mxt->object_str);
+		mutex_destroy(&mxt->T37_buf_mutex);
+		kfree(mxt->T37_buf);
 	}
+}
 
-	data->input_dev = input_dev;
+static int mxt_save_regs(struct mxt_data *data, u8 type, u8 instance,
+			 u8 offset, u8 *val, u16 size)
+{
+	struct mxt_object *object;
+	u16 addr;
+	int ret;
 
-	return 0;
+	object = mxt_get_object(data, type);
+	if (!object)
+		return -EINVAL;
 
-err_free_mem:
-	input_free_device(input_dev);
-	return error;
-}
+	addr = object->start_address + instance * mxt_obj_size(object) + offset;
+	ret = __mxt_read_reg(data->client, addr, size, val);
+	if (ret)
+		return -EINVAL;
 
-static int mxt_configure_objects(struct mxt_data *data,
-				 const struct firmware *cfg);
+	return 0;
+}
 
-static void mxt_config_cb(const struct firmware *cfg, void *ctx)
+static int mxt_set_regs(struct mxt_data *data, u8 type, u8 instance,
+			u8 offset, const u8 *val, u16 size)
 {
-	mxt_configure_objects(ctx, cfg);
-	release_firmware(cfg);
+	struct mxt_object *object;
+	u16 addr;
+	int ret;
+
+	object = mxt_get_object(data, type);
+	if (!object)
+		return -EINVAL;
+
+	addr = object->start_address + instance * mxt_obj_size(object) + offset;
+	ret = __mxt_write_reg(data->client, addr, size, val);
+	if (ret)
+		return -EINVAL;
+
+	return 0;
 }
 
-static int mxt_initialize(struct mxt_data *data)
+static void mxt_save_all_regs(struct mxt_data *data)
 {
-	struct i2c_client *client = data->client;
-	int recovery_attempts = 0;
-	int error;
-
-	while (1) {
-		error = mxt_get_info(data);
-		if (!error)
-			break;
+	struct device *dev = &data->client->dev;
+	int ret;
+	u8 current_T9_ctrl = 0;
+	u8 current_T100_ctrl = 0;
 
-		/* Check bootloader state */
-		error = mxt_probe_bootloader(data, false);
-		if (error) {
-			dev_info(&client->dev, "Trying alternate bootloader address\n");
-			error = mxt_probe_bootloader(data, true);
-			if (error) {
-				/* Chip is not in appmode or bootloader mode */
-				return error;
-			}
-		}
+	/* Save 3 bytes T7 Power config */
+	ret = mxt_save_regs(data, MXT_GEN_POWER_T7, 0, 0,
+			    data->T7_config, 3);
+	if (ret)
+		dev_err(dev, "Save T7 Power config failed, %d\n", ret);
+	data->T7_config_valid = (ret == 0);
 
-		/* OK, we are in bootloader, see if we can recover */
-		if (++recovery_attempts > 1) {
-			dev_err(&client->dev, "Could not recover from bootloader mode\n");
-			/*
-			 * We can reflash from this state, so do not
-			 * abort initialization.
-			 */
-			data->in_bootloader = true;
-			return 0;
+	if (data->has_T9) {
+		/* Save 1 byte T9 Ctrl config */
+		ret = mxt_save_regs(data, MXT_TOUCH_MULTI_T9, 0, 0,
+				    &current_T9_ctrl, 1);
+		if (ret)
+			dev_err(dev, "Save T9 ctrl config failed, %d\n", ret);
+		if (!data->T9_ctrl_valid && !ret) {
+			data->T9_ctrl_valid = true;
+			data->T9_ctrl = current_T9_ctrl;
 		}
-
-		/* Attempt to exit bootloader into app mode */
-		mxt_send_bootloader_cmd(data, false);
-		msleep(MXT_FW_RESET_TIME);
 	}
-
-	/* Get object table information */
-	error = mxt_get_object_table(data);
-	if (error) {
-		dev_err(&client->dev, "Error %d reading object table\n", error);
-		return error;
+	if (data->has_T100) {
+		/* Save 1 byte T100 Ctrl config */
+		ret = mxt_save_regs(data, MXT_TOUCH_MULTITOUCHSCREEN_T100, 0, 0,
+				    &current_T100_ctrl, 1);
+		if (ret)
+			dev_err(dev, "Save T100 ctrl config failed, %d\n", ret);
+		if (!data->T100_ctrl_valid && !ret) {
+			data->T100_ctrl_valid = true;
+			data->T100_ctrl = current_T100_ctrl;
+		}
 	}
 
-	error = mxt_acquire_irq(data);
-	if (error)
-		goto err_free_object_table;
-
-	error = request_firmware_nowait(THIS_MODULE, true, MXT_CFG_NAME,
-					&client->dev, GFP_KERNEL, data,
-					mxt_config_cb);
-	if (error) {
-		dev_err(&client->dev, "Failed to invoke firmware loader: %d\n",
-			error);
-		goto err_free_object_table;
+	if (is_hovering_supported(data)) {
+		/* Save 1 byte T101 Ctrl config */
+		ret = mxt_save_regs(data, MXT_SPT_TOUCHSCREENHOVER_T101, 0, 0,
+				    &data->T101_ctrl, 1);
+		if (ret)
+			dev_err(dev, "Save T101 ctrl config failed, %d\n", ret);
+		data->T101_ctrl_valid = (ret == 0);
 	}
 
-	return 0;
+	ret = mxt_save_regs(data, MXT_PROCI_TOUCHSUPPRESSION_T42, 0, 0,
+			    &data->T42_ctrl, 1);
+	if (ret)
+		dev_err(dev, "Save T42 ctrl config failed, %d\n", ret);
+	data->T42_ctrl_valid = (ret == 0);
 
-err_free_object_table:
-	mxt_free_object_table(data);
-	return error;
+	ret = mxt_save_regs(data, MXT_SPT_GPIOPWM_T19, 0, 0,
+			    &data->T19_ctrl, 1);
+	if (ret)
+		dev_err(dev, "Save T19 ctrl config failed, %d\n", ret);
+	data->T19_ctrl_valid = (ret == 0);
 }
 
-static int mxt_configure_objects(struct mxt_data *data,
-				 const struct firmware *cfg)
+static void mxt_restore_all_regs(struct mxt_data *data)
 {
 	struct device *dev = &data->client->dev;
-	struct mxt_info *info = &data->info;
-	int error;
+	int ret;
 
-	if (cfg) {
-		error = mxt_update_cfg(data, cfg);
-		if (error)
-			dev_warn(dev, "Error %d updating config\n", error);
+	/* Restore the T9 Ctrl config to before-suspend value */
+	if (data->has_T9 && data->T9_ctrl_valid) {
+		ret = mxt_set_regs(data, MXT_TOUCH_MULTI_T9, 0, 0,
+				   &data->T9_ctrl, 1);
+		if (ret)
+			dev_err(dev, "Set T9 ctrl config failed, %d\n", ret);
 	}
+	data->T9_ctrl_valid = false;
 
-	error = mxt_initialize_t9_input_device(data);
-	if (error)
-		return error;
+	if (data->has_T100 && data->T100_ctrl_valid) {
+		ret = mxt_set_regs(data, MXT_TOUCH_MULTITOUCHSCREEN_T100, 0, 0,
+				   &data->T100_ctrl, 1);
+		if (ret)
+			dev_err(dev, "Set T100 ctrl config failed, %d\n", ret);
+	}
+	data->T100_ctrl_valid = false;
+
+	/* Restore the T7 Power config to before-suspend value */
+	if (data->T7_config_valid) {
+		ret = mxt_set_regs(data, MXT_GEN_POWER_T7, 0, 0,
+				   data->T7_config, 3);
+		if (ret)
+			dev_err(dev, "Set T7 power config failed, %d\n", ret);
+	} else {
+		u8 fallback_T7_config[3] = {FALLBACK_MXT_POWER_IDLEACQINT,
+					    FALLBACK_MXT_POWER_ACTVACQINT,
+					    FALLBACK_MXT_POWER_ACTV2IDLETO};
+		dev_err(dev, "No T7 values found, setting to fallback value\n");
+		ret = mxt_set_regs(data, MXT_GEN_POWER_T7, 0, 0,
+				   fallback_T7_config, 3);
+		if (ret)
+			dev_err(dev, "Set T7 to fallbacks failed, %d\n", ret);
+	}
 
-	dev_info(dev,
-		 "Family: %u Variant: %u Firmware V%u.%u.%02X Objects: %u\n",
-		 info->family_id, info->variant_id, info->version >> 4,
-		 info->version & 0xf, info->build, info->object_num);
+	/* Restore the T42 ctrl to before-suspend value */
+	if (data->T42_ctrl_valid) {
+		ret = mxt_set_regs(data, MXT_PROCI_TOUCHSUPPRESSION_T42, 0, 0,
+				   &data->T42_ctrl, 1);
+		if (ret)
+			dev_err(dev, "Set T42 ctrl failed, %d\n", ret);
+	}
 
-	return 0;
+	/* Restore the T19 ctrl to before-suspend value */
+	if (data->T19_ctrl_valid) {
+		ret = mxt_set_regs(data, MXT_SPT_GPIOPWM_T19, 0, 0,
+				   &data->T19_ctrl, 1);
+		if (ret)
+			dev_err(dev, "Set T19 ctrl failed, %d\n", ret);
+	}
+
+	if (is_hovering_supported(data) && data->T101_ctrl_valid) {
+		ret = mxt_set_regs(data, MXT_SPT_TOUCHSCREENHOVER_T101, 0, 0,
+				   &data->T101_ctrl, 1);
+		if (ret)
+			dev_err(dev, "Set T101 ctrl config failed, %d\n", ret);
+	}
 }
 
-/* Firmware Version is returned as Major.Minor.Build */
-static ssize_t mxt_fw_version_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
+static void mxt_start(struct mxt_data *data)
 {
-	struct mxt_data *data = dev_get_drvdata(dev);
-	struct mxt_info *info = &data->info;
-	return scnprintf(buf, PAGE_SIZE, "%u.%u.%02X\n",
-			 info->version >> 4, info->version & 0xf, info->build);
+	/* Enable touch reporting */
+	if (data->has_T9)
+		mxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_CTRL,
+				 MXT_TOUCH_CTRL_OPERATIONAL);
+	else
+		mxt_write_object(data, MXT_TOUCH_MULTITOUCHSCREEN_T100,
+				 MXT_T100_CTRL, MXT_TOUCH_CTRL_OPERATIONAL);
 }
 
-/* Hardware Version is returned as FamilyID.VariantID */
-static ssize_t mxt_hw_version_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
+static void mxt_stop(struct mxt_data *data)
 {
-	struct mxt_data *data = dev_get_drvdata(dev);
-	struct mxt_info *info = &data->info;
-	return scnprintf(buf, PAGE_SIZE, "%u.%u\n",
-			 info->family_id, info->variant_id);
+	/* Disable touch reporting */
+	if (data->has_T9)
+		mxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_CTRL,
+				 MXT_TOUCH_CTRL_OFF);
+	else
+		mxt_write_object(data, MXT_TOUCH_MULTITOUCHSCREEN_T100,
+				 MXT_T100_CTRL, MXT_TOUCH_CTRL_OFF);
 }
 
-static ssize_t mxt_show_instance(char *buf, int count,
-				 struct mxt_object *object, int instance,
-				 const u8 *val)
+static int mxt_input_open(struct input_dev *dev)
 {
-	int i;
+	struct mxt_data *data = input_get_drvdata(dev);
 
-	if (mxt_obj_instances(object) > 1)
-		count += scnprintf(buf + count, PAGE_SIZE - count,
-				   "Instance %u\n", instance);
-
-	for (i = 0; i < mxt_obj_size(object); i++)
-		count += scnprintf(buf + count, PAGE_SIZE - count,
-				"\t[%2u]: %02x (%d)\n", i, val[i], val[i]);
-	count += scnprintf(buf + count, PAGE_SIZE - count, "\n");
+	mxt_start(data);
 
-	return count;
+	return 0;
 }
 
-static ssize_t mxt_object_show(struct device *dev,
-				    struct device_attribute *attr, char *buf)
+static void mxt_input_close(struct input_dev *dev)
 {
-	struct mxt_data *data = dev_get_drvdata(dev);
-	struct mxt_object *object;
-	int count = 0;
-	int i, j;
-	int error;
-	u8 *obuf;
+	struct mxt_data *data = input_get_drvdata(dev);
 
-	/* Pre-allocate buffer large enough to hold max sized object. */
-	obuf = kmalloc(256, GFP_KERNEL);
-	if (!obuf)
-		return -ENOMEM;
+	mxt_stop(data);
+}
 
-	error = 0;
-	for (i = 0; i < data->info.object_num; i++) {
-		object = data->object_table + i;
+static int mxt_input_inhibit(struct input_dev *input)
+{
+	static const u8 T7_config_deepsleep[3] = { 0x00, 0x00, 0x00 };
+	struct mxt_data *data = input_get_drvdata(input);
+	struct device *dev = &data->client->dev;
+	int ret;
 
-		if (!mxt_object_readable(object->type))
-			continue;
+	dev_dbg(dev, "inhibit\n");
 
-		count += scnprintf(buf + count, PAGE_SIZE - count,
-				"T%u:\n", object->type);
+	disable_irq(data->client->irq);
 
-		for (j = 0; j < mxt_obj_instances(object); j++) {
-			u16 size = mxt_obj_size(object);
-			u16 addr = object->start_address + j * size;
+	mxt_save_all_regs(data);
 
-			error = __mxt_read_reg(data->client, addr, size, obuf);
-			if (error)
-				goto done;
+	ret = mxt_set_regs(data, MXT_GEN_POWER_T7, 0, 0,
+			   T7_config_deepsleep, 3);
+	if (ret)
+		dev_err(dev, "Set T7 Power config failed, %d\n", ret);
 
-			count = mxt_show_instance(buf, count, object, j, obuf);
-		}
-	}
+	mxt_stop(data);
 
-done:
-	kfree(obuf);
-	return error ?: count;
+	return 0;
 }
 
-static int mxt_check_firmware_format(struct device *dev,
-				     const struct firmware *fw)
+static int mxt_input_uninhibit(struct input_dev *input)
 {
-	unsigned int pos = 0;
-	char c;
+	struct mxt_data *data = input_get_drvdata(input);
+	struct device *dev = &data->client->dev;
+	int error;
 
-	while (pos < fw->size) {
-		c = *(fw->data + pos);
+	dev_dbg(dev, "uninhibit\n");
 
-		if (c < '0' || (c > '9' && c < 'A') || c > 'F')
-			return 0;
+	/* Read all pending messages so that CHG line can be de-asserted */
+	error = mxt_handle_messages(data, false);
+	if (error)
+		dev_warn(dev,
+			 "error while clearing pending messages when un-inhibiting: %d\n",
+			 error);
 
-		pos++;
-	}
+	mxt_release_all_fingers(data);
+
+	data->T9_ctrl_valid = false;
+	mxt_restore_all_regs(data);
+
+	mxt_start(data);
 
 	/*
-	 * To convert file try:
-	 * xxd -r -p mXTXXX__APP_VX-X-XX.enc > maxtouch.fw
+	 * As hovering is supported in mXT33xT series, an extra calibration is
+	 * required to reflect environment change especially for sensitive SC
+	 * deltas when system resumes from suspend/idle.
 	 */
-	dev_err(dev, "Aborting: firmware file must be in binary format\n");
+	if (is_mxt_33x_t(data))
+		mxt_recalibrate(data);
 
-	return -EINVAL;
+	enable_irq(data->client->irq);
+
+	return 0;
 }
 
-static int mxt_load_fw(struct device *dev, const char *fn)
+static int mxt_input_dev_create(struct mxt_data *data)
 {
-	struct mxt_data *data = dev_get_drvdata(dev);
-	const struct firmware *fw = NULL;
-	unsigned int frame_size;
-	unsigned int pos = 0;
-	unsigned int retry = 0;
-	unsigned int frame = 0;
-	int ret;
-
-	ret = request_firmware(&fw, fn, dev);
-	if (ret) {
-		dev_err(dev, "Unable to open firmware %s\n", fn);
-		return ret;
-	}
-
-	/* Check for incorrect enc file */
-	ret = mxt_check_firmware_format(dev, fw);
-	if (ret)
-		goto release_firmware;
-
-	if (!data->in_bootloader) {
-		/* Change to the bootloader mode */
-		data->in_bootloader = true;
+	const struct mxt_platform_data *pdata = data->pdata;
+	struct input_dev *input_dev;
+	int error;
+	int max_area_channels;
+	int max_touch_major;
 
-		ret = mxt_t6_command(data, MXT_COMMAND_RESET,
-				     MXT_BOOT_VALUE, false);
-		if (ret)
-			goto release_firmware;
+	/* Don't need to register input_dev in bl mode */
+	if (mxt_in_bootloader(data))
+		return 0;
 
-		msleep(MXT_RESET_TIME);
+	error = data->has_T9 ? mxt_calc_resolution_T9(data) :
+			       mxt_calc_resolution_T100(data);
+	if (error)
+		return error;
 
-		/* Do not need to scan since we know family ID */
-		ret = mxt_lookup_bootloader_address(data, 0);
-		if (ret)
-			goto release_firmware;
+	/* Update T100 settings */
+	if (data->has_T100) {
+		error = mxt_update_setting_T100(data);
+		if (error)
+			return error;
+	}
 
-		mxt_free_input_device(data);
-		mxt_free_object_table(data);
-	} else {
-		enable_irq(data->irq);
+	/* Clear the existing one if it exists */
+	if (data->input_dev) {
+		input_unregister_device(data->input_dev);
+		data->input_dev = NULL;
 	}
 
-	reinit_completion(&data->bl_completion);
+	input_dev = devm_input_allocate_device(&data->client->dev);
+	if (!input_dev)
+		return -ENOMEM;
+
+	if (pdata && pdata->is_tp)
+		data->is_tp = true;
 
-	ret = mxt_check_bootloader(data, MXT_WAITING_BOOTLOAD_CMD, false);
-	if (ret) {
-		/* Bootloader may still be unlocked from previous attempt */
-		ret = mxt_check_bootloader(data, MXT_WAITING_FRAME_DATA, false);
-		if (ret)
-			goto disable_irq;
-	} else {
-		dev_info(dev, "Unlocking bootloader\n");
+	input_dev->name = (data->is_tp) ? "Atmel maXTouch Touchpad" :
+					  "Atmel maXTouch Touchscreen";
+	input_dev->phys = data->phys;
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &data->client->dev;
+	input_dev->open = mxt_input_open;
+	input_dev->close = mxt_input_close;
+	input_dev->inhibit = mxt_input_inhibit;
+	input_dev->uninhibit = mxt_input_uninhibit;
 
-		/* Unlock bootloader */
-		ret = mxt_send_bootloader_cmd(data, true);
-		if (ret)
-			goto disable_irq;
-	}
+	__set_bit(EV_ABS, input_dev->evbit);
+	__set_bit(EV_KEY, input_dev->evbit);
+	__set_bit(BTN_TOUCH, input_dev->keybit);
 
-	while (pos < fw->size) {
-		ret = mxt_check_bootloader(data, MXT_WAITING_FRAME_DATA, true);
-		if (ret)
-			goto disable_irq;
+	if (data->is_tp) {
+		int i;
+		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+		__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);
 
-		frame_size = ((*(fw->data + pos) << 8) | *(fw->data + pos + 1));
+		if (!pdata)
+			__set_bit(BTN_LEFT, input_dev->keybit);
+		for (i = 0; i < MXT_NUM_GPIO; i++)
+			if (pdata && pdata->key_map[i] != KEY_RESERVED)
+				__set_bit(pdata->key_map[i], input_dev->keybit);
+
+		__set_bit(BTN_TOOL_FINGER, input_dev->keybit);
+		__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);
+		__set_bit(BTN_TOOL_TRIPLETAP, input_dev->keybit);
+		__set_bit(BTN_TOOL_QUADTAP, input_dev->keybit);
+		__set_bit(BTN_TOOL_QUINTTAP, input_dev->keybit);
 
-		/* Take account of CRC bytes */
-		frame_size += 2;
+		input_abs_set_res(input_dev, ABS_X, MXT_PIXELS_PER_MM);
+		input_abs_set_res(input_dev, ABS_Y, MXT_PIXELS_PER_MM);
+		input_abs_set_res(input_dev, ABS_MT_POSITION_X,
+				  MXT_PIXELS_PER_MM);
+		input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
+				  MXT_PIXELS_PER_MM);
+	}
 
-		/* Write one frame to device */
-		ret = mxt_bootloader_write(data, fw->data + pos, frame_size);
-		if (ret)
-			goto disable_irq;
+	/* For single touch */
+	input_set_abs_params(input_dev, ABS_X,
+			     0, data->max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y,
+			     0, data->max_y, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE,
+			     0, 255, 0, 0);
+	input_abs_set_res(input_dev, ABS_X, MXT_PIXELS_PER_MM);
+	input_abs_set_res(input_dev, ABS_Y, MXT_PIXELS_PER_MM);
 
-		ret = mxt_check_bootloader(data, MXT_FRAME_CRC_PASS, true);
-		if (ret) {
-			retry++;
+	/* For multi touch */
+	error = input_mt_init_slots(input_dev, data->num_touchids, 0);
+	if (error)
+		goto err_free_input_dev;
 
-			/* Back off by 20ms per retry */
-			msleep(retry * 20);
+	max_area_channels = min(255U, data->max_area_channels);
+	max_touch_major = get_touch_major_pixels(data, max_area_channels);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
+			     0, max_touch_major, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X,
+			     0, data->max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y,
+			     0, data->max_y, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_PRESSURE,
+			     0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_DISTANCE,
+			     DISTANCE_ACTIVE_TOUCH, DISTANCE_HOVERING, 0, 0);
+	input_abs_set_res(input_dev, ABS_MT_POSITION_X, MXT_PIXELS_PER_MM);
+	input_abs_set_res(input_dev, ABS_MT_POSITION_Y, MXT_PIXELS_PER_MM);
 
-			if (retry > 20) {
-				dev_err(dev, "Retry count exceeded\n");
-				goto disable_irq;
-			}
-		} else {
-			retry = 0;
-			pos += frame_size;
-			frame++;
-		}
+	input_set_drvdata(input_dev, data);
 
-		if (frame % 50 == 0)
-			dev_dbg(dev, "Sent %d frames, %d/%zd bytes\n",
-				frame, pos, fw->size);
-	}
+	error = input_register_device(input_dev);
+	if (error)
+		goto err_free_input_dev;
 
-	/* Wait for flash. */
-	ret = mxt_wait_for_completion(data, &data->bl_completion,
-				      MXT_FW_RESET_TIME);
-	if (ret)
-		goto disable_irq;
+	data->input_dev = input_dev;
+	return 0;
 
-	dev_dbg(dev, "Sent %d frames, %d bytes\n", frame, pos);
+err_free_input_dev:
 
 	/*
-	 * Wait for device to reset. Some bootloader versions do not assert
-	 * the CHG line after bootloading has finished, so ignore potential
-	 * errors.
+	 * Even though input device is managed we free it on error
+	 * because next time mxt_input_dev_create() is called it
+	 * would not know if device is fully registered or not and
+	 * if it should be unregistered or freed.
 	 */
-	mxt_wait_for_completion(data, &data->bl_completion, MXT_FW_RESET_TIME);
-
-	data->in_bootloader = false;
-
-disable_irq:
-	disable_irq(data->irq);
-release_firmware:
-	release_firmware(fw);
-	return ret;
+	input_free_device(input_dev);
+	return error;
 }
 
-static ssize_t mxt_update_fw_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
+static int mxt_power_on(struct mxt_data *data)
 {
-	struct mxt_data *data = dev_get_drvdata(dev);
 	int error;
 
-	error = mxt_load_fw(dev, MXT_FW_NAME);
-	if (error) {
-		dev_err(dev, "The firmware update failed(%d)\n", error);
-		count = error;
-	} else {
-		dev_info(dev, "The firmware update succeeded\n");
+	/*
+	 * If we do not have reset gpio assume platform firmware
+	 * controls regulators and does power them on for us.
+	 */
+	if (IS_ERR_OR_NULL(data->reset_gpio))
+		return 0;
 
-		error = mxt_initialize(data);
-		if (error)
-			return error;
-	}
+	gpiod_set_value_cansleep(data->reset_gpio, 1);
 
-	return count;
-}
+	error = regulator_enable(data->vdd);
+	if (error) {
+		dev_err(&data->client->dev,
+			"failed to enable vdd regulator: %d\n",
+			error);
+		goto release_reset_gpio;
+	}
 
-static DEVICE_ATTR(fw_version, S_IRUGO, mxt_fw_version_show, NULL);
-static DEVICE_ATTR(hw_version, S_IRUGO, mxt_hw_version_show, NULL);
-static DEVICE_ATTR(object, S_IRUGO, mxt_object_show, NULL);
-static DEVICE_ATTR(update_fw, S_IWUSR, NULL, mxt_update_fw_store);
+	error = regulator_enable(data->avdd);
+	if (error) {
+		dev_err(&data->client->dev,
+			"failed to enable avdd regulator: %d\n",
+			error);
+		regulator_disable(data->vdd);
+		goto release_reset_gpio;
+	}
 
-static struct attribute *mxt_attrs[] = {
-	&dev_attr_fw_version.attr,
-	&dev_attr_hw_version.attr,
-	&dev_attr_object.attr,
-	&dev_attr_update_fw.attr,
-	NULL
-};
+release_reset_gpio:
+	gpiod_set_value_cansleep(data->reset_gpio, 0);
+	if (error)
+		return error;
 
-static const struct attribute_group mxt_attr_group = {
-	.attrs = mxt_attrs,
-};
+	msleep(MXT_POWERON_DELAY);
 
-static void mxt_start(struct mxt_data *data)
-{
-	/* Touch enable */
-	mxt_write_object(data,
-			MXT_TOUCH_MULTI_T9, MXT_TOUCH_CTRL, 0x83);
+	return 0;
 }
 
-static void mxt_stop(struct mxt_data *data)
+static void mxt_power_off(void *_data)
 {
-	/* Touch disable */
-	mxt_write_object(data,
-			MXT_TOUCH_MULTI_T9, MXT_TOUCH_CTRL, 0);
+	struct mxt_data *data = _data;
+
+	regulator_disable(data->avdd);
+	regulator_disable(data->vdd);
 }
 
-static int mxt_input_open(struct input_dev *dev)
+static int mxt_check_device_present(struct mxt_data *data, bool probe_alternate)
 {
-	struct mxt_data *data = input_get_drvdata(dev);
-
-	mxt_start(data);
+	struct i2c_client *client = data->client;
+	union i2c_smbus_data dummy;
 
-	return 0;
-}
+	if (i2c_smbus_xfer(client->adapter, client->addr,
+			   0, I2C_SMBUS_READ, 0, I2C_SMBUS_BYTE,
+			   &dummy) == 0)
+		return 0;
 
-static void mxt_input_close(struct input_dev *dev)
-{
-	struct mxt_data *data = input_get_drvdata(dev);
+	/*
+	 * FIXME: This is basically a hack to cope with device tree
+	 * specifying given address but device coming up in bootloader
+	 * mode and using another address. We can't do what we did
+	 * earlier and define 2-nd device at alternate address as they
+	 * will both try to grab reset gpio and clash, so we hack around
+	 * it here.
+	 */
+	if (probe_alternate && client->addr == 0x4a) {
+		client->addr = 0x26;
+		if (i2c_smbus_xfer(client->adapter, client->addr,
+				   0, I2C_SMBUS_READ, 0, I2C_SMBUS_BYTE,
+				   &dummy) == 0)
+			return 0;
+	}
 
-	mxt_stop(data);
+	return -ENXIO;
 }
 
-#ifdef CONFIG_OF
-static struct mxt_platform_data *mxt_parse_dt(struct i2c_client *client)
+static void mxt_cleanup_fs(void *_data)
 {
-	struct mxt_platform_data *pdata;
-	u32 *keymap;
-	u32 keycode;
-	int proplen, i, ret;
-
-	if (!client->dev.of_node)
-		return ERR_PTR(-ENODEV);
-
-	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
-	if (!pdata)
-		return ERR_PTR(-ENOMEM);
-
-	if (of_find_property(client->dev.of_node, "linux,gpio-keymap",
-			     &proplen)) {
-		pdata->t19_num_keys = proplen / sizeof(u32);
-
-		keymap = devm_kzalloc(&client->dev,
-				pdata->t19_num_keys * sizeof(keymap[0]),
-				GFP_KERNEL);
-		if (!keymap)
-			return ERR_PTR(-ENOMEM);
-
-		for (i = 0; i < pdata->t19_num_keys; i++) {
-			ret = of_property_read_u32_index(client->dev.of_node,
-					"linux,gpio-keymap", i, &keycode);
-			if (ret)
-				keycode = KEY_RESERVED;
+	struct mxt_data *data = _data;
+	struct i2c_client *client = data->client;
 
-			keymap[i] = keycode;
-		}
+	if (data->debugfs_initialized)
+		mxt_debugfs_remove(data);
 
-		pdata->t19_keymap = keymap;
-	}
+	if (data->power_sysfs_group_merged)
+		sysfs_unmerge_group(&client->dev.kobj, &mxt_power_attr_group);
 
-	return pdata;
-}
-#else
-static struct mxt_platform_data *mxt_parse_dt(struct i2c_client *client)
-{
-	dev_dbg(&client->dev, "No platform data specified\n");
-	return ERR_PTR(-EINVAL);
+	if (data->sysfs_group_created)
+		sysfs_remove_group(&client->dev.kobj, &mxt_attr_group);
 }
-#endif
 
-static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)
+static int mxt_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
 {
+	const struct mxt_platform_data *pdata = dev_get_platdata(&client->dev);
 	struct mxt_data *data;
-	const struct mxt_platform_data *pdata;
+	unsigned long irqflags;
 	int error;
 
-	pdata = dev_get_platdata(&client->dev);
-	if (!pdata) {
-		pdata = mxt_parse_dt(client);
-		if (IS_ERR(pdata))
-			return PTR_ERR(pdata);
-	}
-
-	data = kzalloc(sizeof(struct mxt_data), GFP_KERNEL);
+	data = devm_kzalloc(&client->dev, sizeof(struct mxt_data), GFP_KERNEL);
 	if (!data) {
 		dev_err(&client->dev, "Failed to allocate memory\n");
 		return -ENOMEM;
 	}
 
+	if (id)
+		data->is_tp = !strcmp(id->name, "atmel_mxt_tp");
+#ifdef CONFIG_ACPI
+	else {
+		/*
+		 * Check the ACPI device ID to determine if this device
+		 * is a touchpad because i2c_device_id is NULL when probed
+		 * from the ACPI device id table.
+		 */
+		struct acpi_device *adev;
+		acpi_status status;
+		status = acpi_bus_get_device(ACPI_HANDLE(&client->dev), &adev);
+		if (ACPI_SUCCESS(status))
+			data->is_tp = !strncmp(dev_name(&adev->dev),
+					       "ATML0000", 8);
+	}
+#endif
+	data->client = client;
+	i2c_set_clientdata(client, data);
+
 	snprintf(data->phys, sizeof(data->phys), "i2c-%u-%04x/input0",
 		 client->adapter->nr, client->addr);
 
-	data->client = client;
 	data->pdata = pdata;
 	data->irq = client->irq;
-	i2c_set_clientdata(client, data);
+
+	mutex_init(&data->fw_mutex);
 
 	init_completion(&data->bl_completion);
-	init_completion(&data->reset_completion);
-	init_completion(&data->crc_completion);
+	init_completion(&data->auto_cal_completion);
+
+	data->suspend_acq_interval = MXT_SUSPEND_ACQINT_VALUE;
+
+	data->vdd = devm_regulator_get(&client->dev, "vdd");
+	if (IS_ERR(data->vdd)) {
+		error = PTR_ERR(data->vdd);
+		if (error != -EPROBE_DEFER)
+			dev_err(&client->dev,
+				"Failed to get 'vdd' regulator: %d\n",
+				error);
+		return error;
+	}
+
+	data->avdd = devm_regulator_get(&client->dev, "avdd");
+	if (IS_ERR(data->avdd)) {
+		error = PTR_ERR(data->avdd);
+		if (error != -EPROBE_DEFER)
+			dev_err(&client->dev,
+				"Failed to get 'avdd' regulator: %d\n",
+				error);
+		return error;
+	}
+
+	data->reset_gpio = devm_gpiod_get(&client->dev, "atmel,reset");
+	if (IS_ERR(data->reset_gpio)) {
+		error = PTR_ERR(data->reset_gpio);
+
+		if (error == -EPROBE_DEFER)
+			return error;
+
+		if (error != -ENOENT && error != -ENOSYS) {
+			dev_err(&client->dev,
+				"failed to get reset gpio: %d\n",
+				error);
+			return error;
+		}
+
+	} else {
+		error = gpiod_direction_output(data->reset_gpio, 0);
+		if (error) {
+			dev_err(&client->dev,
+				"failed to configure reset gpio as output: %d\n",
+				error);
+			return error;
+		}
+	}
 
-	error = request_threaded_irq(client->irq, NULL, mxt_interrupt,
-				     pdata->irqflags | IRQF_ONESHOT,
-				     client->name, data);
+	error = mxt_power_on(data);
+	if (error)
+		return error;
+
+	error = devm_add_action(&client->dev, mxt_power_off, data);
 	if (error) {
-		dev_err(&client->dev, "Failed to register interrupt\n");
-		goto err_free_mem;
+		dev_err(&client->dev,
+			"failed to install power off action: %d\n", error);
+		mxt_power_off(data);
+		return error;
 	}
 
-	disable_irq(client->irq);
+	error = mxt_check_device_present(data,
+					 !IS_ERR_OR_NULL(data->reset_gpio));
+	if (error)
+		return error;
 
-	error = mxt_initialize(data);
+	error = mxt_update_file_name(&client->dev, &data->fw_file, MXT_FW_NAME,
+				     strlen(MXT_FW_NAME));
+	if (error)
+		return error;
+
+	error = mxt_update_file_name(&client->dev, &data->config_file,
+				     MXT_CONFIG_NAME, strlen(MXT_CONFIG_NAME));
 	if (error)
-		goto err_free_irq;
+		return error;
 
-	error = sysfs_create_group(&client->dev.kobj, &mxt_attr_group);
+	if (mxt_in_bootloader(data)) {
+		dev_warn(&client->dev, "device in bootloader at probe\n");
+	} else {
+		error = mxt_initialize(data);
+		if (error)
+			return error;
+
+		error = mxt_input_dev_create(data);
+		if (error)
+			return error;
+	}
+
+	/*
+	 * Force the device to report back status so we can cache the device
+	 * config checksum.
+	 */
+	error = mxt_write_object(data, MXT_GEN_COMMAND_T6,
+				 MXT_COMMAND_REPORTALL, 1);
+	if (error)
+		dev_warn(&client->dev, "error making device report status.\n");
+
+	/* Default to falling edge if no platform data provided */
+	irqflags = data->pdata ? data->pdata->irqflags : IRQF_TRIGGER_FALLING;
+	error = devm_request_threaded_irq(&client->dev, client->irq,
+					  NULL, mxt_interrupt,
+					  irqflags | IRQF_ONESHOT,
+					  client->name, data);
 	if (error) {
-		dev_err(&client->dev, "Failure %d creating sysfs group\n",
+		dev_err(&client->dev, "failed to register interrupt: %d\n",
 			error);
-		goto err_free_object;
+		return error;
 	}
 
-	return 0;
+	if (!mxt_in_bootloader(data)) {
+		error = mxt_handle_messages(data, true);
+		if (error)
+			return error;
+	}
 
-err_free_object:
-	mxt_free_input_device(data);
-	mxt_free_object_table(data);
-err_free_irq:
-	free_irq(client->irq, data);
-err_free_mem:
-	kfree(data);
-	return error;
+	error = devm_add_action(&client->dev, mxt_cleanup_fs, data);
+	if (error) {
+		dev_err(&client->dev,
+			"failed to add cleanup fs action: %d\n",
+			error);
+		return error;
+	}
+
+	error = sysfs_create_group(&client->dev.kobj, &mxt_attr_group);
+	if (error) {
+		dev_err(&client->dev, "error creating sysfs entries.\n");
+		return error;
+	} else {
+		data->sysfs_group_created = true;
+	}
+
+	error = sysfs_merge_group(&client->dev.kobj, &mxt_power_attr_group);
+	if (error)
+		dev_warn(&client->dev, "error merging power sysfs entries.\n");
+	else
+		data->power_sysfs_group_merged = true;
+
+	error = mxt_debugfs_init(data);
+	if (error)
+		dev_warn(&client->dev, "error creating debugfs entries.\n");
+	else
+		data->debugfs_initialized = true;
+
+	device_set_wakeup_enable(&client->dev, false);
+
+	return 0;
 }
 
-static int mxt_remove(struct i2c_client *client)
+static void __maybe_unused mxt_suspend_enable_T9(struct mxt_data *data,
+						 u8 current_T9_ctrl)
 {
-	struct mxt_data *data = i2c_get_clientdata(client);
+	struct device *dev = &data->client->dev;
+	u8 T9_ctrl = MXT_TOUCH_CTRL_ENABLE | MXT_TOUCH_CTRL_RPTEN;
+	int ret;
+	unsigned long timeout = msecs_to_jiffies(350);
+	bool need_enable = false;
+	bool need_report = false;
+
+	dev_dbg(dev, "Current T9_Ctrl is %x\n", current_T9_ctrl);
+
+	need_enable = !(current_T9_ctrl & MXT_TOUCH_CTRL_ENABLE);
+	need_report = !(current_T9_ctrl & MXT_TOUCH_CTRL_RPTEN);
+
+	/* If already enabled and reporting, do nothing */
+	if (!need_enable && !need_report)
+		return;
+
+	/* If the ENABLE bit is toggled, there will be auto-calibration msg.
+	 * We will have to clear this msg before going into suspend otherwise
+	 * it will wake up the device immediately
+	 */
+	if (need_enable)
+		init_completion(&data->auto_cal_completion);
 
-	sysfs_remove_group(&client->dev.kobj, &mxt_attr_group);
-	free_irq(data->irq, data);
-	mxt_free_input_device(data);
-	mxt_free_object_table(data);
-	kfree(data);
+	/* Enable T9 object (ENABLE and REPORT) */
+	ret = mxt_set_regs(data, MXT_TOUCH_MULTI_T9, 0, 0,
+			   &T9_ctrl, 1);
+	if (ret) {
+		dev_err(dev, "Set T9 ctrl config failed, %d\n", ret);
+		return;
+	}
 
-	return 0;
+	if (need_enable) {
+		ret = wait_for_completion_interruptible_timeout(
+			&data->auto_cal_completion, timeout);
+		if (ret <= 0)
+			dev_err(dev, "Wait for auto cal completion failed.\n");
+	}
 }
 
 static int __maybe_unused mxt_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct mxt_data *data = i2c_get_clientdata(client);
-	struct input_dev *input_dev = data->input_dev;
+	struct input_dev *input_dev;
+	const u8 T7_config_idle[3] = {
+			data->suspend_acq_interval,
+			data->suspend_acq_interval,
+			0x00 };
+	static const u8 T7_config_deepsleep[3] = { 0x00, 0x00, 0x00 };
+	const u8 *power_config;
+	int ret;
+
+	/*
+	 * fw_mutex protects, as part of firmware/config update procedures,
+	 * device transitions to and form bootloader mode and also
+	 * teardown and [re-]creation of input device.
+	 */
+	ret = mutex_lock_interruptible(&data->fw_mutex);
+	if (ret)
+		return ret;
+
+	if (mxt_in_bootloader(data))
+		goto out;
+
+	/*
+	 * Even if device is not in bootloader mode we may not have
+	 * input device created (no memory or something else). While
+	 * we might do something smart with the power in such case, is
+	 * should be not common occurrence so let's treat it the same
+	 * as when device is in bootloader mode and just exit.
+	 */
+	input_dev = data->input_dev;
+	if (!input_dev)
+		goto out;
 
+	/*
+	 * Note that holding mutex here is not strictly necessary
+	 * if inhibit/uninhibit/open/close can only be invoked by
+	 * userspace activity (as they currently are) and not from
+	 * within the kernel, since userspace is stunned during
+	 * system suspend transition. But to be protected against
+	 * possible future changes we are taking the mutex anyway.
+	 */
 	mutex_lock(&input_dev->mutex);
 
-	if (input_dev->users)
+	if (input_dev->inhibited)
+		goto out_unlock_input;
+
+	disable_irq(data->irq);
+
+	mxt_save_all_regs(data);
+
+	/*
+	 * Set T7 to idle mode if we allow wakeup from touch, otherwise
+	 * put it into deepsleep mode.
+	 */
+	power_config = device_may_wakeup(dev) ? T7_config_idle
+					      : T7_config_deepsleep;
+
+	ret = mxt_set_regs(data, MXT_GEN_POWER_T7, 0, 0,
+			   power_config, 3);
+	if (ret)
+		dev_err(dev, "Set T7 Power config failed, %d\n", ret);
+	/*
+	 *  For tpads, save T42 and T19 ctrl registers if may wakeup,
+	 *  enable large object suppression, and disable button wake.
+	 *  This will prevent a lid close from acting as a wake source.
+	 */
+	if (data->is_tp && device_may_wakeup(dev)) {
+		u8 T42_sleep = 0x01;
+		u8 T19_sleep = 0x00;
+		u8 T101_sleep = 0x00;
+
+		/* Enable Large Object Suppression */
+		ret = mxt_set_regs(data, MXT_PROCI_TOUCHSUPPRESSION_T42, 0, 0,
+				   &T42_sleep, 1);
+		if (ret)
+			dev_err(dev, "Set T42 ctrl failed, %d\n", ret);
+
+		/* Disable Touchpad Button via GPIO */
+		ret = mxt_set_regs(data, MXT_SPT_GPIOPWM_T19, 0, 0,
+				   &T19_sleep, 1);
+		if (ret)
+			dev_err(dev, "Set T19 ctrl failed, %d\n", ret);
+
+		/* Disable Hover, if supported */
+		if (is_hovering_supported(data) &&
+		    data->T101_ctrl_valid &&
+		    data->T101_ctrl != T101_sleep) {
+			unsigned long timeout = msecs_to_jiffies(350);
+
+			init_completion(&data->auto_cal_completion);
+			enable_irq(data->irq);
+
+			ret = mxt_set_regs(data, MXT_SPT_TOUCHSCREENHOVER_T101,
+					   0, 0, &T101_sleep, 1);
+			if (ret)
+				dev_err(dev, "Set T101 ctrl failed, %d\n", ret);
+
+			ret = wait_for_completion_interruptible_timeout(
+					&data->auto_cal_completion, timeout);
+			if (ret <= 0)
+				dev_err(dev,
+					"Wait for cal completion failed.\n");
+			disable_irq(data->irq);
+		}
+	} else {
+		data->T42_ctrl_valid = data->T19_ctrl_valid = false;
+	}
+
+	if (device_may_wakeup(dev)) {
+		/*
+		 * If we allow wakeup from touch, we have to enable T9 so
+		 * that IRQ can be generated from touch
+		 */
+
+		/* Set proper T9 ENABLE & REPTN bits */
+		if (data->has_T9 && data->T9_ctrl_valid)
+			mxt_suspend_enable_T9(data, data->T9_ctrl);
+
+		/* Enable wake from IRQ */
+		data->irq_wake = (enable_irq_wake(data->irq) == 0);
+	} else if (input_dev->users) {
 		mxt_stop(data);
+	}
 
+out_unlock_input:
 	mutex_unlock(&input_dev->mutex);
-
+out:
+	mutex_unlock(&data->fw_mutex);
 	return 0;
 }
 
@@ -2216,27 +4062,53 @@
 	struct i2c_client *client = to_i2c_client(dev);
 	struct mxt_data *data = i2c_get_clientdata(client);
 	struct input_dev *input_dev = data->input_dev;
+	int ret = 0;
+
+	ret = mutex_lock_interruptible(&data->fw_mutex);
+	if (ret)
+		return ret;
+
+	if (mxt_in_bootloader(data))
+		goto out;
 
-	mxt_soft_reset(data);
+	input_dev = data->input_dev;
+	if (!input_dev)
+		goto out;
 
 	mutex_lock(&input_dev->mutex);
 
-	if (input_dev->users)
-		mxt_start(data);
+	if (input_dev->inhibited)
+		goto out_unlock_input;
 
-	mutex_unlock(&input_dev->mutex);
+	/* Process any pending message so that CHG line can be de-asserted */
+	ret = mxt_handle_messages(data, false);
+	if (ret)
+		dev_err(dev, "Handling message fails upon resume, %d\n", ret);
+
+	mxt_release_all_fingers(data);
+
+	mxt_restore_all_regs(data);
+
+	/* Recalibration in case of environment change */
+	if (!device_may_wakeup(dev) || is_mxt_33x_t(data))
+		mxt_recalibrate(data);
+
+	enable_irq(data->irq);
+
+	if (data->irq_wake) {
+		disable_irq_wake(data->irq);
+		data->irq_wake = false;
+	}
 
+out_unlock_input:
+	mutex_unlock(&input_dev->mutex);
+out:
+	mutex_unlock(&data->fw_mutex);
 	return 0;
 }
 
 static SIMPLE_DEV_PM_OPS(mxt_pm_ops, mxt_suspend, mxt_resume);
 
-static const struct of_device_id mxt_of_match[] = {
-	{ .compatible = "atmel,maxtouch", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, mxt_of_match);
-
 static const struct i2c_device_id mxt_id[] = {
 	{ "qt602240_ts", 0 },
 	{ "atmel_mxt_ts", 0 },
@@ -2246,19 +4118,46 @@
 };
 MODULE_DEVICE_TABLE(i2c, mxt_id);
 
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id mxt_acpi_id[] = {
+	{ "ATML0000", 0 }, /* Touchpad */
+	{ "ATML0001", 0 }, /* Touchscreen */
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, mxt_acpi_id);
+#endif
+
 static struct i2c_driver mxt_driver = {
 	.driver = {
 		.name	= "atmel_mxt_ts",
 		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(mxt_of_match),
 		.pm	= &mxt_pm_ops,
+		.acpi_match_table = ACPI_PTR(mxt_acpi_id)
 	},
 	.probe		= mxt_probe,
-	.remove		= mxt_remove,
 	.id_table	= mxt_id,
 };
 
-module_i2c_driver(mxt_driver);
+static int __init mxt_init(void)
+{
+	/* Create a global debugfs root for all atmel_mxt_ts devices */
+	mxt_debugfs_root = debugfs_create_dir(mxt_driver.driver.name, NULL);
+	if (mxt_debugfs_root == ERR_PTR(-ENODEV))
+		mxt_debugfs_root = NULL;
+
+	return i2c_add_driver(&mxt_driver);
+}
+
+static void __exit mxt_exit(void)
+{
+	if (mxt_debugfs_root)
+		debugfs_remove_recursive(mxt_debugfs_root);
+
+	i2c_del_driver(&mxt_driver);
+}
+
+module_init(mxt_init);
+module_exit(mxt_exit);
 
 /* Module information */
 MODULE_AUTHOR("Joonyoung Shim <jy0922.shim@samsung.com>");
diff -Naur linux-3.19.old/drivers/platform/chrome/chromeos_laptop.c linux-3.19/drivers/platform/chrome/chromeos_laptop.c
--- linux-3.19.old/drivers/platform/chrome/chromeos_laptop.c	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/drivers/platform/chrome/chromeos_laptop.c	2015-03-23 20:36:55.983730010 -0800
@@ -22,6 +22,7 @@
  */
 
 #include <linux/dmi.h>
+#include <linux/gpio.h>
 #include <linux/i2c.h>
 #include <linux/i2c/atmel_mxt_ts.h>
 #include <linux/input.h>
@@ -42,13 +43,15 @@
 static struct i2c_client *als;
 static struct i2c_client *tp;
 static struct i2c_client *ts;
+static struct i2c_client *nfc;
+static struct i2c_client *codec;
 
 static const char *i2c_adapter_names[] = {
 	"SMBus I801 adapter",
 	"i915 gmbus vga",
 	"i915 gmbus panel",
-	"i2c-designware-pci",
-	"i2c-designware-pci",
+	"i2c-designware-pci-0",
+	"i2c-designware-pci-1",
 };
 
 /* Keep this enum consistent with i2c_adapter_names */
@@ -56,8 +59,8 @@
 	I2C_ADAPTER_SMBUS = 0,
 	I2C_ADAPTER_VGADDC,
 	I2C_ADAPTER_PANEL,
-	I2C_ADAPTER_DESIGNWARE_0,
-	I2C_ADAPTER_DESIGNWARE_1,
+	I2C_ADAPTER_I2C0,
+	I2C_ADAPTER_I2C1,
 };
 
 enum i2c_peripheral_state {
@@ -73,10 +76,11 @@
 	int tries;
 };
 
-#define MAX_I2C_PERIPHERALS 3
+#define MAX_I2C_PERIPHERALS 4
 
 struct chromeos_laptop {
 	struct i2c_peripheral i2c_peripherals[MAX_I2C_PERIPHERALS];
+	bool has_keyboard_backlight;
 };
 
 static struct chromeos_laptop *cros_laptop;
@@ -98,34 +102,13 @@
 	I2C_BOARD_INFO("tsl2563", TAOS_ALS_I2C_ADDR),
 };
 
-static int mxt_t19_keys[] = {
-	KEY_RESERVED,
-	KEY_RESERVED,
-	KEY_RESERVED,
-	KEY_RESERVED,
-	KEY_RESERVED,
-	BTN_LEFT
-};
-
-static struct mxt_platform_data atmel_224s_tp_platform_data = {
-	.irqflags		= IRQF_TRIGGER_FALLING,
-	.t19_num_keys		= ARRAY_SIZE(mxt_t19_keys),
-	.t19_keymap		= mxt_t19_keys,
-};
-
 static struct i2c_board_info atmel_224s_tp_device = {
 	I2C_BOARD_INFO("atmel_mxt_tp", ATMEL_TP_I2C_ADDR),
-	.platform_data = &atmel_224s_tp_platform_data,
 	.flags		= I2C_CLIENT_WAKE,
 };
 
-static struct mxt_platform_data atmel_1664s_platform_data = {
-	.irqflags		= IRQF_TRIGGER_FALLING,
-};
-
 static struct i2c_board_info atmel_1664s_device = {
 	I2C_BOARD_INFO("atmel_mxt_ts", ATMEL_TS_I2C_ADDR),
-	.platform_data = &atmel_1664s_platform_data,
 	.flags		= I2C_CLIENT_WAKE,
 };
 
@@ -160,7 +143,12 @@
 			       __func__, name);
 			return NULL;
 		}
-		info->irq = dev_data->instance;
+
+		/* Use Peripheral IRQ if devfn is 0, otherwise use GPIO IRQ */
+		if (dev_data->devfn != 0)
+			info->irq = gpio_to_irq(dev_data->instance);
+		else
+			info->irq = dev_data->instance;
 	}
 
 	adapter = i2c_get_adapter(bus);
@@ -182,43 +170,29 @@
 	return client;
 }
 
-struct i2c_lookup {
-	const char *name;
-	int instance;
-	int n;
-};
-
 static int __find_i2c_adap(struct device *dev, void *data)
 {
-	struct i2c_lookup *lookup = data;
+	const char *name = data;
 	static const char *prefix = "i2c-";
 	struct i2c_adapter *adapter;
-
 	if (strncmp(dev_name(dev), prefix, strlen(prefix)) != 0)
 		return 0;
 	adapter = to_i2c_adapter(dev);
-	if (strncmp(adapter->name, lookup->name, strlen(lookup->name)) == 0 &&
-	    lookup->n++ == lookup->instance)
-		return 1;
-	return 0;
+	return (strncmp(adapter->name, name, strlen(name)) == 0);
 }
 
 static int find_i2c_adapter_num(enum i2c_adapter_type type)
 {
 	struct device *dev = NULL;
 	struct i2c_adapter *adapter;
-	struct i2c_lookup lookup;
-
-	memset(&lookup, 0, sizeof(lookup));
-	lookup.name = i2c_adapter_names[type];
-	lookup.instance = (type == I2C_ADAPTER_DESIGNWARE_1) ? 1 : 0;
-
+	const char *name = i2c_adapter_names[type];
 	/* find the adapter by name */
-	dev = bus_find_device(&i2c_bus_type, NULL, &lookup, __find_i2c_adap);
+	dev = bus_find_device(&i2c_bus_type, NULL, (void *)name,
+			      __find_i2c_adap);
 	if (!dev) {
 		/* Adapters may appear later. Deferred probing will retry */
 		pr_notice("%s: i2c adapter %s not found on system.\n", __func__,
-			  lookup.name);
+			  name);
 		return -ENODEV;
 	}
 	adapter = to_i2c_adapter(dev);
@@ -255,7 +229,6 @@
 						struct i2c_board_info *info)
 {
 	const unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };
-
 	return __add_probed_i2c_device(name,
 				       find_i2c_adapter_num(type),
 				       info,
@@ -330,6 +303,22 @@
 	return (!als) ? -EAGAIN : 0;
 }
 
+static struct platform_device *kb_backlight_device;
+
+static void setup_keyboard_backlight(void)
+{
+	if (kb_backlight_device)
+		return;
+
+	kb_backlight_device =
+		platform_device_register_simple("chromeos-keyboard-leds",
+						-1, NULL, 0);
+	if (IS_ERR(kb_backlight_device)) {
+		pr_warn("Error registering Chrome OS keyboard LEDs.\n");
+		kb_backlight_device = NULL;
+	}
+}
+
 static int __init chromeos_laptop_dmi_matched(const struct dmi_system_id *id)
 {
 	cros_laptop = (void *)id->driver_data;
@@ -385,6 +374,10 @@
 		}
 	}
 
+	/* Add keyboard backlight device if present. */
+	if (cros_laptop->has_keyboard_backlight)
+		setup_keyboard_backlight();
+
 	return ret;
 }
 
@@ -413,51 +406,61 @@
 		/* Light Sensor. */
 		{ .add = setup_isl29018_als, I2C_ADAPTER_PANEL },
 	},
+	.has_keyboard_backlight = true,
 };
 
-static struct chromeos_laptop hp_chromebook_14 = {
+static struct chromeos_laptop slippy = {
 	.i2c_peripherals = {
+		/* Light Sensor. */
+		{ .add = setup_isl29018_als, I2C_ADAPTER_I2C1 },
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_I2C0 },
 	},
 };
 
-static struct chromeos_laptop dell_chromebook_11 = {
+static struct chromeos_laptop falco = {
 	.i2c_peripherals = {
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_I2C0 },
 	},
 };
 
-static struct chromeos_laptop toshiba_cb35 = {
+static struct chromeos_laptop peppy = {
 	.i2c_peripherals = {
+		/* Touchscreen. */
+		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_I2C1 },
+		/* Light Sensor. */
+		{ .add = setup_isl29018_als, I2C_ADAPTER_I2C1 },
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_I2C0 },
 	},
 };
 
-static struct chromeos_laptop acer_c7_chromebook = {
+static struct chromeos_laptop wolf = {
 	.i2c_peripherals = {
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_I2C0 },
 	},
 };
 
-static struct chromeos_laptop acer_ac700 = {
+static struct chromeos_laptop leon = {
 	.i2c_peripherals = {
-		/* Light Sensor. */
-		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
+		/* Touchpad. */
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_I2C0 },
 	},
 };
 
-static struct chromeos_laptop acer_c720 = {
+static struct chromeos_laptop acer_c7_chromebook = {
 	.i2c_peripherals = {
-		/* Touchscreen. */
-		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_DESIGNWARE_1 },
 		/* Touchpad. */
-		{ .add = setup_cyapa_tp, I2C_ADAPTER_DESIGNWARE_0 },
+		{ .add = setup_cyapa_tp, I2C_ADAPTER_SMBUS },
+	},
+};
+
+static struct chromeos_laptop acer_ac700 = {
+	.i2c_peripherals = {
 		/* Light Sensor. */
-		{ .add = setup_isl29018_als, I2C_ADAPTER_DESIGNWARE_1 },
+		{ .add = setup_tsl2563_als, I2C_ADAPTER_SMBUS },
 	},
 };
 
@@ -475,6 +478,19 @@
 	},
 };
 
+static struct chromeos_laptop bolt = {
+	.i2c_peripherals = {
+		/* Touchscreen. */
+		{ .add = setup_atmel_1664s_ts, I2C_ADAPTER_I2C1 },
+		/* Touchpad. */
+		{ .add = setup_atmel_224s_tp, I2C_ADAPTER_I2C0 },
+		/* Light Sensor. */
+		{ .add = setup_isl29018_als, I2C_ADAPTER_I2C1 },
+	},
+	.has_keyboard_backlight = true,
+};
+
+
 #define _CBDD(board_) \
 	.callback = chromeos_laptop_dmi_matched, \
 	.driver_data = (void *)&board_
@@ -504,28 +520,44 @@
 		_CBDD(chromebook_pixel),
 	},
 	{
-		.ident = "Wolf",
+		.ident = "Slippy",
 		.matches = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Wolf"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Slippy"),
 		},
-		_CBDD(dell_chromebook_11),
+		_CBDD(slippy),
 	},
 	{
-		.ident = "HP Chromebook 14",
+		.ident = "Falco",
 		.matches = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Falco"),
 		},
-		_CBDD(hp_chromebook_14),
+		_CBDD(falco),
+	},
+	{
+		.ident = "Peppy",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Peppy"),
+		},
+		_CBDD(peppy),
 	},
 	{
-		.ident = "Toshiba CB35",
+		.ident = "Wolf",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Wolf"),
+		},
+		_CBDD(wolf),
+	},
+	{
+		.ident = "Leon",
 		.matches = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
 			DMI_MATCH(DMI_PRODUCT_NAME, "Leon"),
 		},
-		_CBDD(toshiba_cb35),
+		_CBDD(leon),
 	},
 	{
 		.ident = "Acer C7 Chromebook",
@@ -542,13 +574,6 @@
 		_CBDD(acer_ac700),
 	},
 	{
-		.ident = "Acer C720",
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_NAME, "Peppy"),
-		},
-		_CBDD(acer_c720),
-	},
-	{
 		.ident = "HP Pavilion 14 Chromebook",
 		.matches = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Butterfly"),
@@ -562,6 +587,14 @@
 		},
 		_CBDD(cr48),
 	},
+	{
+		.ident = "Bolt",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Bolt"),
+		},
+		_CBDD(bolt),
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(dmi, chromeos_laptop_dmi_table);
@@ -571,6 +604,7 @@
 static struct platform_driver cros_platform_driver = {
 	.driver = {
 		.name = "chromeos_laptop",
+		.owner = THIS_MODULE,
 	},
 	.probe = chromeos_laptop_probe,
 };
@@ -578,7 +612,6 @@
 static int __init chromeos_laptop_init(void)
 {
 	int ret;
-
 	if (!dmi_check_system(chromeos_laptop_dmi_table)) {
 		pr_debug("%s unsupported system.\n", __func__);
 		return -ENODEV;
@@ -611,10 +644,16 @@
 {
 	if (als)
 		i2c_unregister_device(als);
+	if (codec)
+		i2c_unregister_device(codec);
+	if (nfc)
+		i2c_unregister_device(nfc);
 	if (tp)
 		i2c_unregister_device(tp);
 	if (ts)
 		i2c_unregister_device(ts);
+	if (kb_backlight_device)
+		platform_device_unregister(kb_backlight_device);
 
 	platform_device_unregister(cros_platform_device);
 	platform_driver_unregister(&cros_platform_driver);
diff -Naur linux-3.19.old/drivers/platform/chrome/chromeos_pstore.c linux-3.19/drivers/platform/chrome/chromeos_pstore.c
--- linux-3.19.old/drivers/platform/chrome/chromeos_pstore.c	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/drivers/platform/chrome/chromeos_pstore.c	2015-03-23 20:36:56.420396676 -0800
@@ -8,6 +8,7 @@
  *  the Free Software Foundation, version 2 of the License.
  */
 
+#include <linux/acpi.h>
 #include <linux/dmi.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
@@ -58,7 +59,7 @@
 static struct ramoops_platform_data chromeos_ramoops_data = {
 	.mem_size	= 0x100000,
 	.mem_address	= 0xf00000,
-	.record_size	= 0x20000,
+	.record_size	= 0x40000,
 	.console_size	= 0x20000,
 	.ftrace_size	= 0x20000,
 	.dump_oops	= 1,
@@ -71,9 +72,60 @@
 	},
 };
 
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id cros_ramoops_acpi_match[] = {
+	{ "GOOG9999", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, cros_ramoops_acpi_match);
+
+static struct platform_driver chromeos_ramoops_acpi = {
+	.driver		= {
+		.name	= "chromeos_pstore",
+		.owner	= THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(cros_ramoops_acpi_match),
+	},
+};
+
+static int __init chromeos_probe_acpi(struct platform_device *pdev)
+{
+	struct resource *res;
+	resource_size_t len;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENOMEM;
+
+	len = resource_size(res);
+	if (!res->start || !len)
+		return -ENOMEM;
+
+	pr_info("chromeos ramoops using acpi device.\n");
+
+	chromeos_ramoops_data.mem_size = len;
+	chromeos_ramoops_data.mem_address = res->start;
+
+	return 0;
+}
+
+static bool __init chromeos_check_acpi(void)
+{
+	if (!platform_driver_probe(&chromeos_ramoops_acpi, chromeos_probe_acpi))
+		return true;
+	return false;
+}
+#else
+static inline bool chromeos_check_acpi(void) { return false; }
+#endif
+
 static int __init chromeos_pstore_init(void)
 {
-	if (dmi_check_system(chromeos_pstore_dmi_table))
+	bool acpi_dev_found;
+
+	/* First check ACPI for non-hardcoded values from firmware. */
+	acpi_dev_found = chromeos_check_acpi();
+
+	if (acpi_dev_found || dmi_check_system(chromeos_pstore_dmi_table))
 		return platform_device_register(&chromeos_ramoops);
 
 	return -ENODEV;
diff -Naur linux-3.19.old/drivers/platform/chrome/Kconfig linux-3.19/drivers/platform/chrome/Kconfig
--- linux-3.19.old/drivers/platform/chrome/Kconfig	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/drivers/platform/chrome/Kconfig	2015-03-23 20:38:33.660396497 -0800
@@ -2,6 +2,10 @@
 # Platform support for Chrome OS hardware (Chromebooks and Chromeboxes)
 #
 
+if X86
+source "drivers/platform/x86/Kconfig"
+endif
+
 menuconfig CHROME_PLATFORMS
 	bool "Platform support for Chrome hardware"
 	depends on X86
diff -Naur linux-3.19.old/drivers/platform/chromeos.c linux-3.19/drivers/platform/chromeos.c
--- linux-3.19.old/drivers/platform/chromeos.c	1969-12-31 14:00:00.000000000 -1000
+++ linux-3.19/drivers/platform/chromeos.c	2015-03-23 20:34:00.373730325 -0800
@@ -0,0 +1,119 @@
+/*
+ *  ChromeOS platform support code. Glue layer between higher level functions
+ *  and per-platform firmware interfaces.
+ *
+ *  Copyright (C) 2010 The Chromium OS Authors
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/chromeos_platform.h>
+#include <linux/module.h>
+#include "chromeos.h"
+
+static struct chromeos_vbc *chromeos_vbc_ptr;
+
+static int vbc_read(u8 *buf, int buf_size);
+static int vbc_write_byte(unsigned offset, u8 value);
+
+/* the following defines are copied from
+ * vboot_reference:firmware/lib/vboot_nvstorage.c.
+ */
+#define RECOVERY_OFFSET              2
+#define VBNV_RECOVERY_RW_INVALID_OS  0x43
+
+int chromeos_set_need_recovery(void)
+{
+	if (!chromeos_legacy_set_need_recovery())
+		return 0;
+
+	return vbc_write_byte(RECOVERY_OFFSET, VBNV_RECOVERY_RW_INVALID_OS);
+}
+
+/*
+ * Lifted from vboot_reference:firmware/lib/vboot_nvstorage.c and formatted.
+ *
+ * Return CRC-8 of the data, using x^8 + x^2 + x + 1 polynomial. A table-based
+ * algorithm would be faster, but for only 15 bytes isn't worth the code size.
+ */
+static u8 crc8(const u8 *data, int len)
+{
+	unsigned crc = 0;
+	int i, j;
+
+	for (j = len; j; j--, data++) {
+		crc ^= (*data << 8);
+		for (i = 8; i; i--) {
+			if (crc & 0x8000)
+				crc ^= (0x1070 << 3);
+			crc <<= 1;
+		}
+	}
+	return (u8)(crc >> 8);
+}
+
+static int vbc_write_byte(unsigned offset, u8 value)
+{
+	u8 buf[MAX_VBOOT_CONTEXT_BUFFER_SIZE];
+	ssize_t size;
+
+	if (!chromeos_vbc_ptr)
+		return -ENOSYS;
+
+	size = vbc_read(buf, sizeof(buf));
+	if (size <= 0)
+		return -EINVAL;
+
+	if (offset >= (size - 1))
+		return -EINVAL;
+
+	if (buf[offset] == value)
+		return 0;
+
+	buf[offset] = value;
+	buf[size - 1] = crc8(buf, size - 1);
+
+	return chromeos_vbc_ptr->write(buf, size);
+}
+
+/*
+ * Read vboot context and verify it.  If everything checks out, return number
+ * of bytes in the vboot context buffer, -1 on any error (uninitialized
+ * subsystem, corrupted crc8 value, not enough room in the buffer, etc.).
+ */
+static int vbc_read(u8 *buf, int buf_size)
+{
+	ssize_t size;
+
+	if (!chromeos_vbc_ptr)
+		return -ENOSYS;
+
+	size = chromeos_vbc_ptr->read(buf, buf_size);
+	if (size <= 0)
+		return -1;
+
+	if (buf[size - 1] != crc8(buf, size - 1)) {
+		pr_err("%s: vboot context contents corrupted\n", __func__);
+		return -1;
+	}
+	return size;
+}
+
+int chromeos_vbc_register(struct chromeos_vbc *chromeos_vbc)
+{
+	chromeos_vbc_ptr = chromeos_vbc;
+	return 0;
+}
diff -Naur linux-3.19.old/drivers/platform/chromeos.h linux-3.19/drivers/platform/chromeos.h
--- linux-3.19.old/drivers/platform/chromeos.h	1969-12-31 14:00:00.000000000 -1000
+++ linux-3.19/drivers/platform/chromeos.h	2015-03-23 20:34:00.373730325 -0800
@@ -0,0 +1,61 @@
+/*
+ *  Copyright (C) 2011 The Chromium OS Authors
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _DRIVERS_PLATFORM_CHROMEOS_H
+#define _DRIVERS_PLATFORM_CHROMEOS_H
+
+#define MAX_VBOOT_CONTEXT_BUFFER_SIZE 64  /* Should be enough for anything. */
+
+#ifdef CONFIG_ACPI_CHROMEOS
+extern int chromeos_legacy_set_need_recovery(void);
+#else
+static inline int chromeos_legacy_set_need_recovery(void) { return -ENODEV; }
+#endif
+
+struct chromeos_vbc {
+	/**
+	 * Read vboot context to buffer
+	 *
+	 * @param buf		Pointer to buffer for storing vboot context
+	 * @param count		Size of buffer
+	 * @return	on success, the number of bytes read is returned and
+	 *		on error, -err is returned.
+	 */
+	ssize_t (*read)(void *buf, size_t count);
+
+	/**
+	 * Write vboot context from buffer
+	 *
+	 * @param buf		Pointer to buffer of new vboot context content
+	 * @param count		Size of buffer
+	 * @return	on success, the number of bytes written is returned and
+	 *		on error, -err is returned.
+	 */
+	ssize_t (*write)(const void *buf, size_t count);
+
+	const char *name;
+};
+
+/**
+ * Register chromeos_vbc callbacks.
+ *
+ * @param chromeos_vbc	Pointer to struct holding callbacks
+ * @return	on success, return 0, on error, -err is returned.
+ */
+int chromeos_vbc_register(struct chromeos_vbc *chromeos_vbc);
+
+#endif /* _DRIVERS_PLATFORM_CHROMEOS_H */
diff -Naur linux-3.19.old/drivers/platform/Kconfig linux-3.19/drivers/platform/Kconfig
--- linux-3.19.old/drivers/platform/Kconfig	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/drivers/platform/Kconfig	2015-03-23 20:45:23.940395767 -0800
@@ -6,3 +6,12 @@
 endif
 
 source "drivers/platform/chrome/Kconfig"
+
+config CHROMEOS
+        bool
+        depends on ARM_CHROMEOS_FIRMWARE || (NVRAM && ACPI_CHROMEOS)
+
+        ---help---
+          Provides abstracted interfaces to the firmware features provided on
+          ChromeOS devices. It depends on a lowlevel driver to implement the
+          firmware interface on the platform.
diff -Naur linux-3.19.old/drivers/platform/Makefile linux-3.19/drivers/platform/Makefile
--- linux-3.19.old/drivers/platform/Makefile	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/drivers/platform/Makefile	2015-03-23 20:45:18.667062440 -0800
@@ -6,3 +6,4 @@
 obj-$(CONFIG_OLPC)		+= olpc/
 obj-$(CONFIG_GOLDFISH)		+= goldfish/
 obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome/
+obj-$(CONFIG_CHROMEOS)          += chromeos.o
diff -Naur linux-3.19.old/drivers/platform/x86/chromeos_acpi.c linux-3.19/drivers/platform/x86/chromeos_acpi.c
--- linux-3.19.old/drivers/platform/x86/chromeos_acpi.c	1969-12-31 14:00:00.000000000 -1000
+++ linux-3.19/drivers/platform/x86/chromeos_acpi.c	2015-03-23 20:39:58.540396342 -0800
@@ -0,0 +1,800 @@
+ /*
+ *  chromeos_acpi.c - ChromeOS specific ACPI support
+ *
+ *
+ * Copyright (C) 2011 The Chromium OS Authors
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * This driver attaches to the ChromeOS ACPI device and the exports the values
+ * reported by the ACPI in a sysfs directory
+ * (/sys/devices/platform/chromeos_acpi).
+ *
+ * The first version of the driver provides only static information; the
+ * values reported by the driver are the snapshot reported by the ACPI at
+ * driver installation time.
+ *
+ * All values are presented in the string form (numbers as decimal values) and
+ * can be accessed as the contents of the appropriate read only files in the
+ * sysfs directory tree originating in /sys/devices/platform/chromeos_acpi.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/nvram.h>
+#include <linux/platform_device.h>
+#include <linux/acpi.h>
+
+#include "../chromeos.h"
+
+#define CHNV_DEBUG_RESET_FLAG	0x40	     /* flag for S3 reboot */
+#define CHNV_RECOVERY_FLAG	0x80	     /* flag for recovery reboot */
+
+#define CHSW_RECOVERY_FW	0x00000002   /* recovery button depressed */
+#define CHSW_RECOVERY_EC	0x00000004   /* recovery button depressed */
+#define CHSW_DEVELOPER_MODE	0x00000020   /* developer switch set */
+#define CHSW_WP			0x00000200   /* write-protect (optional) */
+
+/*
+ * Structure containing one ACPI exported integer along with the validity
+ * flag.
+ */
+struct chromeos_acpi_datum {
+	unsigned cad_value;
+	bool	 cad_is_set;
+};
+
+/*
+ * Structure containing the set of ACPI exported integers required by chromeos
+ * wrapper.
+ */
+struct chromeos_acpi_if {
+	struct chromeos_acpi_datum	switch_state;
+
+	/* chnv is a single byte offset in nvram. exported by older firmware */
+	struct chromeos_acpi_datum	chnv;
+
+	/* vbnv is an address range in nvram, exported by newer firmware */
+	struct chromeos_acpi_datum	nv_base;
+	struct chromeos_acpi_datum	nv_size;
+};
+
+#define MY_LOGPREFIX "chromeos_acpi: "
+#define MY_ERR KERN_ERR MY_LOGPREFIX
+#define MY_NOTICE KERN_NOTICE MY_LOGPREFIX
+#define MY_INFO KERN_INFO MY_LOGPREFIX
+
+/* ACPI method name for MLST; the response for this method is a
+ * package of strings listing the methods which should be reflected in
+ * sysfs. */
+#define MLST_METHOD "MLST"
+
+static const struct acpi_device_id chromeos_device_ids[] = {
+	{"GGL0001", 0}, /* Google's own */
+	{"", 0},
+};
+
+MODULE_DEVICE_TABLE(acpi, chromeos_device_ids);
+
+static int chromeos_device_add(struct acpi_device *device);
+static int chromeos_device_remove(struct acpi_device *device);
+
+static struct chromeos_acpi_if chromeos_acpi_if_data;
+static struct acpi_driver chromeos_acpi_driver = {
+	.name = "ChromeOS Device",
+	.class = "ChromeOS",
+	.ids = chromeos_device_ids,
+	.ops = {
+		.add = chromeos_device_add,
+		.remove = chromeos_device_remove,
+		},
+	.owner = THIS_MODULE,
+};
+
+/* The default list of methods the chromeos ACPI device is supposed to export,
+ * if the MLST method is not present or is poorly formed.  The MLST method
+ * itself is included, to aid in debugging. */
+static char *default_methods[] = {
+	"CHSW", "HWID", "BINF", "GPIO", "CHNV", "FWID", "FRID", MLST_METHOD
+};
+
+/*
+ * Representation of a single sys fs attribute. In addition to the standard
+ * device_attribute structure has a link field, allowing to create a list of
+ * these structures (to keep track for de-allocation when removing the driver)
+ * and a pointer to the actual attribute value, reported when accessing the
+ * appropriate sys fs file
+ */
+struct acpi_attribute {
+	struct device_attribute dev_attr;
+	struct acpi_attribute *next_acpi_attr;
+	char *value;
+};
+
+/*
+ * Representation of a sys fs attribute group (a sub directory in the device's
+ * sys fs directory). In addition to the standard structure has a link to
+ * allow to keep track of the allocated structures.
+ */
+struct acpi_attribute_group {
+	struct attribute_group ag;
+	struct acpi_attribute_group *next_acpi_attr_group;
+};
+
+/*
+ * ChromeOS ACPI device wrapper adds links pointing at lists of allocated
+ * attributes and attribute groups.
+ */
+struct chromeos_acpi_dev {
+	struct platform_device *p_dev;
+	struct acpi_attribute *attributes;
+	struct acpi_attribute_group *groups;
+};
+
+static struct chromeos_acpi_dev chromeos_acpi = { };
+
+static bool chromeos_on_legacy_firmware(void)
+{
+	/*
+	 * Presense of the CHNV ACPI element implies running on a legacy
+	 * firmware
+	 */
+	return chromeos_acpi_if_data.chnv.cad_is_set;
+}
+
+/*
+ * This function operates on legacy BIOSes which do not export VBNV element
+ * through ACPI. These BIOSes use a fixed location in NVRAM to contain a
+ * bitmask of known flags.
+ *
+ * @flag - the bitmask to set, it is the responsibility of the caller to set
+ *         the proper bits.
+ *
+ * returns 0 on success (is running in legacy mode and chnv is initialized) or
+ *         -1 otherwise.
+ */
+static int chromeos_set_nvram_flag(u8 flag)
+{
+	u8 cur;
+	unsigned index = chromeos_acpi_if_data.chnv.cad_value;
+
+	if (!chromeos_on_legacy_firmware())
+		return -ENODEV;
+
+	cur = nvram_read_byte(index);
+
+	if ((cur & flag) != flag)
+		nvram_write_byte(cur | flag, index);
+	return 0;
+}
+
+int chromeos_legacy_set_need_recovery(void)
+{
+	return chromeos_set_nvram_flag(CHNV_RECOVERY_FLAG);
+}
+
+/*
+ * Read the nvram buffer contents into the user provided space.
+ *
+ * retrun number of bytes copied, or -1 on any error.
+ */
+static ssize_t chromeos_vbc_nvram_read(void *buf, size_t count)
+{
+
+	int base, size, i;
+
+	if (!chromeos_acpi_if_data.nv_base.cad_is_set ||
+	    !chromeos_acpi_if_data.nv_size.cad_is_set) {
+		printk(MY_ERR "%s: NVRAM not configured!\n", __func__);
+		return -ENODEV;
+	}
+
+	base = chromeos_acpi_if_data.nv_base.cad_value;
+	size = chromeos_acpi_if_data.nv_size.cad_value;
+
+	if (count < size) {
+		pr_err("%s: not enough room to read nvram (%zd < %d)\n",
+		       __func__, count, size);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < size; i++)
+		((u8 *)buf)[i] = nvram_read_byte(base++);
+
+	return size;
+}
+
+static ssize_t chromeos_vbc_nvram_write(const void *buf, size_t count)
+{
+	unsigned base, size, i;
+
+	if (!chromeos_acpi_if_data.nv_base.cad_is_set ||
+	    !chromeos_acpi_if_data.nv_size.cad_is_set) {
+		printk(MY_ERR "%s: NVRAM not configured!\n", __func__);
+		return -ENODEV;
+	}
+
+	size = chromeos_acpi_if_data.nv_size.cad_value;
+	base = chromeos_acpi_if_data.nv_base.cad_value;
+
+	if (count != size) {
+		printk(MY_ERR "%s: wrong buffer size (%zd != %d)!\n", __func__,
+		       count, size);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < size; i++) {
+		u8 c;
+
+		c = nvram_read_byte(base + i);
+		if (c == ((u8 *)buf)[i])
+			continue;
+		nvram_write_byte(((u8 *)buf)[i], base + i);
+	}
+	return size;
+}
+
+/*
+ * To show attribute value just access the container structure's `value'
+ * field.
+ */
+static ssize_t show_acpi_attribute(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct acpi_attribute *paa;
+
+	paa = container_of(attr, struct acpi_attribute, dev_attr);
+	return snprintf(buf, PAGE_SIZE, paa->value);
+}
+
+/*
+ * create_sysfs_attribute() create and initialize an ACPI sys fs attribute
+ *			    structure.
+ * @value: attribute value
+ * @name: base attribute name
+ * @count: total number of instances of this attribute
+ * @instance: instance number of this particular attribute
+ *
+ * This function allocates and initializes the structure containing all
+ * information necessary to add a sys fs attribute. In case the attribute has
+ * just a single instance, the attribute file name is equal to the @name
+ * parameter . In case the attribute has several instances, the attribute
+ * file name is @name.@instance.
+ *
+ * Returns: a pointer to the allocated and initialized structure, or null if
+ * allocation failed.
+ *
+ * As a side effect, the allocated structure is added to the list in the
+ * chromeos_acpi structure. Note that the actual attribute creation is not
+ * attempted yet, in case of creation error the structure would not have an
+ * actual attribute associated with it, so when de-installing the driver this
+ * structure would be used to try to remove an attribute which does not exist.
+ * This is considered acceptable, as there is no reason for sys fs attribute
+ * creation failure.
+ */
+static struct acpi_attribute *create_sysfs_attribute(char *value, char *name,
+						     int count, int instance)
+{
+	struct acpi_attribute *paa;
+	int total_size, room_left;
+	int value_len = strlen(value);
+
+	if (!value_len)
+		return NULL;
+
+	value_len++; /* include the terminating zero */
+
+	/*
+	 * total allocation size includes (all strings with including
+	 * terminating zeros):
+	 *
+	 * - value string
+	 * - attribute structure size
+	 * - name string
+	 * - suffix string (in case there are multiple instances)
+	 * - dot separating the instance suffix
+	 */
+
+	total_size = value_len + sizeof(struct acpi_attribute) +
+			strlen(name) + 1;
+
+	if (count != 1) {
+		if (count >= 1000) {
+			printk(MY_ERR "%s: too many (%d) instances of %s\n",
+			       __func__, count, name);
+			return NULL;
+		}
+		/* allow up to three digits and the dot */
+		total_size += 4;
+	}
+
+	paa = kzalloc(total_size, GFP_KERNEL);
+	if (!paa) {
+		printk(MY_ERR "out of memory in %s!\n", __func__);
+		return NULL;
+	}
+
+	sysfs_attr_init(&paa->dev_attr.attr);
+	paa->dev_attr.attr.mode = 0444;  /* read only */
+	paa->dev_attr.show = show_acpi_attribute;
+	paa->value = (char *)(paa + 1);
+	strcpy(paa->value, value);
+	paa->dev_attr.attr.name = paa->value + value_len;
+
+	room_left = total_size - value_len -
+			offsetof(struct acpi_attribute, value);
+
+	if (count == 1) {
+		snprintf((char *)paa->dev_attr.attr.name, room_left, name);
+	} else {
+		snprintf((char *)paa->dev_attr.attr.name, room_left,
+			 "%s.%d", name, instance);
+	}
+
+	paa->next_acpi_attr = chromeos_acpi.attributes;
+	chromeos_acpi.attributes = paa;
+
+	return paa;
+}
+
+/*
+ * add_sysfs_attribute() create and initialize an ACPI sys fs attribute
+ *			    structure and create the attribute.
+ * @value: attribute value
+ * @name: base attribute name
+ * @count: total number of instances of this attribute
+ * @instance: instance number of this particular attribute
+ */
+
+static void add_sysfs_attribute(char *value, char *name,
+				int count, int instance)
+{
+	struct acpi_attribute *paa =
+	    create_sysfs_attribute(value, name, count, instance);
+
+	if (!paa)
+		return;
+
+	if (device_create_file(&chromeos_acpi.p_dev->dev, &paa->dev_attr))
+		printk(MY_ERR "failed to create attribute for %s\n", name);
+}
+
+/*
+ * handle_nested_acpi_package() create sysfs group including attributes
+ *				representing a nested ACPI package.
+ *
+ * @po: package contents as returned by ACPI
+ * @pm: name of the group
+ * @total: number of instances of this package
+ * @instance: instance number of this particular group
+ *
+ * The created group is called @pm in case there is a single instance, or
+ * @pm.@instance otherwise.
+ *
+ * All group and attribute storage allocations are included in the lists for
+ * tracking of allocated memory.
+ */
+static void handle_nested_acpi_package(union acpi_object *po, char *pm,
+				       int total, int instance)
+{
+	int i, size, count, j;
+	struct acpi_attribute_group *aag;
+
+	count = po->package.count;
+
+	size = strlen(pm) + 1 + sizeof(struct acpi_attribute_group) +
+	    sizeof(struct attribute *) * (count + 1);
+
+	if (total != 1) {
+		if (total >= 1000) {
+			printk(MY_ERR "%s: too many (%d) instances of %s\n",
+			       __func__, total, pm);
+			return;
+		}
+		/* allow up to three digits and the dot */
+		size += 4;
+	}
+
+	aag = kzalloc(size, GFP_KERNEL);
+	if (!aag) {
+		printk(MY_ERR "out of memory in %s!\n", __func__);
+		return;
+	}
+
+	aag->next_acpi_attr_group = chromeos_acpi.groups;
+	chromeos_acpi.groups = aag->next_acpi_attr_group;
+	aag->ag.attrs = (struct attribute **)(aag + 1);
+	aag->ag.name = (const char *)&aag->ag.attrs[count + 1];
+
+	/* room left in the buffer */
+	size = size - (aag->ag.name - (char *)aag);
+
+	if (total != 1)
+		snprintf((char *)aag->ag.name, size, "%s.%d", pm, instance);
+	else
+		snprintf((char *)aag->ag.name, size, "%s", pm);
+
+	j = 0;			/* attribute index */
+	for (i = 0; i < count; i++) {
+		union acpi_object *element = po->package.elements + i;
+		int copy_size = 0;
+		char attr_value[40];	/* 40 chars be enough for names */
+		struct acpi_attribute *paa;
+
+		switch (element->type) {
+		case ACPI_TYPE_INTEGER:
+			copy_size = snprintf(attr_value, sizeof(attr_value),
+					     "%d", (int)element->integer.value);
+			paa = create_sysfs_attribute(attr_value, pm, count, i);
+			break;
+
+		case ACPI_TYPE_STRING:
+			copy_size = min(element->string.length,
+					(u32)(sizeof(attr_value)) - 1);
+			memcpy(attr_value, element->string.pointer, copy_size);
+			attr_value[copy_size] = '\0';
+			paa = create_sysfs_attribute(attr_value, pm, count, i);
+			break;
+
+		default:
+			printk(MY_ERR "ignoring nested type %d\n",
+			       element->type);
+			continue;
+		}
+		aag->ag.attrs[j++] = &paa->dev_attr.attr;
+	}
+
+	if (sysfs_create_group(&chromeos_acpi.p_dev->dev.kobj, &aag->ag))
+		printk(MY_ERR "failed to create group %s.%d\n", pm, instance);
+}
+
+/*
+ * maybe_export_acpi_int() export a single int value when required
+ *
+ * @pm: name of the package
+ * @index: index of the element of the package
+ * @value: value of the element
+ */
+static void maybe_export_acpi_int(const char *pm, int index, unsigned value)
+{
+	int i;
+	struct chromeos_acpi_exported_ints {
+		const char *acpi_name;
+		int acpi_index;
+		struct chromeos_acpi_datum *cad;
+	} exported_ints[] = {
+		{ "VBNV", 0, &chromeos_acpi_if_data.nv_base },
+		{ "VBNV", 1, &chromeos_acpi_if_data.nv_size },
+		{ "CHSW", 0, &chromeos_acpi_if_data.switch_state },
+		{ "CHNV", 0, &chromeos_acpi_if_data.chnv }
+	};
+
+	for (i = 0; i < ARRAY_SIZE(exported_ints); i++) {
+		struct chromeos_acpi_exported_ints *exported_int;
+
+		exported_int = exported_ints + i;
+
+		if (!strncmp(pm, exported_int->acpi_name, 4) &&
+		    (exported_int->acpi_index == index)) {
+			printk(MY_NOTICE "registering %s %d\n", pm, index);
+			exported_int->cad->cad_value = value;
+			exported_int->cad->cad_is_set = true;
+			return;
+		}
+	}
+}
+
+/*
+ * acpi_buffer_to_string() convert contents of an ACPI buffer element into a
+ *		hex string truncating it if necessary to fit into one page.
+ *
+ * @element: an acpi element known to contain an ACPI buffer.
+ *
+ * Returns: pointer to an ASCII string containing the buffer representation
+ *	    (whatever fit into PAGE_SIZE). The caller is responsible for
+ *	    freeing the memory.
+ */
+static char *acpi_buffer_to_string(union acpi_object *element)
+{
+	char *base, *p;
+	int i;
+	unsigned room_left;
+	/* Include this many characters per line */
+	unsigned char_per_line = 16;
+	unsigned blob_size;
+	unsigned string_buffer_size;
+
+	/*
+	 * As of now the VDAT structure can supply as much as 3700 bytes. When
+	 * expressed as a hex dump it becomes 3700 * 3 + 3700/16 + .. which
+	 * clearly exceeds the maximum allowed sys fs buffer size of one page
+	 * (4k).
+	 *
+	 * What this means is that we can't keep the entire blob in one sysfs
+	 * file. Currently verified boot (the consumer of the VDAT contents)
+	 * does not care about the most of the data, so as a quick fix we will
+	 * truncate it here. Once the blob data beyond the 4K boundary is
+	 * required this approach will have to be reworked.
+	 *
+	 * TODO(vbendeb): Split the data into multiple VDAT instances, each
+	 * not exceeding 4K or consider exporting as a binary using
+	 * sysfs_create_bin_file().
+	 */
+
+	/*
+	 * X, the maximum number of bytes which will fit into a sysfs file
+	 * (one memory page) can be derived from the following equation (where
+	 * N is number of bytes included in every hex string):
+	 *
+	 * 3X + X/N + 4 <= PAGE_SIZE.
+	 *
+	 * Solving this for X gives the following
+	 */
+	blob_size = ((PAGE_SIZE - 4) * char_per_line) / (char_per_line * 3 + 1);
+
+	if (element->buffer.length > blob_size)
+		printk(MY_INFO "truncating buffer from %d to %d\n",
+		       element->buffer.length, blob_size);
+	else
+		blob_size = element->buffer.length;
+
+	string_buffer_size =
+		/* three characters to display one byte */
+		blob_size * 3 +
+		/* one newline per line, all rounded up, plus
+		 * extra newline in the end, plus terminating
+		 * zero, hence + 4
+		 */
+		blob_size/char_per_line + 4;
+
+	p = kzalloc(string_buffer_size, GFP_KERNEL);
+	if (!p) {
+		printk(MY_ERR "out of memory in %s!\n", __func__);
+		return NULL;
+	}
+
+	base = p;
+	room_left = string_buffer_size;
+	for (i = 0; i < blob_size; i++) {
+		int printed;
+		printed = snprintf(p, room_left, " %2.2x",
+				   element->buffer.pointer[i]);
+		room_left -= printed;
+		p += printed;
+		if (((i + 1) % char_per_line) == 0) {
+			if (!room_left)
+				break;
+			room_left--;
+			*p++ = '\n';
+		}
+	}
+	if (room_left < 2) {
+		printk(MY_ERR "%s: no room in the buffer!\n", __func__);
+		*p = '\0';
+	} else {
+		*p++ = '\n';
+		*p++ = '\0';
+	}
+	return base;
+}
+
+/*
+ * handle_acpi_package() create sysfs group including attributes
+ *			 representing an ACPI package.
+ *
+ * @po: package contents as returned by ACPI
+ * @pm: name of the group
+ *
+ * Scalar objects included in the package get sys fs attributes created for
+ * them. Nested packages are passed to a function creating a sys fs group per
+ * package.
+ */
+static void handle_acpi_package(union acpi_object *po, char *pm)
+{
+	int j;
+	int count = po->package.count;
+	for (j = 0; j < count; j++) {
+		union acpi_object *element = po->package.elements + j;
+		int copy_size = 0;
+		char attr_value[256];	/* strings could be this long */
+
+		switch (element->type) {
+		case ACPI_TYPE_INTEGER:
+			copy_size = snprintf(attr_value, sizeof(attr_value),
+					     "%d", (int)element->integer.value);
+			add_sysfs_attribute(attr_value, pm, count, j);
+			maybe_export_acpi_int(pm, j, (unsigned)
+					      element->integer.value);
+			break;
+
+		case ACPI_TYPE_STRING:
+			copy_size = min(element->string.length,
+					(u32)(sizeof(attr_value)) - 1);
+			memcpy(attr_value, element->string.pointer, copy_size);
+			attr_value[copy_size] = '\0';
+			add_sysfs_attribute(attr_value, pm, count, j);
+			break;
+
+		case ACPI_TYPE_BUFFER: {
+			char *buf_str;
+			buf_str = acpi_buffer_to_string(element);
+			if (buf_str) {
+				add_sysfs_attribute(buf_str, pm, count, j);
+				kfree(buf_str);
+			}
+			break;
+		}
+		case ACPI_TYPE_PACKAGE:
+			handle_nested_acpi_package(element, pm, count, j);
+			break;
+
+		default:
+			printk(MY_ERR "ignoring type %d (%s)\n",
+			       element->type, pm);
+			break;
+		}
+	}
+}
+
+
+/*
+ * add_acpi_method() evaluate an ACPI method and create sysfs attributes.
+ *
+ * @device: ACPI device
+ * @pm: name of the method to evaluate
+ */
+static void add_acpi_method(struct acpi_device *device, char *pm)
+{
+	acpi_status status;
+	struct acpi_buffer output;
+	union acpi_object *po;
+
+	output.length = ACPI_ALLOCATE_BUFFER;
+	output.pointer = NULL;
+
+	status = acpi_evaluate_object(device->handle, pm, NULL, &output);
+
+	if (!ACPI_SUCCESS(status)) {
+		printk(MY_ERR "failed to retrieve %s (%d)\n", pm, status);
+		return;
+	}
+
+	po = output.pointer;
+
+	if (po->type != ACPI_TYPE_PACKAGE)
+		printk(MY_ERR "%s is not a package, ignored\n", pm);
+	else
+		handle_acpi_package(po, pm);
+	kfree(output.pointer);
+}
+
+/*
+ * chromeos_process_mlst() Evaluate the MLST method and add methods listed
+ *                         in the response.
+ *
+ * @device: ACPI device
+ *
+ * Returns: 0 if successful, non-zero if error.
+ */
+static int chromeos_process_mlst(struct acpi_device *device)
+{
+	acpi_status status;
+	struct acpi_buffer output;
+	union acpi_object *po;
+	int j;
+
+	output.length = ACPI_ALLOCATE_BUFFER;
+	output.pointer = NULL;
+
+	status = acpi_evaluate_object(device->handle, MLST_METHOD, NULL,
+				      &output);
+	if (!ACPI_SUCCESS(status)) {
+		pr_debug(MY_LOGPREFIX "failed to retrieve MLST (%d)\n",
+			 status);
+		return 1;
+	}
+
+	po = output.pointer;
+	if (po->type != ACPI_TYPE_PACKAGE) {
+		printk(MY_ERR MLST_METHOD "is not a package, ignored\n");
+		kfree(output.pointer);
+		return -EINVAL;
+	}
+
+	for (j = 0; j < po->package.count; j++) {
+		union acpi_object *element = po->package.elements + j;
+		int copy_size = 0;
+		char method[ACPI_NAME_SIZE + 1];
+
+		if (element->type == ACPI_TYPE_STRING) {
+			copy_size = min(element->string.length,
+					(u32)ACPI_NAME_SIZE);
+			memcpy(method, element->string.pointer, copy_size);
+			method[copy_size] = '\0';
+			add_acpi_method(device, method);
+		} else {
+			pr_debug(MY_LOGPREFIX "ignoring type %d\n",
+				 element->type);
+		}
+	}
+
+	kfree(output.pointer);
+	return 0;
+}
+
+static int chromeos_device_add(struct acpi_device *device)
+{
+	int i;
+
+	/* Attempt to add methods by querying the device's MLST method
+	 * for the list of methods. */
+	if (!chromeos_process_mlst(device))
+		return 0;
+
+	printk(MY_INFO "falling back to default list of methods\n");
+	for (i = 0; i < ARRAY_SIZE(default_methods); i++)
+		add_acpi_method(device, default_methods[i]);
+	return 0;
+}
+
+static int chromeos_device_remove(struct acpi_device *device)
+{
+	return 0;
+}
+
+static struct chromeos_vbc chromeos_vbc_nvram = {
+	.name = "chromeos_vbc_nvram",
+	.read = chromeos_vbc_nvram_read,
+	.write = chromeos_vbc_nvram_write,
+};
+
+static int __init chromeos_acpi_init(void)
+{
+	int ret = 0;
+	acpi_status status;
+
+	if (acpi_disabled)
+		return -ENODEV;
+
+	ret = chromeos_vbc_register(&chromeos_vbc_nvram);
+	if (ret)
+		return ret;
+
+	chromeos_acpi.p_dev = platform_device_register_simple("chromeos_acpi",
+							      -1, NULL, 0);
+	if (IS_ERR(chromeos_acpi.p_dev)) {
+		printk(MY_ERR "unable to register platform device\n");
+		return PTR_ERR(chromeos_acpi.p_dev);
+	}
+
+	ret = acpi_bus_register_driver(&chromeos_acpi_driver);
+	if (ret < 0) {
+		printk(MY_ERR "failed to register driver (%d)\n", ret);
+		platform_device_unregister(chromeos_acpi.p_dev);
+		chromeos_acpi.p_dev = NULL;
+		return ret;
+	}
+	printk(MY_INFO "installed%s\n",
+	       chromeos_on_legacy_firmware() ? " (legacy mode)" : "");
+
+	printk(MY_INFO "chromeos_acpi: enabling S3 USB wake\n");
+	status = acpi_evaluate_object(NULL, "\\S3UE", NULL, NULL);
+	if (!ACPI_SUCCESS(status))
+		printk(MY_INFO "chromeos_acpi: failed to enable S3 USB wake\n");
+
+	return 0;
+}
+
+subsys_initcall(chromeos_acpi_init);
diff -Naur linux-3.19.old/drivers/platform/x86/Kconfig linux-3.19/drivers/platform/x86/Kconfig
--- linux-3.19.old/drivers/platform/x86/Kconfig	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/drivers/platform/x86/Kconfig	2015-03-23 20:40:44.617062933 -0800
@@ -734,6 +734,13 @@
 	  along with the CPU frequency and i915 drivers, provides that
 	  functionality.  If in doubt, say Y here; it will only load on
 	  supported platforms.
+config ACPI_CHROMEOS
+        bool "ChromeOS specific ACPI extensions"
+        depends on ACPI
+        select CHROMEOS
+        ---help---
+          This driver provides the firmware interface for the services exported
+          through the CHROMEOS interfaces when using ChromeOS ACPI firmware.
 
 config IBM_RTL
 	tristate "Device driver to enable PRTL support"
diff -Naur linux-3.19.old/drivers/platform/x86/Makefile linux-3.19/drivers/platform/x86/Makefile
--- linux-3.19.old/drivers/platform/x86/Makefile	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/drivers/platform/x86/Makefile	2015-03-23 20:40:15.213729651 -0800
@@ -55,6 +55,7 @@
 obj-$(CONFIG_APPLE_GMUX)	+= apple-gmux.o
 obj-$(CONFIG_INTEL_RST)		+= intel-rst.o
 obj-$(CONFIG_INTEL_SMARTCONNECT)	+= intel-smartconnect.o
+obj-$(CONFIG_ACPI_CHROMEOS)     += chromeos_acpi.o
 
 obj-$(CONFIG_PVPANIC)           += pvpanic.o
 obj-$(CONFIG_ALIENWARE_WMI)	+= alienware-wmi.o
diff -Naur linux-3.19.old/include/linux/chromeos_platform.h linux-3.19/include/linux/chromeos_platform.h
--- linux-3.19.old/include/linux/chromeos_platform.h	1969-12-31 14:00:00.000000000 -1000
+++ linux-3.19/include/linux/chromeos_platform.h	2015-03-23 20:53:49.520394836 -0800
@@ -0,0 +1,27 @@
+#ifndef _LINUX_CHROMEOS_PLATFORM_H
+#define _LINUX_CHROMEOS_PLATFORM_H
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_CHROMEOS
+/*
+ * ChromeOS platform support code. Glue layer between higher level functions
+ * and per-platform firmware interfaces.
+ */
+
+/*
+ * Set the taint bit telling firmware that the currently running side needs
+ * recovery (or reinstall).
+ */
+extern int chromeos_set_need_recovery(void);
+
+#else
+
+static inline int chromeos_set_need_recovery(void)
+{
+	return -ENODEV;
+}
+#endif /* CONFIG_CHROMEOS */
+
+#endif /* _LINUX_CHROMEOS_PLATFORM_H */
diff -Naur linux-3.19.old/include/linux/i2c/atmel_mxt_ts.h linux-3.19/include/linux/i2c/atmel_mxt_ts.h
--- linux-3.19.old/include/linux/i2c/atmel_mxt_ts.h	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/include/linux/i2c/atmel_mxt_ts.h	2015-03-23 20:52:27.353728335 -0800
@@ -15,11 +15,35 @@
 
 #include <linux/types.h>
 
+/* For key_map array */
+#define MXT_NUM_GPIO		4
+
+/* Orient */
+#define MXT_NORMAL		0x0
+#define MXT_DIAGONAL		0x1
+#define MXT_HORIZONTAL_FLIP	0x2
+#define MXT_ROTATED_90_COUNTER	0x3
+#define MXT_VERTICAL_FLIP	0x4
+#define MXT_ROTATED_90		0x5
+#define MXT_ROTATED_180		0x6
+#define MXT_DIAGONAL_COUNTER	0x7
+
 /* The platform data for the Atmel maXTouch touchscreen driver */
 struct mxt_platform_data {
+	const u8 *config;
+	size_t config_length;
+
+	unsigned int x_line;
+	unsigned int y_line;
+	unsigned int x_size;
+	unsigned int y_size;
+	unsigned int blen;
+	unsigned int threshold;
+	unsigned int voltage;
+	unsigned char orient;
 	unsigned long irqflags;
-	u8 t19_num_keys;
-	const unsigned int *t19_keymap;
+	bool is_tp;
+	const unsigned int key_map[MXT_NUM_GPIO];
 };
 
 #endif /* __LINUX_ATMEL_MXT_TS_H */
diff -Naur linux-3.19.old/include/linux/input.h linux-3.19/include/linux/input.h
--- linux-3.19.old/include/linux/input.h	2015-02-08 17:54:22.000000000 -0900
+++ linux-3.19/include/linux/input.h	2015-03-23 21:39:20.257056614 -0800
@@ -117,6 +117,10 @@
  * @vals: array of values queued in the current frame
  * @devres_managed: indicates that devices is managed with devres framework
  *	and needs not be explicitly unregistered or freed.
+ * @inhibit: method to ignore all events and power off device.
+ *      inhibit..uninhibit are always called outside of suspend..resume.
+ * @uninhibit: undo effects of inhibit
+ * @inhibited: whether the input device is currently inhibited
  */
 struct input_dev {
 	const char *name;
@@ -187,6 +191,11 @@
 	struct input_value *vals;
 
 	bool devres_managed;
+
+	int (*inhibit)(struct input_dev *dev);
+	int (*uninhibit)(struct input_dev *dev);
+
+	bool inhibited;
 };
 #define to_input_dev(d) container_of(d, struct input_dev, dev)
 
